0100 typedef unsigned int   uint;
0101 typedef unsigned short ushort;
0102 typedef unsigned char  uchar;
0103 typedef uint pde_t;
0104 
0105 
0106 
0107 
0108 
0109 
0110 
0111 
0112 
0113 
0114 
0115 
0116 
0117 
0118 
0119 
0120 
0121 
0122 
0123 
0124 
0125 
0126 
0127 
0128 
0129 
0130 
0131 
0132 
0133 
0134 
0135 
0136 
0137 
0138 
0139 
0140 
0141 
0142 
0143 
0144 
0145 
0146 
0147 
0148 
0149 
0150 #define NPROC        64  
0151 #define KSTACKSIZE 4096  
0152 #define NCPU          8  
0153 #define NOFILE       16  
0154 #define NFILE       100  
0155 #define NINODE       50  
0156 #define NDEV         10  
0157 #define ROOTDEV       1  
0158 #define MAXARG       32  
0159 #define MAXOPBLOCKS  10  
0160 #define LOGSIZE      (MAXOPBLOCKS*3)  
0161 #define NBUF         (MAXOPBLOCKS*3)  
0162 #define FSSIZE       1000  
0163 
0164 
0165 
0166 
0167 
0168 
0169 
0170 
0171 
0172 
0173 
0174 
0175 
0176 
0177 
0178 
0179 
0180 
0181 
0182 
0183 
0184 
0185 
0186 
0187 
0188 
0189 
0190 
0191 
0192 
0193 
0194 
0195 
0196 
0197 
0198 
0199 
0200 
0201 
0202 #define EXTMEM  0x100000            
0203 #define PHYSTOP 0xE000000           
0204 #define DEVSPACE 0xFE000000         
0205 
0206 
0207 #define KERNBASE 0x80000000         
0208 #define KERNLINK (KERNBASE+EXTMEM)  
0209 
0210 #define V2P(a) (((uint) (a)) - KERNBASE)
0211 #define P2V(a) ((void *)(((char *) (a)) + KERNBASE))
0212 
0213 #define V2P_WO(x) ((x) - KERNBASE)    
0214 #define P2V_WO(x) ((x) + KERNBASE)    
0215 
0216 
0217 
0218 
0219 
0220 
0221 
0222 
0223 
0224 
0225 
0226 
0227 
0228 
0229 
0230 
0231 
0232 
0233 
0234 
0235 
0236 
0237 
0238 
0239 
0240 
0241 
0242 
0243 
0244 
0245 
0246 
0247 
0248 
0249 
0250 struct buf;
0251 struct context;
0252 struct file;
0253 struct inode;
0254 struct pipe;
0255 struct proc;
0256 struct rtcdate;
0257 struct spinlock;
0258 struct sleeplock;
0259 struct stat;
0260 struct superblock;
0261 
0262 
0263 void            binit(void);
0264 struct buf*     bread(uint, uint);
0265 void            brelse(struct buf*);
0266 void            bwrite(struct buf*);
0267 
0268 
0269 void            consoleinit(void);
0270 void            cprintf(char*, ...);
0271 void            consoleintr(int(*)(void));
0272 void            panic(char*) __attribute__((noreturn));
0273 
0274 
0275 int             exec(char*, char**);
0276 
0277 
0278 struct file*    filealloc(void);
0279 void            fileclose(struct file*);
0280 struct file*    filedup(struct file*);
0281 void            fileinit(void);
0282 int             fileread(struct file*, char*, int n);
0283 int             filestat(struct file*, struct stat*);
0284 int             filewrite(struct file*, char*, int n);
0285 
0286 
0287 void            readsb(int dev, struct superblock *sb);
0288 int             dirlink(struct inode*, char*, uint);
0289 struct inode*   dirlookup(struct inode*, char*, uint*);
0290 struct inode*   ialloc(uint, short);
0291 struct inode*   idup(struct inode*);
0292 void            iinit(int dev);
0293 void            ilock(struct inode*);
0294 void            iput(struct inode*);
0295 void            iunlock(struct inode*);
0296 void            iunlockput(struct inode*);
0297 void            iupdate(struct inode*);
0298 int             namecmp(const char*, const char*);
0299 struct inode*   namei(char*);
0300 struct inode*   nameiparent(char*, char*);
0301 int             readi(struct inode*, char*, uint, uint);
0302 void            stati(struct inode*, struct stat*);
0303 int             writei(struct inode*, char*, uint, uint);
0304 
0305 
0306 void            ideinit(void);
0307 void            ideintr(void);
0308 void            iderw(struct buf*);
0309 
0310 
0311 void            ioapicenable(int irq, int cpu);
0312 extern uchar    ioapicid;
0313 void            ioapicinit(void);
0314 
0315 
0316 char*           kalloc(void);
0317 void            kfree(char*);
0318 void            kinit1(void*, void*);
0319 void            kinit2(void*, void*);
0320 
0321 
0322 void            kbdintr(void);
0323 
0324 
0325 void            cmostime(struct rtcdate *r);
0326 int             lapicid(void);
0327 extern volatile uint*    lapic;
0328 void            lapiceoi(void);
0329 void            lapicinit(void);
0330 void            lapicstartap(uchar, uint);
0331 void            microdelay(int);
0332 
0333 
0334 void            initlog(int dev);
0335 void            log_write(struct buf*);
0336 void            begin_op();
0337 void            end_op();
0338 
0339 
0340 extern int      ismp;
0341 void            mpinit(void);
0342 
0343 
0344 void            picenable(int);
0345 void            picinit(void);
0346 
0347 
0348 
0349 
0350 
0351 int             pipealloc(struct file**, struct file**);
0352 void            pipeclose(struct pipe*, int);
0353 int             piperead(struct pipe*, char*, int);
0354 int             pipewrite(struct pipe*, char*, int);
0355 
0356 
0357 
0358 int             cpuid(void);
0359 void            exit(void);
0360 int             fork(void);
0361 int             growproc(int);
0362 int             kill(int);
0363 struct cpu*     mycpu(void);
0364 struct proc*    myproc();
0365 void            pinit(void);
0366 void            procdump(void);
0367 void            scheduler(void) __attribute__((noreturn));
0368 void            sched(void);
0369 void            setproc(struct proc*);
0370 void            sleep(void*, struct spinlock*);
0371 void            userinit(void);
0372 int             wait(void);
0373 void            wakeup(void*);
0374 void            yield(void);
0375 
0376 void            greet(void);
0377 void*           growproc_lazy(int);
0378 
0379 
0380 void            swtch(struct context**, struct context*);
0381 
0382 
0383 void            acquire(struct spinlock*);
0384 void            getcallerpcs(void*, uint*);
0385 int             holding(struct spinlock*);
0386 void            initlock(struct spinlock*, char*);
0387 void            release(struct spinlock*);
0388 void            pushcli(void);
0389 void            popcli(void);
0390 
0391 
0392 void            acquiresleep(struct sleeplock*);
0393 void            releasesleep(struct sleeplock*);
0394 int             holdingsleep(struct sleeplock*);
0395 void            initsleeplock(struct sleeplock*, char*);
0396 
0397 
0398 
0399 
0400 
0401 int             memcmp(const void*, const void*, uint);
0402 void*           memmove(void*, const void*, uint);
0403 void*           memset(void*, int, uint);
0404 char*           safestrcpy(char*, const char*, int);
0405 int             strlen(const char*);
0406 int             strncmp(const char*, const char*, uint);
0407 char*           strncpy(char*, const char*, int);
0408 
0409 
0410 int             argint(int, int*);
0411 int             argptr(int, char**, int);
0412 int             argstr(int, char**);
0413 int             fetchint(uint, int*);
0414 int             fetchstr(uint, char**);
0415 void            syscall(void);
0416 
0417 
0418 void            timerinit(void);
0419 
0420 
0421 void            idtinit(void);
0422 extern uint     ticks;
0423 void            tvinit(void);
0424 extern struct spinlock tickslock;
0425 
0426 
0427 void            uartinit(void);
0428 void            uartintr(void);
0429 void            uartputc(int);
0430 
0431 
0432 void            seginit(void);
0433 void            kvmalloc(void);
0434 pde_t*          setupkvm(void);
0435 char*           uva2ka(pde_t*, char*);
0436 int             allocuvm(pde_t*, uint, uint);
0437 int             deallocuvm(pde_t*, uint, uint);
0438 void            freevm(pde_t*);
0439 void            inituvm(pde_t*, char*, uint);
0440 int             loaduvm(pde_t*, char*, struct inode*, uint, uint);
0441 pde_t*          copyuvm(pde_t*, uint);
0442 void            switchuvm(struct proc*);
0443 void            switchkvm(void);
0444 int             copyout(pde_t*, uint, void*, uint);
0445 void            clearpteu(pde_t *pgdir, char *uva);
0446 int             sys_numvp(void);
0447 int             sys_numpp(void);
0448 int             getptsize(void);
0449 int             sys_mmap(void);
0450 int             allocuvm_lazy(pde_t *pgdir, uint oldsz, uint newsz);
0451 int             sys_munmap(void);
0452 
0453 
0454 #define NELEM(x) (sizeof(x)/sizeof((x)[0]))
0455 
0456 
0457 
0458 
0459 
0460 
0461 
0462 
0463 
0464 
0465 
0466 
0467 
0468 
0469 
0470 
0471 
0472 
0473 
0474 
0475 
0476 
0477 
0478 
0479 
0480 
0481 
0482 
0483 
0484 
0485 
0486 
0487 
0488 
0489 
0490 
0491 
0492 
0493 
0494 
0495 
0496 
0497 
0498 
0499 
0500 
0501 
0502 static inline uchar
0503 inb(ushort port)
0504 {
0505   uchar data;
0506 
0507   asm volatile("in %1,%0" : "=a" (data) : "d" (port));
0508   return data;
0509 }
0510 
0511 static inline void
0512 insl(int port, void *addr, int cnt)
0513 {
0514   asm volatile("cld; rep insl" :
0515                "=D" (addr), "=c" (cnt) :
0516                "d" (port), "0" (addr), "1" (cnt) :
0517                "memory", "cc");
0518 }
0519 
0520 static inline void
0521 outb(ushort port, uchar data)
0522 {
0523   asm volatile("out %0,%1" : : "a" (data), "d" (port));
0524 }
0525 
0526 static inline void
0527 outw(ushort port, ushort data)
0528 {
0529   asm volatile("out %0,%1" : : "a" (data), "d" (port));
0530 }
0531 
0532 static inline void
0533 outsl(int port, const void *addr, int cnt)
0534 {
0535   asm volatile("cld; rep outsl" :
0536                "=S" (addr), "=c" (cnt) :
0537                "d" (port), "0" (addr), "1" (cnt) :
0538                "cc");
0539 }
0540 
0541 static inline void
0542 stosb(void *addr, int data, int cnt)
0543 {
0544   asm volatile("cld; rep stosb" :
0545                "=D" (addr), "=c" (cnt) :
0546                "0" (addr), "1" (cnt), "a" (data) :
0547                "memory", "cc");
0548 }
0549 
0550 static inline void
0551 stosl(void *addr, int data, int cnt)
0552 {
0553   asm volatile("cld; rep stosl" :
0554                "=D" (addr), "=c" (cnt) :
0555                "0" (addr), "1" (cnt), "a" (data) :
0556                "memory", "cc");
0557 }
0558 
0559 struct segdesc;
0560 
0561 static inline void
0562 lgdt(struct segdesc *p, int size)
0563 {
0564   volatile ushort pd[3];
0565 
0566   pd[0] = size-1;
0567   pd[1] = (uint)p;
0568   pd[2] = (uint)p >> 16;
0569 
0570   asm volatile("lgdt (%0)" : : "r" (pd));
0571 }
0572 
0573 struct gatedesc;
0574 
0575 static inline void
0576 lidt(struct gatedesc *p, int size)
0577 {
0578   volatile ushort pd[3];
0579 
0580   pd[0] = size-1;
0581   pd[1] = (uint)p;
0582   pd[2] = (uint)p >> 16;
0583 
0584   asm volatile("lidt (%0)" : : "r" (pd));
0585 }
0586 
0587 static inline void
0588 ltr(ushort sel)
0589 {
0590   asm volatile("ltr %0" : : "r" (sel));
0591 }
0592 
0593 static inline uint
0594 readeflags(void)
0595 {
0596   uint eflags;
0597   asm volatile("pushfl; popl %0" : "=r" (eflags));
0598   return eflags;
0599 }
0600 static inline void
0601 loadgs(ushort v)
0602 {
0603   asm volatile("movw %0, %%gs" : : "r" (v));
0604 }
0605 
0606 static inline void
0607 cli(void)
0608 {
0609   asm volatile("cli");
0610 }
0611 
0612 static inline void
0613 sti(void)
0614 {
0615   asm volatile("sti");
0616 }
0617 
0618 static inline uint
0619 xchg(volatile uint *addr, uint newval)
0620 {
0621   uint result;
0622 
0623   
0624   asm volatile("lock; xchgl %0, %1" :
0625                "+m" (*addr), "=a" (result) :
0626                "1" (newval) :
0627                "cc");
0628   return result;
0629 }
0630 
0631 static inline uint
0632 rcr2(void)
0633 {
0634   uint val;
0635   asm volatile("movl %%cr2,%0" : "=r" (val));
0636   return val;
0637 }
0638 
0639 static inline void
0640 lcr3(uint val)
0641 {
0642   asm volatile("movl %0,%%cr3" : : "r" (val));
0643 }
0644 
0645 
0646 
0647 
0648 
0649 
0650 
0651 
0652 struct trapframe {
0653   
0654   uint edi;
0655   uint esi;
0656   uint ebp;
0657   uint oesp;      
0658   uint ebx;
0659   uint edx;
0660   uint ecx;
0661   uint eax;
0662 
0663   
0664   ushort gs;
0665   ushort padding1;
0666   ushort fs;
0667   ushort padding2;
0668   ushort es;
0669   ushort padding3;
0670   ushort ds;
0671   ushort padding4;
0672   uint trapno;
0673 
0674   
0675   uint err;
0676   uint eip;
0677   ushort cs;
0678   ushort padding5;
0679   uint eflags;
0680 
0681   
0682   uint esp;
0683   ushort ss;
0684   ushort padding6;
0685 };
0686 
0687 
0688 
0689 
0690 
0691 
0692 
0693 
0694 
0695 
0696 
0697 
0698 
0699 
0700 
0701 
0702 
0703 
0704 #define SEG_NULLASM                                             \
0705         .word 0, 0;                                             \
0706         .byte 0, 0, 0, 0
0707 
0708 
0709 
0710 #define SEG_ASM(type,base,lim)                                  \
0711         .word (((lim) >> 12) & 0xffff), ((base) & 0xffff);      \
0712         .byte (((base) >> 16) & 0xff), (0x90 | (type)),         \
0713                 (0xC0 | (((lim) >> 28) & 0xf)), (((base) >> 24) & 0xff)
0714 
0715 #define STA_X     0x8       
0716 #define STA_W     0x2       
0717 #define STA_R     0x2       
0718 
0719 
0720 
0721 
0722 
0723 
0724 
0725 
0726 
0727 
0728 
0729 
0730 
0731 
0732 
0733 
0734 
0735 
0736 
0737 
0738 
0739 
0740 
0741 
0742 
0743 
0744 
0745 
0746 
0747 
0748 
0749 
0750 
0751 
0752 
0753 
0754 #define FL_IF           0x00000200      
0755 
0756 
0757 #define CR0_PE          0x00000001      
0758 #define CR0_WP          0x00010000      
0759 #define CR0_PG          0x80000000      
0760 
0761 #define CR4_PSE         0x00000010      
0762 
0763 
0764 #define SEG_KCODE 1  
0765 #define SEG_KDATA 2  
0766 #define SEG_UCODE 3  
0767 #define SEG_UDATA 4  
0768 #define SEG_TSS   5  
0769 
0770 
0771 #define NSEGS     6
0772 
0773 #ifndef __ASSEMBLER__
0774 
0775 struct segdesc {
0776   uint lim_15_0 : 16;  
0777   uint base_15_0 : 16; 
0778   uint base_23_16 : 8; 
0779   uint type : 4;       
0780   uint s : 1;          
0781   uint dpl : 2;        
0782   uint p : 1;          
0783   uint lim_19_16 : 4;  
0784   uint avl : 1;        
0785   uint rsv1 : 1;       
0786   uint db : 1;         
0787   uint g : 1;          
0788   uint base_31_24 : 8; 
0789 };
0790 
0791 
0792 
0793 
0794 
0795 
0796 
0797 
0798 
0799 
0800 
0801 #define SEG(type, base, lim, dpl) (struct segdesc)    \
0802 { ((lim) >> 12) & 0xffff, (uint)(base) & 0xffff,      \
0803   ((uint)(base) >> 16) & 0xff, type, 1, dpl, 1,       \
0804   (uint)(lim) >> 28, 0, 0, 1, 1, (uint)(base) >> 24 }
0805 #define SEG16(type, base, lim, dpl) (struct segdesc)  \
0806 { (lim) & 0xffff, (uint)(base) & 0xffff,              \
0807   ((uint)(base) >> 16) & 0xff, type, 1, dpl, 1,       \
0808   (uint)(lim) >> 16, 0, 0, 1, 0, (uint)(base) >> 24 }
0809 #endif
0810 
0811 #define DPL_USER    0x3     
0812 
0813 
0814 #define STA_X       0x8     
0815 #define STA_W       0x2     
0816 #define STA_R       0x2     
0817 
0818 
0819 #define STS_T32A    0x9     
0820 #define STS_IG32    0xE     
0821 #define STS_TG32    0xF     
0822 
0823 
0824 
0825 
0826 
0827 
0828 
0829 
0830 
0831 
0832 #define PDX(va)         (((uint)(va) >> PDXSHIFT) & 0x3FF)
0833 
0834 
0835 #define PTX(va)         (((uint)(va) >> PTXSHIFT) & 0x3FF)
0836 
0837 
0838 #define PGADDR(d, t, o) ((uint)((d) << PDXSHIFT | (t) << PTXSHIFT | (o)))
0839 
0840 
0841 #define NPDENTRIES      1024    
0842 #define NPTENTRIES      1024    
0843 #define PGSIZE          4096    
0844 
0845 #define PTXSHIFT        12      
0846 #define PDXSHIFT        22      
0847 
0848 #define PGROUNDUP(sz)  (((sz)+PGSIZE-1) & ~(PGSIZE-1))
0849 #define PGROUNDDOWN(a) (((a)) & ~(PGSIZE-1))
0850 
0851 #define PTE_P           0x001   
0852 #define PTE_W           0x002   
0853 #define PTE_U           0x004   
0854 #define PTE_PS          0x080   
0855 #define PTE_LAZY        0x200   
0856 
0857 
0858 #define PTE_ADDR(pte)   ((uint)(pte) & ~0xFFF)
0859 #define PTE_FLAGS(pte)  ((uint)(pte) &  0xFFF)
0860 
0861 #ifndef __ASSEMBLER__
0862 typedef uint pte_t;
0863 
0864 
0865 struct taskstate {
0866   uint link;         
0867   uint esp0;         
0868   ushort ss0;        
0869   ushort padding1;
0870   uint *esp1;
0871   ushort ss1;
0872   ushort padding2;
0873   uint *esp2;
0874   ushort ss2;
0875   ushort padding3;
0876   void *cr3;         
0877   uint *eip;         
0878   uint eflags;
0879   uint eax;          
0880   uint ecx;
0881   uint edx;
0882   uint ebx;
0883   uint *esp;
0884   uint *ebp;
0885   uint esi;
0886   uint edi;
0887   ushort es;         
0888   ushort padding4;
0889   ushort cs;
0890   ushort padding5;
0891   ushort ss;
0892   ushort padding6;
0893   ushort ds;
0894   ushort padding7;
0895   ushort fs;
0896   ushort padding8;
0897   ushort gs;
0898   ushort padding9;
0899   ushort ldt;
0900   ushort padding10;
0901   ushort t;          
0902   ushort iomb;       
0903 };
0904 
0905 
0906 struct gatedesc {
0907   uint off_15_0 : 16;   
0908   uint cs : 16;         
0909   uint args : 5;        
0910   uint rsv1 : 3;        
0911   uint type : 4;        
0912   uint s : 1;           
0913   uint dpl : 2;         
0914   uint p : 1;           
0915   uint off_31_16 : 16;  
0916 };
0917 
0918 
0919 
0920 
0921 
0922 
0923 
0924 
0925 
0926 #define SETGATE(gate, istrap, sel, off, d)                \
0927 {                                                         \
0928   (gate).off_15_0 = (uint)(off) & 0xffff;                \
0929   (gate).cs = (sel);                                      \
0930   (gate).args = 0;                                        \
0931   (gate).rsv1 = 0;                                        \
0932   (gate).type = (istrap) ? STS_TG32 : STS_IG32;           \
0933   (gate).s = 0;                                           \
0934   (gate).dpl = (d);                                       \
0935   (gate).p = 1;                                           \
0936   (gate).off_31_16 = (uint)(off) >> 16;                  \
0937 }
0938 
0939 #endif
0940 
0941 
0942 
0943 
0944 
0945 
0946 
0947 
0948 
0949 
0950 
0951 
0952 #define ELF_MAGIC 0x464C457FU  
0953 
0954 
0955 struct elfhdr {
0956   uint magic;  
0957   uchar elf[12];
0958   ushort type;
0959   ushort machine;
0960   uint version;
0961   uint entry;
0962   uint phoff;
0963   uint shoff;
0964   uint flags;
0965   ushort ehsize;
0966   ushort phentsize;
0967   ushort phnum;
0968   ushort shentsize;
0969   ushort shnum;
0970   ushort shstrndx;
0971 };
0972 
0973 
0974 struct proghdr {
0975   uint type;
0976   uint off;
0977   uint vaddr;
0978   uint paddr;
0979   uint filesz;
0980   uint memsz;
0981   uint flags;
0982   uint align;
0983 };
0984 
0985 
0986 #define ELF_PROG_LOAD           1
0987 
0988 
0989 #define ELF_PROG_FLAG_EXEC      1
0990 #define ELF_PROG_FLAG_WRITE     2
0991 #define ELF_PROG_FLAG_READ      4
0992 
0993 
0994 
0995 
0996 
0997 
0998 
0999 
1000 struct rtcdate {
1001   uint second;
1002   uint minute;
1003   uint hour;
1004   uint day;
1005   uint month;
1006   uint year;
1007 };
1008 
1009 
1010 
1011 
1012 
1013 
1014 
1015 
1016 
1017 
1018 
1019 
1020 
1021 
1022 
1023 
1024 
1025 
1026 
1027 
1028 
1029 
1030 
1031 
1032 
1033 
1034 
1035 
1036 
1037 
1038 
1039 
1040 
1041 
1042 
1043 
1044 
1045 
1046 
1047 
1048 
1049 
1050 
1051 
1052 
1053 
1054 
1055 
1056 
1057 
1058 
1059 
1060 
1061 
1062 
1063 
1064 
1065 
1066 
1067 
1068 
1069 
1070 
1071 
1072 
1073 
1074 
1075 
1076 .p2align 2
1077 .text
1078 .globl multiboot_header
1079 multiboot_header:
1080   
1081   
1082   .long magic
1083   .long flags
1084   .long (-magic-flags)
1085 
1086 
1087 
1088 
1089 .globl _start
1090 _start = V2P_WO(entry)
1091 
1092 
1093 .globl entry
1094 entry:
1095   
1096   movl    %cr4, %eax
1097   orl     $(CR4_PSE), %eax
1098   movl    %eax, %cr4
1099   
1100   movl    $(V2P_WO(entrypgdir)), %eax
1101   movl    %eax, %cr3
1102   
1103   movl    %cr0, %eax
1104   orl     $(CR0_PG|CR0_WP), %eax
1105   movl    %eax, %cr0
1106 
1107   
1108   movl $(stack + KSTACKSIZE), %esp
1109 
1110   
1111   
1112   
1113   
1114   mov $main, %eax
1115   jmp *%eax
1116 
1117 .comm stack, KSTACKSIZE
1118 
1119 
1120 
1121 
1122 
1123 
1124 
1125 
1126 
1127 
1128 
1129 
1130 
1131 
1132 
1133 
1134 
1135 
1136 
1137 
1138 
1139 
1140 
1141 
1142 
1143 
1144 
1145 
1146 
1147 
1148 
1149 
1150 
1151 
1152 
1153 
1154 
1155 
1156 
1157 
1158 
1159 
1160 
1161 
1162 
1163 
1164 
1165 
1166 
1167 
1168 
1169 
1170 
1171 .code16
1172 .globl start
1173 start:
1174   cli
1175 
1176   
1177   xorw    %ax,%ax
1178   movw    %ax,%ds
1179   movw    %ax,%es
1180   movw    %ax,%ss
1181 
1182   
1183   
1184   
1185   lgdt    gdtdesc
1186   movl    %cr0, %eax
1187   orl     $CR0_PE, %eax
1188   movl    %eax, %cr0
1189 
1190   
1191   
1192   
1193   ljmpl    $(SEG_KCODE<<3), $(start32)
1194 
1195 
1196 
1197 
1198 
1199 
1200 .code32  
1201 start32:
1202   
1203   movw    $(SEG_KDATA<<3), %ax    
1204   movw    %ax, %ds                
1205   movw    %ax, %es                
1206   movw    %ax, %ss                
1207   movw    $0, %ax                 
1208   movw    %ax, %fs                
1209   movw    %ax, %gs                
1210 
1211   
1212   movl    %cr4, %eax
1213   orl     $(CR4_PSE), %eax
1214   movl    %eax, %cr4
1215   
1216   movl    (start-12), %eax
1217   movl    %eax, %cr3
1218   
1219   movl    %cr0, %eax
1220   orl     $(CR0_PE|CR0_PG|CR0_WP), %eax
1221   movl    %eax, %cr0
1222 
1223   
1224   movl    (start-4), %esp
1225   
1226   call	 *(start-8)
1227 
1228   movw    $0x8a00, %ax
1229   movw    %ax, %dx
1230   outw    %ax, %dx
1231   movw    $0x8ae0, %ax
1232   outw    %ax, %dx
1233 spin:
1234   jmp     spin
1235 
1236 .p2align 2
1237 gdt:
1238   SEG_NULLASM
1239   SEG_ASM(STA_X|STA_R, 0, 0xffffffff)
1240   SEG_ASM(STA_W, 0, 0xffffffff)
1241 
1242 
1243 gdtdesc:
1244   .word   (gdtdesc - gdt - 1)
1245   .long   gdt
1246 
1247 
1248 
1249 
1250 #include "types.h"
1251 #include "defs.h"
1252 #include "param.h"
1253 #include "memlayout.h"
1254 #include "mmu.h"
1255 #include "proc.h"
1256 #include "x86.h"
1257 
1258 static void startothers(void);
1259 static void mpmain(void)  __attribute__((noreturn));
1260 extern pde_t *kpgdir;
1261 extern char end[]; 
1262 
1263 
1264 
1265 
1266 int
1267 main(void)
1268 {
1269   kinit1(end, P2V(4*1024*1024)); 
1270   kvmalloc();      
1271   mpinit();        
1272   lapicinit();     
1273   seginit();       
1274   picinit();       
1275   ioapicinit();    
1276   consoleinit();   
1277   uartinit();      
1278   pinit();         
1279   tvinit();        
1280   binit();         
1281   fileinit();      
1282   ideinit();       
1283   startothers();   
1284   kinit2(P2V(4*1024*1024), P2V(PHYSTOP)); 
1285   userinit();      
1286   mpmain();        
1287 }
1288 
1289 
1290 static void
1291 mpenter(void)
1292 {
1293   switchkvm();
1294   seginit();
1295   lapicinit();
1296   mpmain();
1297 }
1298 
1299 
1300 
1301 static void
1302 mpmain(void)
1303 {
1304   cprintf("cpu%d: starting %d\n", cpuid(), cpuid());
1305   idtinit();       
1306   xchg(&(mycpu()->started), 1); 
1307   scheduler();     
1308 }
1309 
1310 pde_t entrypgdir[];  
1311 
1312 
1313 static void
1314 startothers(void)
1315 {
1316   extern uchar _binary_entryother_start[], _binary_entryother_size[];
1317   uchar *code;
1318   struct cpu *c;
1319   char *stack;
1320 
1321   
1322   
1323   
1324   code = P2V(0x7000);
1325   memmove(code, _binary_entryother_start, (uint)_binary_entryother_size);
1326 
1327   for(c = cpus; c < cpus+ncpu; c++){
1328     if(c == mycpu())  
1329       continue;
1330 
1331     
1332     
1333     
1334     stack = kalloc();
1335     *(void**)(code-4) = stack + KSTACKSIZE;
1336     *(void(**)(void))(code-8) = mpenter;
1337     *(int**)(code-12) = (void *) V2P(entrypgdir);
1338 
1339     lapicstartap(c->apicid, V2P(code));
1340 
1341     
1342     while(c->started == 0)
1343       ;
1344   }
1345 }
1346 
1347 
1348 
1349 
1350 
1351 
1352 
1353 
1354 
1355 __attribute__((__aligned__(PGSIZE)))
1356 pde_t entrypgdir[NPDENTRIES] = {
1357   
1358   [0] = (0) | PTE_P | PTE_W | PTE_PS,
1359   
1360   [KERNBASE>>PDXSHIFT] = (0) | PTE_P | PTE_W | PTE_PS,
1361 };
1362 
1363 
1364 
1365 
1366 
1367 
1368 
1369 
1370 
1371 
1372 
1373 
1374 
1375 
1376 
1377 
1378 
1379 
1380 
1381 
1382 
1383 
1384 
1385 
1386 
1387 
1388 
1389 
1390 
1391 
1392 
1393 
1394 
1395 
1396 
1397 
1398 
1399 
1400 
1401 
1402 
1403 
1404 
1405 
1406 
1407 
1408 
1409 
1410 
1411 
1412 
1413 
1414 
1415 
1416 
1417 
1418 
1419 
1420 
1421 
1422 
1423 
1424 
1425 
1426 
1427 
1428 
1429 
1430 
1431 
1432 
1433 
1434 
1435 
1436 
1437 
1438 
1439 
1440 
1441 
1442 
1443 
1444 
1445 
1446 
1447 
1448 
1449 
1450 
1451 
1452 
1453 
1454 
1455 
1456 
1457 
1458 
1459 
1460 
1461 
1462 
1463 
1464 
1465 
1466 
1467 
1468 
1469 
1470 
1471 
1472 
1473 
1474 
1475 
1476 
1477 
1478 
1479 
1480 
1481 
1482 
1483 
1484 
1485 
1486 
1487 
1488 
1489 
1490 
1491 
1492 
1493 
1494 
1495 
1496 
1497 
1498 
1499 
1500 
1501 
1502 
1503 
1504 
1505 
1506 
1507 
1508 
1509 
1510 
1511 
1512 
1513 
1514 
1515 
1516 
1517 
1518 
1519 
1520 
1521 
1522 
1523 
1524 
1525 
1526 
1527 
1528 
1529 
1530 
1531 
1532 
1533 
1534 
1535 
1536 
1537 
1538 
1539 
1540 
1541 
1542 
1543 
1544 
1545 
1546 
1547 
1548 
1549 
1550 
1551 struct spinlock {
1552   uint locked;       
1553 
1554   
1555   char *name;        
1556   struct cpu *cpu;   
1557   uint pcs[10];      
1558                      
1559 };
1560 
1561 
1562 
1563 
1564 
1565 
1566 
1567 
1568 
1569 
1570 
1571 
1572 
1573 
1574 
1575 
1576 
1577 
1578 
1579 
1580 
1581 
1582 
1583 
1584 
1585 
1586 
1587 
1588 
1589 
1590 
1591 
1592 
1593 
1594 
1595 
1596 
1597 
1598 
1599 
1600 
1601 
1602 #include "types.h"
1603 #include "defs.h"
1604 #include "param.h"
1605 #include "x86.h"
1606 #include "memlayout.h"
1607 #include "mmu.h"
1608 #include "proc.h"
1609 #include "spinlock.h"
1610 
1611 void
1612 initlock(struct spinlock *lk, char *name)
1613 {
1614   lk->name = name;
1615   lk->locked = 0;
1616   lk->cpu = 0;
1617 }
1618 
1619 
1620 
1621 
1622 
1623 void
1624 acquire(struct spinlock *lk)
1625 {
1626   pushcli(); 
1627   if(holding(lk))
1628     panic("acquire");
1629 
1630   
1631   while(xchg(&lk->locked, 1) != 0)
1632     ;
1633 
1634   
1635   
1636   
1637   __sync_synchronize();
1638 
1639   
1640   lk->cpu = mycpu();
1641   getcallerpcs(&lk, lk->pcs);
1642 }
1643 
1644 
1645 
1646 
1647 
1648 
1649 
1650 
1651 void
1652 release(struct spinlock *lk)
1653 {
1654   if(!holding(lk))
1655     panic("release");
1656 
1657   lk->pcs[0] = 0;
1658   lk->cpu = 0;
1659 
1660   
1661   
1662   
1663   
1664   
1665   __sync_synchronize();
1666 
1667   
1668   
1669   
1670   asm volatile("movl $0, %0" : "+m" (lk->locked) : );
1671 
1672   popcli();
1673 }
1674 
1675 
1676 void
1677 getcallerpcs(void *v, uint pcs[])
1678 {
1679   uint *ebp;
1680   int i;
1681 
1682   ebp = (uint*)v - 2;
1683   for(i = 0; i < 10; i++){
1684     if(ebp == 0 || ebp < (uint*)KERNBASE || ebp == (uint*)0xffffffff)
1685       break;
1686     pcs[i] = ebp[1];     
1687     ebp = (uint*)ebp[0]; 
1688   }
1689   for(; i < 10; i++)
1690     pcs[i] = 0;
1691 }
1692 
1693 
1694 
1695 
1696 
1697 
1698 
1699 
1700 
1701 int
1702 holding(struct spinlock *lock)
1703 {
1704   int r;
1705   pushcli();
1706   r = lock->locked && lock->cpu == mycpu();
1707   popcli();
1708   return r;
1709 }
1710 
1711 
1712 
1713 
1714 
1715 
1716 void
1717 pushcli(void)
1718 {
1719   int eflags;
1720 
1721   eflags = readeflags();
1722   cli();
1723   if(mycpu()->ncli == 0)
1724     mycpu()->intena = eflags & FL_IF;
1725   mycpu()->ncli += 1;
1726 }
1727 
1728 void
1729 popcli(void)
1730 {
1731   if(readeflags()&FL_IF)
1732     panic("popcli - interruptible");
1733   if(--mycpu()->ncli < 0)
1734     panic("popcli");
1735   if(mycpu()->ncli == 0 && mycpu()->intena)
1736     sti();
1737 }
1738 
1739 
1740 
1741 
1742 
1743 
1744 
1745 
1746 
1747 
1748 
1749 
1750 #include "param.h"
1751 #include "types.h"
1752 #include "defs.h"
1753 #include "x86.h"
1754 #include "memlayout.h"
1755 #include "mmu.h"
1756 #include "proc.h"
1757 #include "elf.h"
1758 
1759 extern char data[];  
1760 pde_t *kpgdir;  
1761 
1762 
1763 
1764 void
1765 seginit(void)
1766 {
1767   struct cpu *c;
1768 
1769   
1770   
1771   
1772   
1773   c = &cpus[cpuid()];
1774   c->gdt[SEG_KCODE] = SEG(STA_X|STA_R, 0, 0xffffffff, 0);
1775   c->gdt[SEG_KDATA] = SEG(STA_W, 0, 0xffffffff, 0);
1776   c->gdt[SEG_UCODE] = SEG(STA_X|STA_R, 0, 0xffffffff, DPL_USER);
1777   c->gdt[SEG_UDATA] = SEG(STA_W, 0, 0xffffffff, DPL_USER);
1778   lgdt(c->gdt, sizeof(c->gdt));
1779 }
1780 
1781 
1782 
1783 
1784 static pte_t *
1785 walkpgdir(pde_t *pgdir, const void *va, int alloc)
1786 {
1787   pde_t *pde;
1788   pte_t *pgtab;
1789 
1790   pde = &pgdir[PDX(va)];
1791   if(*pde & PTE_P){
1792     pgtab = (pte_t*)P2V(PTE_ADDR(*pde));
1793   } else {
1794     if(!alloc || (pgtab = (pte_t*)kalloc()) == 0)
1795       return 0;
1796     
1797     memset(pgtab, 0, PGSIZE);
1798     
1799     
1800     
1801     *pde = V2P(pgtab) | PTE_P | PTE_W | PTE_U;
1802   }
1803   return &pgtab[PTX(va)];
1804 }
1805 
1806 
1807 
1808 
1809 static int
1810 mappages(pde_t *pgdir, void *va, uint size, uint pa, int perm)
1811 {
1812   char *a, *last;
1813   pte_t *pte;
1814 
1815   a = (char*)PGROUNDDOWN((uint)va);
1816   last = (char*)PGROUNDDOWN(((uint)va) + size - 1);
1817   for(;;){
1818     if((pte = walkpgdir(pgdir, a, 1)) == 0)
1819       return -1;
1820     if(*pte & PTE_P)
1821       panic("remap");
1822     *pte = pa | perm | PTE_P;
1823     if(a == last)
1824       break;
1825     a += PGSIZE;
1826     pa += PGSIZE;
1827   }
1828   return 0;
1829 }
1830 
1831 
1832 
1833 
1834 
1835 
1836 
1837 
1838 
1839 
1840 
1841 
1842 
1843 
1844 
1845 
1846 
1847 
1848 
1849 
1850 
1851 
1852 
1853 
1854 static struct kmap {
1855   void *virt;
1856   uint phys_start;
1857   uint phys_end;
1858   int perm;
1859 } kmap[] = {
1860  { (void*)KERNBASE, 0,             EXTMEM,    PTE_W}, 
1861  { (void*)KERNLINK, V2P(KERNLINK), V2P(data), 0},     
1862  { (void*)data,     V2P(data),     PHYSTOP,   PTE_W}, 
1863  { (void*)DEVSPACE, DEVSPACE,      0,         PTE_W}, 
1864 };
1865 
1866 
1867 pde_t*
1868 setupkvm(void)
1869 {
1870   pde_t *pgdir;
1871   struct kmap *k;
1872 
1873   if((pgdir = (pde_t*)kalloc()) == 0)
1874     return 0;
1875   memset(pgdir, 0, PGSIZE);
1876   if (P2V(PHYSTOP) > (void*)DEVSPACE)
1877     panic("PHYSTOP too high");
1878   for(k = kmap; k < &kmap[NELEM(kmap)]; k++)
1879     if(mappages(pgdir, k->virt, k->phys_end - k->phys_start,
1880                 (uint)k->phys_start, k->perm) < 0) {
1881       freevm(pgdir);
1882       return 0;
1883     }
1884   return pgdir;
1885 }
1886 
1887 
1888 
1889 void
1890 kvmalloc(void)
1891 {
1892   kpgdir = setupkvm();
1893   switchkvm();
1894 }
1895 
1896 
1897 
1898 
1899 
1900 
1901 
1902 void
1903 switchkvm(void)
1904 {
1905   lcr3(V2P(kpgdir));   
1906 }
1907 
1908 
1909 void
1910 switchuvm(struct proc *p)
1911 {
1912   if(p == 0)
1913     panic("switchuvm: no process");
1914   if(p->kstack == 0)
1915     panic("switchuvm: no kstack");
1916   if(p->pgdir == 0)
1917     panic("switchuvm: no pgdir");
1918 
1919   pushcli();
1920   mycpu()->gdt[SEG_TSS] = SEG16(STS_T32A, &mycpu()->ts,
1921                                 sizeof(mycpu()->ts)-1, 0);
1922   mycpu()->gdt[SEG_TSS].s = 0;
1923   mycpu()->ts.ss0 = SEG_KDATA << 3;
1924   mycpu()->ts.esp0 = (uint)p->kstack + KSTACKSIZE;
1925   
1926   
1927   mycpu()->ts.iomb = (ushort) 0xFFFF;
1928   ltr(SEG_TSS << 3);
1929   lcr3(V2P(p->pgdir));  
1930   popcli();
1931 }
1932 
1933 
1934 
1935 void
1936 inituvm(pde_t *pgdir, char *init, uint sz)
1937 {
1938   char *mem;
1939 
1940   if(sz >= PGSIZE)
1941     panic("inituvm: more than a page");
1942   mem = kalloc();
1943   memset(mem, 0, PGSIZE);
1944   mappages(pgdir, 0, PGSIZE, V2P(mem), PTE_W|PTE_U);
1945   memmove(mem, init, sz);
1946 }
1947 
1948 
1949 
1950 
1951 
1952 int
1953 loaduvm(pde_t *pgdir, char *addr, struct inode *ip, uint offset, uint sz)
1954 {
1955   uint i, pa, n;
1956   pte_t *pte;
1957 
1958   if((uint) addr % PGSIZE != 0)
1959     panic("loaduvm: addr must be page aligned");
1960   for(i = 0; i < sz; i += PGSIZE){
1961     if((pte = walkpgdir(pgdir, addr+i, 0)) == 0)
1962       panic("loaduvm: address should exist");
1963     pa = PTE_ADDR(*pte);
1964     if(sz - i < PGSIZE)
1965       n = sz - i;
1966     else
1967       n = PGSIZE;
1968     if(readi(ip, P2V(pa), offset+i, n) != n)
1969       return -1;
1970   }
1971   return 0;
1972 }
1973 
1974 
1975 
1976 int
1977 allocuvm(pde_t *pgdir, uint oldsz, uint newsz)
1978 {
1979   char *mem;
1980   uint a;
1981 
1982   if(newsz >= KERNBASE)
1983     return 0;
1984   if(newsz < oldsz)
1985     return oldsz;
1986 
1987   a = PGROUNDUP(oldsz);
1988   for(; a < newsz; a += PGSIZE){
1989     mem = kalloc();
1990     if(mem == 0){
1991       cprintf("allocuvm out of memory\n");
1992       deallocuvm(pgdir, newsz, oldsz);
1993       return 0;
1994     }
1995     memset(mem, 0, PGSIZE);
1996     if(mappages(pgdir, (char*)a, PGSIZE, V2P(mem), PTE_W|PTE_U) < 0){
1997       cprintf("allocuvm out of memory (2)\n");
1998       deallocuvm(pgdir, newsz, oldsz);
1999       kfree(mem);
2000       return 0;
2001     }
2002   }
2003   return newsz;
2004 }
2005 
2006 
2007 int
2008 allocuvm_lazy(pde_t *pgdir, uint oldsz, uint newsz) {
2009   char *mem;
2010   uint a;
2011 
2012   if(newsz >= KERNBASE)
2013     return 0;
2014   if(newsz < oldsz)
2015     return oldsz;
2016 
2017   a = PGROUNDUP(oldsz);
2018   for(; a < newsz; a += PGSIZE){
2019     if((pgdir[PDX(a)] & PTE_P) == 0) {
2020       
2021       char *mem = kalloc();
2022       if(mem == 0)
2023         panic("allocuvm_lazy");
2024       memset(mem, 0, PGSIZE);
2025       pgdir[PDX(a)] = V2P(mem) | PTE_P | PTE_W | PTE_U;
2026     }
2027 
2028     pte_t *pgtable = P2V(PTE_ADDR(pgdir[PDX(a)]));
2029     pgtable[PTX(a)] = 0;
2030     pgtable[PTX(a)] = PTE_W | PTE_U | PTE_LAZY;
2031   }
2032   return newsz;
2033 }
2034 
2035 
2036 
2037 
2038 
2039 int
2040 deallocuvm(pde_t *pgdir, uint oldsz, uint newsz)
2041 {
2042   pte_t *pte;
2043   uint a, pa;
2044 
2045   if(newsz >= oldsz)
2046     return oldsz;
2047 
2048 
2049 
2050   a = PGROUNDUP(newsz);
2051   for(; a  < oldsz; a += PGSIZE){
2052     pte = walkpgdir(pgdir, (char*)a, 0);
2053     if(!pte)
2054       a = PGADDR(PDX(a) + 1, 0, 0) - PGSIZE;
2055     else if((*pte & PTE_P) != 0){
2056       pa = PTE_ADDR(*pte);
2057       if(pa == 0)
2058         panic("kfree");
2059       char *v = P2V(pa);
2060       kfree(v);
2061       *pte = 0;
2062     }
2063   }
2064   return newsz;
2065 }
2066 
2067 
2068 
2069 void
2070 freevm(pde_t *pgdir)
2071 {
2072   uint i;
2073 
2074   if(pgdir == 0)
2075     panic("freevm: no pgdir");
2076   deallocuvm(pgdir, KERNBASE, 0);
2077   for(i = 0; i < NPDENTRIES; i++){
2078     if(pgdir[i] & PTE_P){
2079       char * v = P2V(PTE_ADDR(pgdir[i]));
2080       kfree(v);
2081     }
2082   }
2083   kfree((char*)pgdir);
2084 }
2085 
2086 
2087 
2088 void
2089 clearpteu(pde_t *pgdir, char *uva)
2090 {
2091   pte_t *pte;
2092 
2093   pte = walkpgdir(pgdir, uva, 0);
2094   if(pte == 0)
2095     panic("clearpteu");
2096   *pte &= ~PTE_U;
2097 }
2098 
2099 
2100 
2101 
2102 pde_t*
2103 copyuvm(pde_t *pgdir, uint sz)
2104 {
2105   pde_t *new_pgdir;
2106   if((new_pgdir = setupkvm()) == 0)
2107     return 0;
2108 
2109   for(int i=0; i<KERNBASE/(PGSIZE*NPTENTRIES); i++) {
2110     if((pgdir[i] & PTE_P) == 0)
2111       continue;
2112 
2113     pte_t *pgtable = P2V(PTE_ADDR(pgdir[i]));
2114     pte_t *new_pgtable = kalloc();
2115     if(new_pgtable == 0)
2116       goto bad;
2117     memmove(new_pgtable, pgtable, PGSIZE);
2118     for(int j=0; j<NPTENTRIES; j++) {
2119       pte_t pte = pgtable[j];
2120       uint flags = (pte & 0xfff);
2121 
2122       if((flags & (PTE_P | PTE_LAZY)) == 0)
2123         continue;
2124       if(flags & PTE_LAZY) {
2125         new_pgtable[j] = flags;
2126         continue;
2127       }
2128 
2129       char *mem = kalloc();
2130       if(mem == 0)
2131         goto bad;
2132       memmove(mem, (void*)(i*PGSIZE*NPTENTRIES+j*PGSIZE), PGSIZE);
2133       new_pgtable[j] = (V2P(mem) | flags);
2134     }
2135     new_pgdir[i] = ((uint)V2P(new_pgtable) | PTE_P | PTE_W | PTE_U);
2136   }
2137 
2138   return new_pgdir;
2139 bad:
2140   freevm(new_pgdir);
2141   return 0;
2142 }
2143 
2144 
2145 
2146 
2147 
2148 
2149 
2150 
2151 char*
2152 uva2ka(pde_t *pgdir, char *uva)
2153 {
2154   pte_t *pte;
2155 
2156   pte = walkpgdir(pgdir, uva, 0);
2157   if((*pte & PTE_P) == 0)
2158     return 0;
2159   if((*pte & PTE_U) == 0)
2160     return 0;
2161   return (char*)P2V(PTE_ADDR(*pte));
2162 }
2163 
2164 
2165 
2166 
2167 int
2168 copyout(pde_t *pgdir, uint va, void *p, uint len)
2169 {
2170   char *buf, *pa0;
2171   uint n, va0;
2172 
2173   buf = (char*)p;
2174   while(len > 0){
2175     va0 = (uint)PGROUNDDOWN(va);
2176     pa0 = uva2ka(pgdir, (char*)va0);
2177     if(pa0 == 0)
2178       return -1;
2179     n = PGSIZE - (va - va0);
2180     if(n > len)
2181       n = len;
2182     memmove(pa0 + (va - va0), buf, n);
2183     len -= n;
2184     buf += n;
2185     va = va0 + PGSIZE;
2186   }
2187   return 0;
2188 }
2189 
2190 
2191 
2192 
2193 
2194 
2195 
2196 
2197 
2198 
2199 
2200 
2201 
2202 
2203 
2204 
2205 
2206 
2207 
2208 
2209 
2210 
2211 
2212 
2213 
2214 
2215 
2216 
2217 
2218 
2219 
2220 
2221 
2222 
2223 
2224 
2225 
2226 
2227 
2228 
2229 
2230 
2231 
2232 
2233 
2234 
2235 
2236 
2237 
2238 
2239 
2240 
2241 
2242 
2243 
2244 
2245 
2246 
2247 
2248 
2249 
2250 
2251 
2252 
2253 
2254 
2255 
2256 
2257 
2258 
2259 
2260 
2261 
2262 
2263 
2264 
2265 
2266 
2267 
2268 
2269 
2270 
2271 
2272 
2273 
2274 
2275 
2276 
2277 
2278 
2279 
2280 
2281 
2282 
2283 
2284 
2285 
2286 
2287 
2288 
2289 
2290 
2291 
2292 
2293 
2294 
2295 
2296 
2297 
2298 
2299 
2300 
2301 
2302 
2303 
2304 int sys_numvp(void) {
2305   struct proc *p = myproc();
2306 
2307   pde_t *pgdir = p->pgdir;
2308   int cnt = 0;
2309 
2310   for(int i=0; i<NPDENTRIES/2; i++) {
2311     if((pgdir[i] & PTE_P) == 0)
2312       continue;
2313 
2314     pte_t *pgtable = (pte_t*)P2V(PTE_ADDR(pgdir[i]));
2315     for(int j=0; j<NPTENTRIES; j++) {
2316       if((pgtable[j] & (PTE_P | PTE_LAZY)) == 0)
2317         continue;
2318       cnt++;
2319     }
2320   }
2321   return cnt + 1;     
2322   
2323 }
2324 
2325 int sys_numpp(void) {
2326   struct proc *p = myproc();
2327 
2328   pde_t *pgdir = p->pgdir;
2329   int cnt = 0;
2330 
2331   for(int i=0; i<NPDENTRIES/2; i++) {
2332     if((pgdir[i] & PTE_P) == 0)
2333       continue;
2334 
2335     pte_t *pgtable = (pte_t*)P2V(PTE_ADDR(pgdir[i]));
2336     for(int j=0; j<NPTENTRIES; j++) {
2337       if((pgtable[j] & PTE_P) == 0)
2338         continue;
2339       cnt++;
2340     }
2341   }
2342   return cnt + 1;     
2343 }
2344 
2345 
2346 
2347 
2348 
2349 
2350 int sys_getptsize(void) {
2351   int cnt = 0;
2352 
2353   pde_t *pgdir = myproc()->pgdir;
2354   for(int i=0; i<NPDENTRIES; i++) {
2355     if(pgdir[i] & PTE_P)
2356       cnt++;
2357   }
2358   return cnt + 1;     
2359 }
2360 
2361 
2362 int sys_mmap(void) {
2363   int n;
2364   char *start;
2365   if(argint(0, (int*)(&start)))
2366     return -1;
2367   if(argint(1, &n) < 0)
2368     return -1;
2369 
2370   struct proc *curr_proc = myproc();
2371   
2372   if(n < 0)
2373     return -1;
2374   if(((uint)start & 0xfff) != 0) {
2375     cprintf("mmap: start address is not page aligned.\n");
2376     return -1;
2377   }
2378   if(start + PGROUNDUP(n) > KERNBASE) {
2379     cprintf("mmap: Invalid inputs to mmap(%x, %d).\n", start, n);
2380     return -1;
2381   }
2382 
2383 
2384   
2385   for(uint p=start; p < start + PGROUNDUP(n); p += PGSIZE) {
2386     pte_t *pte = walkpgdir(curr_proc->pgdir, p, 1);
2387     if(*pte & PTE_P) {
2388       cprintf("mmap: given range of pages are not free.\n");
2389       return -1;
2390     }
2391     *pte = 0 | PTE_LAZY;
2392   }
2393 
2394   switchuvm(curr_proc);
2395   return 0;
2396 }
2397 
2398 
2399 
2400 int sys_munmap(void) {
2401   char *start;
2402   int n;    
2403   if(argint(0, (int*)&start) < 0)
2404     return -1;
2405   if(argint(1, &n) < 0)
2406     return -1;
2407   cprintf("sys_munmap called with arguments: {start = %x, n = %d}\n", start, n);
2408 
2409   
2410   if(n < 0)
2411     return -1;
2412   if(((uint)start & 0xfff) != 0) {
2413     cprintf("munmap: start address is not page aligned.\n");
2414     return -1;
2415   }
2416   if(start + PGROUNDUP(n) > KERNBASE) {
2417     cprintf("munmap: Invalid inputs to mmap(%x, %d).\n", start, n);
2418     return -1;
2419   }
2420 
2421 
2422   
2423   struct proc *curr_proc = myproc();
2424   pde_t *pgdir = curr_proc->pgdir;
2425   for(uint addr=start; addr < start+PGROUNDUP(n); addr += PGSIZE) {
2426 
2427 
2428     pte_t *pte = walkpgdir(pgdir, addr, 0);
2429     if(pte == 0) {
2430       cprintf("munmap: Page doesn't exist at address %x\n", addr);
2431       return -1;
2432     }
2433 
2434     
2435     if(*pte & PTE_P)
2436       kfree(P2V(PTE_ADDR(*pte)));
2437     *pte = 0;
2438   }
2439 
2440   switchuvm(curr_proc);
2441 
2442 }
2443 
2444 
2445 
2446 
2447 
2448 
2449 
2450 
2451 struct cpu {
2452   uchar apicid;                
2453   struct context *scheduler;   
2454   struct taskstate ts;         
2455   struct segdesc gdt[NSEGS];   
2456   volatile uint started;       
2457   int ncli;                    
2458   int intena;                  
2459   struct proc *proc;           
2460 };
2461 
2462 extern struct cpu cpus[NCPU];
2463 extern int ncpu;
2464 
2465 
2466 
2467 
2468 
2469 
2470 
2471 
2472 
2473 
2474 
2475 
2476 struct context {
2477   uint edi;
2478   uint esi;
2479   uint ebx;
2480   uint ebp;
2481   uint eip;
2482 };
2483 
2484 enum procstate { UNUSED, EMBRYO, SLEEPING, RUNNABLE, RUNNING, ZOMBIE };
2485 
2486 
2487 struct proc {
2488   uint sz;                     
2489   pde_t* pgdir;                
2490   char *kstack;                
2491   enum procstate state;        
2492   int pid;                     
2493   struct proc *parent;         
2494   struct trapframe *tf;        
2495   struct context *context;     
2496   void *chan;                  
2497   int killed;                  
2498   struct file *ofile[NOFILE];  
2499   struct inode *cwd;           
2500   char name[16];               
2501 };
2502 
2503 
2504 
2505 
2506 
2507 
2508 
2509 
2510 
2511 
2512 
2513 
2514 
2515 
2516 
2517 
2518 
2519 
2520 
2521 
2522 
2523 
2524 
2525 
2526 
2527 
2528 
2529 
2530 
2531 
2532 
2533 
2534 
2535 
2536 
2537 
2538 
2539 
2540 
2541 
2542 
2543 
2544 
2545 
2546 
2547 
2548 
2549 
2550 #include "types.h"
2551 #include "defs.h"
2552 #include "param.h"
2553 #include "memlayout.h"
2554 #include "mmu.h"
2555 #include "x86.h"
2556 #include "proc.h"
2557 #include "spinlock.h"
2558 
2559 struct {
2560   struct spinlock lock;
2561   struct proc proc[NPROC];
2562 } ptable;
2563 
2564 static struct proc *initproc;
2565 
2566 int nextpid = 1;
2567 extern void forkret(void);
2568 extern void trapret(void);
2569 
2570 static void wakeup1(void *chan);
2571 
2572 void
2573 pinit(void)
2574 {
2575   initlock(&ptable.lock, "ptable");
2576 }
2577 
2578 
2579 int
2580 cpuid() {
2581   return mycpu()-cpus;
2582 }
2583 
2584 
2585 
2586 struct cpu*
2587 mycpu(void)
2588 {
2589   int apicid, i;
2590 
2591   if(readeflags()&FL_IF)
2592     panic("mycpu called with interrupts enabled\n");
2593 
2594   apicid = lapicid();
2595   
2596   
2597   for (i = 0; i < ncpu; ++i) {
2598     if (cpus[i].apicid == apicid)
2599       return &cpus[i];
2600   }
2601   panic("unknown apicid\n");
2602 }
2603 
2604 
2605 
2606 struct proc*
2607 myproc(void) {
2608   struct cpu *c;
2609   struct proc *p;
2610   pushcli();
2611   c = mycpu();
2612   p = c->proc;
2613   popcli();
2614   return p;
2615 }
2616 
2617 static int get_smallest_pid() {
2618   int pids[NPROC];
2619   for(int i=0; i<NPROC; i++)
2620     pids[i] = 0;  
2621 
2622   for(struct proc *p=ptable.proc; p < ptable.proc+NPROC; p++) {
2623     if(p->state != UNUSED) {
2624       pids[p->pid] = 1;
2625     }
2626   }
2627 
2628   int pid = -1;
2629   for(int i=0; i<NPROC; i++) {
2630     if(pids[i] == 0) {
2631       pid = i;
2632       break;
2633     }
2634   }
2635   return pid;
2636 
2637 }
2638 
2639 
2640 
2641 
2642 
2643 
2644 
2645 
2646 
2647 
2648 
2649 
2650 
2651 
2652 
2653 
2654 static struct proc*
2655 allocproc(void)
2656 {
2657   struct proc *p;
2658   char *sp;
2659 
2660   acquire(&ptable.lock);
2661 
2662   for(p = ptable.proc; p < &ptable.proc[NPROC]; p++)
2663     if(p->state == UNUSED)
2664       goto found;
2665 
2666   release(&ptable.lock);
2667   return 0;
2668 
2669 found:
2670   p->state = EMBRYO;
2671   
2672   p->pid = get_smallest_pid();
2673 
2674   release(&ptable.lock);
2675 
2676   
2677   if((p->kstack = kalloc()) == 0){
2678     p->state = UNUSED;
2679     return 0;
2680   }
2681   sp = p->kstack + KSTACKSIZE;
2682 
2683   
2684   sp -= sizeof *p->tf;
2685   p->tf = (struct trapframe*)sp;
2686 
2687   
2688   
2689   sp -= 4;
2690   *(uint*)sp = (uint)trapret;
2691 
2692   sp -= sizeof *p->context;
2693   p->context = (struct context*)sp;
2694   memset(p->context, 0, sizeof *p->context);
2695   p->context->eip = (uint)forkret;
2696 
2697   return p;
2698 }
2699 
2700 
2701 
2702 void
2703 userinit(void)
2704 {
2705   struct proc *p;
2706   extern char _binary_initcode_start[], _binary_initcode_size[];
2707 
2708   p = allocproc();
2709 
2710   initproc = p;
2711   if((p->pgdir = setupkvm()) == 0)
2712     panic("userinit: out of memory?");
2713   inituvm(p->pgdir, _binary_initcode_start, (int)_binary_initcode_size);
2714   p->sz = PGSIZE;
2715   memset(p->tf, 0, sizeof(*p->tf));
2716   p->tf->cs = (SEG_UCODE << 3) | DPL_USER;
2717   p->tf->ds = (SEG_UDATA << 3) | DPL_USER;
2718   p->tf->es = p->tf->ds;
2719   p->tf->ss = p->tf->ds;
2720   p->tf->eflags = FL_IF;
2721   p->tf->esp = PGSIZE;
2722   p->tf->eip = 0;  
2723 
2724   safestrcpy(p->name, "initcode", sizeof(p->name));
2725   p->cwd = namei("/");
2726 
2727   
2728   
2729   
2730   
2731   acquire(&ptable.lock);
2732 
2733   p->state = RUNNABLE;
2734 
2735   release(&ptable.lock);
2736 }
2737 
2738 
2739 
2740 
2741 
2742 
2743 
2744 
2745 
2746 
2747 
2748 
2749 
2750 
2751 
2752 int
2753 growproc(int n)
2754 {
2755   uint sz;
2756   struct proc *curproc = myproc();
2757 
2758   sz = curproc->sz;
2759   if(n > 0){
2760     if((sz = allocuvm(curproc->pgdir, sz, sz + n)) == 0)
2761       return -1;
2762   } else if(n < 0){
2763     if((sz = deallocuvm(curproc->pgdir, sz, sz + n)) == 0)
2764       return -1;
2765   }
2766   curproc->sz = sz;
2767   switchuvm(curproc);
2768   return 0;
2769 }
2770 
2771 
2772 void *growproc_lazy(int n) {
2773   struct proc *curr_proc = myproc();
2774 
2775   int sz = curr_proc->sz;
2776   if(n > 0) {
2777     if((sz = allocuvm_lazy(curr_proc->pgdir, sz, sz + n)) == 0)
2778       return -1;
2779   } else if(n < 0){
2780     if((sz = deallocuvm(curr_proc->pgdir, sz, sz + n)) == 0)
2781       return -1;
2782   }
2783   curr_proc->sz = sz;
2784   switchuvm(curr_proc);
2785   return 0;
2786 }
2787 
2788 
2789 
2790 
2791 
2792 
2793 
2794 
2795 
2796 
2797 
2798 
2799 
2800 
2801 
2802 
2803 int
2804 fork(void)
2805 {
2806   int i, pid;
2807   struct proc *np;
2808   struct proc *curproc = myproc();
2809 
2810   
2811   if((np = allocproc()) == 0){
2812     return -1;
2813   }
2814 
2815   
2816   if((np->pgdir = copyuvm(curproc->pgdir, curproc->sz)) == 0){
2817     kfree(np->kstack);
2818     np->kstack = 0;
2819     np->state = UNUSED;
2820     return -1;
2821   }
2822   np->sz = curproc->sz;
2823   np->parent = curproc;
2824   *np->tf = *curproc->tf;
2825 
2826   
2827   np->tf->eax = 0;
2828 
2829   for(i = 0; i < NOFILE; i++)
2830     if(curproc->ofile[i])
2831       np->ofile[i] = filedup(curproc->ofile[i]);
2832   np->cwd = idup(curproc->cwd);
2833 
2834   safestrcpy(np->name, curproc->name, sizeof(curproc->name));
2835 
2836   pid = np->pid;
2837 
2838   acquire(&ptable.lock);
2839 
2840   np->state = RUNNABLE;
2841 
2842   release(&ptable.lock);
2843 
2844   return pid;
2845 }
2846 
2847 
2848 
2849 
2850 
2851 
2852 
2853 void
2854 exit(void)
2855 {
2856   struct proc *curproc = myproc();
2857   struct proc *p;
2858   int fd;
2859 
2860   if(curproc == initproc)
2861     panic("init exiting");
2862 
2863   
2864   for(fd = 0; fd < NOFILE; fd++){
2865     if(curproc->ofile[fd]){
2866       fileclose(curproc->ofile[fd]);
2867       curproc->ofile[fd] = 0;
2868     }
2869   }
2870 
2871   begin_op();
2872   iput(curproc->cwd);
2873   end_op();
2874   curproc->cwd = 0;
2875 
2876   acquire(&ptable.lock);
2877 
2878   
2879   wakeup1(curproc->parent);
2880 
2881   
2882   for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
2883     if(p->parent == curproc){
2884       p->parent = initproc;
2885       if(p->state == ZOMBIE)
2886         wakeup1(initproc);
2887     }
2888   }
2889 
2890   
2891   curproc->state = ZOMBIE;
2892   sched();
2893   panic("zombie exit");
2894 }
2895 
2896 
2897 
2898 
2899 
2900 
2901 
2902 int
2903 wait(void)
2904 {
2905   struct proc *p;
2906   int havekids, pid;
2907   struct proc *curproc = myproc();
2908 
2909   acquire(&ptable.lock);
2910   for(;;){
2911     
2912     havekids = 0;
2913     for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
2914       if(p->parent != curproc)
2915         continue;
2916       havekids = 1;
2917       if(p->state == ZOMBIE){
2918         
2919         pid = p->pid;
2920         kfree(p->kstack);
2921         p->kstack = 0;
2922         freevm(p->pgdir);
2923         p->pid = 0;
2924         p->parent = 0;
2925         p->name[0] = 0;
2926         p->killed = 0;
2927         p->state = UNUSED;
2928         release(&ptable.lock);
2929         return pid;
2930       }
2931     }
2932 
2933     
2934     if(!havekids || curproc->killed){
2935       release(&ptable.lock);
2936       return -1;
2937     }
2938 
2939     
2940     sleep(curproc, &ptable.lock);  
2941   }
2942 }
2943 
2944 
2945 
2946 
2947 
2948 
2949 
2950 
2951 
2952 
2953 
2954 
2955 
2956 
2957 void
2958 scheduler(void)
2959 {
2960   struct proc *p;
2961   struct cpu *c = mycpu();
2962   c->proc = 0;
2963 
2964   for(;;){
2965     
2966     sti();
2967 
2968     
2969     acquire(&ptable.lock);
2970     for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
2971       if(p->state != RUNNABLE)
2972         continue;
2973 
2974       
2975       
2976       
2977       c->proc = p;
2978       switchuvm(p);
2979       p->state = RUNNING;
2980 
2981       swtch(&(c->scheduler), p->context);
2982       switchkvm();
2983 
2984       
2985       
2986       c->proc = 0;
2987     }
2988     release(&ptable.lock);
2989 
2990   }
2991 }
2992 
2993 
2994 
2995 
2996 
2997 
2998 
2999 
3000 
3001 
3002 
3003 
3004 
3005 
3006 
3007 void
3008 sched(void)
3009 {
3010   int intena;
3011   struct proc *p = myproc();
3012 
3013   if(!holding(&ptable.lock))
3014     panic("sched ptable.lock");
3015   if(mycpu()->ncli != 1)
3016     panic("sched locks");
3017   if(p->state == RUNNING)
3018     panic("sched running");
3019   if(readeflags()&FL_IF)
3020     panic("sched interruptible");
3021   intena = mycpu()->intena;
3022   swtch(&p->context, mycpu()->scheduler);
3023   mycpu()->intena = intena;
3024 }
3025 
3026 
3027 void
3028 yield(void)
3029 {
3030   acquire(&ptable.lock);  
3031   myproc()->state = RUNNABLE;
3032   sched();
3033   release(&ptable.lock);
3034 }
3035 
3036 
3037 
3038 
3039 
3040 
3041 
3042 
3043 
3044 
3045 
3046 
3047 
3048 
3049 
3050 
3051 
3052 void
3053 forkret(void)
3054 {
3055   static int first = 1;
3056   
3057   release(&ptable.lock);
3058 
3059   if (first) {
3060     
3061     
3062     
3063     first = 0;
3064     iinit(ROOTDEV);
3065     initlog(ROOTDEV);
3066   }
3067 
3068   
3069 }
3070 
3071 
3072 
3073 void
3074 sleep(void *chan, struct spinlock *lk)
3075 {
3076   struct proc *p = myproc();
3077 
3078   if(p == 0)
3079     panic("sleep");
3080 
3081   if(lk == 0)
3082     panic("sleep without lk");
3083 
3084   
3085   
3086   
3087   
3088   
3089   
3090   if(lk != &ptable.lock){  
3091     acquire(&ptable.lock);  
3092     release(lk);
3093   }
3094   
3095   p->chan = chan;
3096   p->state = SLEEPING;
3097 
3098   sched();
3099 
3100   
3101   p->chan = 0;
3102 
3103   
3104   if(lk != &ptable.lock){  
3105     release(&ptable.lock);
3106     acquire(lk);
3107   }
3108 }
3109 
3110 
3111 
3112 
3113 
3114 
3115 
3116 
3117 
3118 
3119 
3120 
3121 
3122 
3123 
3124 
3125 
3126 
3127 
3128 
3129 
3130 
3131 
3132 
3133 
3134 
3135 
3136 
3137 
3138 
3139 
3140 
3141 
3142 
3143 
3144 
3145 
3146 
3147 
3148 
3149 
3150 
3151 
3152 static void
3153 wakeup1(void *chan)
3154 {
3155   struct proc *p;
3156 
3157   for(p = ptable.proc; p < &ptable.proc[NPROC]; p++)
3158     if(p->state == SLEEPING && p->chan == chan)
3159       p->state = RUNNABLE;
3160 }
3161 
3162 
3163 void
3164 wakeup(void *chan)
3165 {
3166   acquire(&ptable.lock);
3167   wakeup1(chan);
3168   release(&ptable.lock);
3169 }
3170 
3171 
3172 
3173 
3174 int
3175 kill(int pid)
3176 {
3177   struct proc *p;
3178 
3179   acquire(&ptable.lock);
3180   for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
3181     if(p->pid == pid){
3182       p->killed = 1;
3183       
3184       if(p->state == SLEEPING)
3185         p->state = RUNNABLE;
3186       release(&ptable.lock);
3187       return 0;
3188     }
3189   }
3190   release(&ptable.lock);
3191   return -1;
3192 }
3193 
3194 
3195 
3196 
3197 
3198 
3199 
3200 
3201 
3202 
3203 void
3204 procdump(void)
3205 {
3206   static char *states[] = {
3207   [UNUSED]    "unused",
3208   [EMBRYO]    "embryo",
3209   [SLEEPING]  "sleep ",
3210   [RUNNABLE]  "runble",
3211   [RUNNING]   "run   ",
3212   [ZOMBIE]    "zombie"
3213   };
3214   int i;
3215   struct proc *p;
3216   char *state;
3217   uint pc[10];
3218 
3219   for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
3220     if(p->state == UNUSED)
3221       continue;
3222     if(p->state >= 0 && p->state < NELEM(states) && states[p->state])
3223       state = states[p->state];
3224     else
3225       state = "???";
3226     cprintf("%d %s %s", p->pid, state, p->name);
3227     if(p->state == SLEEPING){
3228       getcallerpcs((uint*)p->context->ebp+2, pc);
3229       for(i=0; i<10 && pc[i] != 0; i++)
3230         cprintf(" %p", pc[i]);
3231     }
3232     cprintf("\n");
3233   }
3234 }
3235 
3236 
3237 void sys_greet(void) {
3238   char *name;
3239   argstr(0, &name);
3240 
3241   cprintf("Hello %s\n", name);
3242 }
3243 
3244 
3245 
3246 
3247 
3248 
3249 
3250 
3251 
3252 
3253 
3254 
3255 
3256 
3257 
3258 .globl swtch
3259 swtch:
3260   movl 4(%esp), %eax
3261   movl 8(%esp), %edx
3262 
3263   
3264   pushl %ebp
3265   pushl %ebx
3266   pushl %esi
3267   pushl %edi
3268 
3269   
3270   movl %esp, (%eax)
3271   movl %edx, %esp
3272 
3273   
3274   popl %edi
3275   popl %esi
3276   popl %ebx
3277   popl %ebp
3278   ret
3279 
3280 
3281 
3282 
3283 
3284 
3285 
3286 
3287 
3288 
3289 
3290 
3291 
3292 
3293 
3294 
3295 
3296 
3297 
3298 
3299 
3300 
3301 
3302 
3303 
3304 #include "types.h"
3305 #include "defs.h"
3306 #include "param.h"
3307 #include "memlayout.h"
3308 #include "mmu.h"
3309 #include "spinlock.h"
3310 
3311 void freerange(void *vstart, void *vend);
3312 extern char end[]; 
3313                    
3314 
3315 struct run {
3316   struct run *next;
3317 };
3318 
3319 struct {
3320   struct spinlock lock;
3321   int use_lock;
3322   struct run *freelist;
3323 } kmem;
3324 
3325 
3326 
3327 
3328 
3329 
3330 void
3331 kinit1(void *vstart, void *vend)
3332 {
3333   initlock(&kmem.lock, "kmem");
3334   kmem.use_lock = 0;
3335   freerange(vstart, vend);
3336 }
3337 
3338 void
3339 kinit2(void *vstart, void *vend)
3340 {
3341   freerange(vstart, vend);
3342   kmem.use_lock = 1;
3343 }
3344 
3345 
3346 
3347 
3348 
3349 
3350 void
3351 freerange(void *vstart, void *vend)
3352 {
3353   char *p;
3354   p = (char*)PGROUNDUP((uint)vstart);
3355   for(; p + PGSIZE <= (char*)vend; p += PGSIZE)
3356     kfree(p);
3357 }
3358 
3359 
3360 
3361 
3362 
3363 void
3364 kfree(char *v)
3365 {
3366   struct run *r;
3367 
3368   if((uint)v % PGSIZE || v < end || V2P(v) >= PHYSTOP)
3369     panic("kfree");
3370 
3371   
3372   memset(v, 1, PGSIZE);
3373 
3374   if(kmem.use_lock)
3375     acquire(&kmem.lock);
3376   r = (struct run*)v;
3377   r->next = kmem.freelist;
3378   kmem.freelist = r;
3379   if(kmem.use_lock)
3380     release(&kmem.lock);
3381 }
3382 
3383 
3384 
3385 
3386 char*
3387 kalloc(void)
3388 {
3389   struct run *r;
3390 
3391   if(kmem.use_lock)
3392     acquire(&kmem.lock);
3393   r = kmem.freelist;
3394   if(r)
3395     kmem.freelist = r->next;
3396   if(kmem.use_lock)
3397     release(&kmem.lock);
3398   return (char*)r;
3399 }
3400 
3401 
3402 
3403 #define T_DIVIDE         0      
3404 #define T_DEBUG          1      
3405 #define T_NMI            2      
3406 #define T_BRKPT          3      
3407 #define T_OFLOW          4      
3408 #define T_BOUND          5      
3409 #define T_ILLOP          6      
3410 #define T_DEVICE         7      
3411 #define T_DBLFLT         8      
3412 
3413 #define T_TSS           10      
3414 #define T_SEGNP         11      
3415 #define T_STACK         12      
3416 #define T_GPFLT         13      
3417 #define T_PGFLT         14      
3418 
3419 #define T_FPERR         16      
3420 #define T_ALIGN         17      
3421 #define T_MCHK          18      
3422 #define T_SIMDERR       19      
3423 
3424 
3425 
3426 #define T_SYSCALL       64      
3427 #define T_DEFAULT      500      
3428 
3429 #define T_IRQ0          32      
3430 
3431 #define IRQ_TIMER        0
3432 #define IRQ_KBD          1
3433 #define IRQ_COM1         4
3434 #define IRQ_IDE         14
3435 #define IRQ_ERROR       19
3436 #define IRQ_SPURIOUS    31
3437 
3438 
3439 
3440 
3441 
3442 
3443 
3444 
3445 
3446 
3447 
3448 
3449 
3450 #!/usr/bin/perl -w
3451 
3452 # Generate vectors.S, the trap/interrupt entry points.
3453 # There has to be one entry point per interrupt number
3454 # since otherwise there's no way for trap() to discover
3455 # the interrupt number.
3456 
3457 print "# generated by vectors.pl - do not edit\n";
3458 print "# handlers\n";
3459 print ".globl alltraps\n";
3460 for(my $i = 0; $i < 256; $i++){
3461     print ".globl vector$i\n";
3462     print "vector$i:\n";
3463     if(!($i == 8 || ($i >= 10 && $i <= 14) || $i == 17)){
3464         print "  pushl \$0\n";
3465     }
3466     print "  pushl \$$i\n";
3467     print "  jmp alltraps\n";
3468 }
3469 
3470 print "\n# vector table\n";
3471 print ".data\n";
3472 print ".globl vectors\n";
3473 print "vectors:\n";
3474 for(my $i = 0; $i < 256; $i++){
3475     print "  .long vector$i\n";
3476 }
3477 
3478 # sample output:
3479 #   # handlers
3480 #   .globl alltraps
3481 #   .globl vector0
3482 #   vector0:
3483 #     pushl $0
3484 #     pushl $0
3485 #     jmp alltraps
3486 #   ...
3487 #
3488 #   # vector table
3489 #   .data
3490 #   .globl vectors
3491 #   vectors:
3492 #     .long vector0
3493 #     .long vector1
3494 #     .long vector2
3495 #   ...
3496 
3497 
3498 
3499 
3500 
3501 
3502   
3503 .globl alltraps
3504 alltraps:
3505   
3506   pushl %ds
3507   pushl %es
3508   pushl %fs
3509   pushl %gs
3510   pushal
3511 
3512   
3513   movw $(SEG_KDATA<<3), %ax
3514   movw %ax, %ds
3515   movw %ax, %es
3516 
3517   
3518   pushl %esp
3519   call trap
3520   addl $4, %esp
3521 
3522   
3523 .globl trapret
3524 trapret:
3525   popal
3526   popl %gs
3527   popl %fs
3528   popl %es
3529   popl %ds
3530   addl $0x8, %esp  
3531   iret
3532 
3533 
3534 
3535 
3536 
3537 
3538 
3539 
3540 
3541 
3542 
3543 
3544 
3545 
3546 
3547 
3548 
3549 
3550 #include "types.h"
3551 #include "defs.h"
3552 #include "param.h"
3553 #include "memlayout.h"
3554 #include "mmu.h"
3555 #include "proc.h"
3556 #include "x86.h"
3557 #include "traps.h"
3558 #include "spinlock.h"
3559 
3560 
3561 struct gatedesc idt[256];
3562 extern uint vectors[];  
3563 struct spinlock tickslock;
3564 uint ticks;
3565 
3566 void
3567 tvinit(void)
3568 {
3569   int i;
3570 
3571   for(i = 0; i < 256; i++)
3572     SETGATE(idt[i], 0, SEG_KCODE<<3, vectors[i], 0);
3573   SETGATE(idt[T_SYSCALL], 1, SEG_KCODE<<3, vectors[T_SYSCALL], DPL_USER);
3574 
3575   initlock(&tickslock, "time");
3576 }
3577 
3578 void
3579 idtinit(void)
3580 {
3581   lidt(idt, sizeof(idt));
3582 }
3583 
3584 static int is_page_lazy(char *addr) {
3585   pde_t *pgdir = myproc()->pgdir;
3586   if(pgdir[PDX(addr)] & PTE_P == 0)
3587     return 0;
3588 
3589   pte_t *pgtable = P2V(PTE_ADDR(pgdir[PDX(addr)]));
3590   return ((pgtable[PTX(addr)] & PTE_LAZY) != 0);
3591 }
3592 
3593 
3594 
3595 
3596 
3597 
3598 
3599 
3600 void
3601 trap(struct trapframe *tf)
3602 {
3603   if(tf->trapno == T_SYSCALL){
3604     if(myproc()->killed)
3605       exit();
3606     myproc()->tf = tf;
3607     syscall();
3608     if(myproc()->killed)
3609       exit();
3610     return;
3611   }
3612 
3613   if(tf->trapno == T_PGFLT) {
3614     struct proc *p = myproc();
3615     uint addr = rcr2();
3616 
3617     if(!is_page_lazy(addr))
3618       goto kill_process;
3619 
3620     pde_t *pgdir = p->pgdir;
3621     pte_t *pgtable = P2V(PTE_ADDR(pgdir[PDX(addr)]));
3622     pgtable[PTX(addr)] = 0;
3623     uint mem = (uint)kalloc();
3624     if(mem == 0) {
3625       cprintf("kalloc: out of physical memory!\n");
3626       goto kill_process;
3627     }
3628 
3629     pgtable[PTX(addr)] &= ~(PTE_LAZY);
3630     pgtable[PTX(addr)] = V2P(mem) | PTE_P | PTE_W | PTE_U;
3631     return;
3632 
3633 
3634   kill_process:
3635     cprintf("Page fault: Killing process %d\n", p->pid);
3636     exit();
3637   }
3638 
3639   switch(tf->trapno){
3640   case T_IRQ0 + IRQ_TIMER:
3641     if(cpuid() == 0){
3642       acquire(&tickslock);
3643       ticks++;
3644       wakeup(&ticks);
3645       release(&tickslock);
3646     }
3647     lapiceoi();
3648     break;
3649   case T_IRQ0 + IRQ_IDE:
3650     ideintr();
3651     lapiceoi();
3652     break;
3653   case T_IRQ0 + IRQ_IDE+1:
3654     
3655     break;
3656   case T_IRQ0 + IRQ_KBD:
3657     kbdintr();
3658     lapiceoi();
3659     break;
3660   case T_IRQ0 + IRQ_COM1:
3661     uartintr();
3662     lapiceoi();
3663     break;
3664   case T_IRQ0 + 7:
3665   case T_IRQ0 + IRQ_SPURIOUS:
3666     cprintf("cpu%d: spurious interrupt at %x:%x\n",
3667             cpuid(), tf->cs, tf->eip);
3668     lapiceoi();
3669     break;
3670 
3671 
3672   default:
3673     if(myproc() == 0 || (tf->cs&3) == 0){
3674       
3675       cprintf("unexpected trap %d from cpu %d eip %x (cr2=0x%x)\n",
3676               tf->trapno, cpuid(), tf->eip, rcr2());
3677       panic("trap");
3678     }
3679     
3680     cprintf("pid %d %s: trap %d err %d on cpu %d "
3681             "eip 0x%x addr 0x%x--kill proc\n",
3682             myproc()->pid, myproc()->name, tf->trapno,
3683             tf->err, cpuid(), tf->eip, rcr2());
3684     myproc()->killed = 1;
3685   }
3686 
3687   
3688   
3689   
3690   if(myproc() && myproc()->killed && (tf->cs&3) == DPL_USER)
3691     exit();
3692 
3693   
3694   
3695   if(myproc() && myproc()->state == RUNNING &&
3696      tf->trapno == T_IRQ0+IRQ_TIMER)
3697     yield();
3698 
3699 
3700   
3701   if(myproc() && myproc()->killed && (tf->cs&3) == DPL_USER)
3702     exit();
3703 }
3704 
3705 
3706 
3707 
3708 
3709 
3710 
3711 
3712 
3713 
3714 
3715 
3716 
3717 
3718 
3719 
3720 
3721 
3722 
3723 
3724 
3725 
3726 
3727 
3728 
3729 
3730 
3731 
3732 
3733 
3734 
3735 
3736 
3737 
3738 
3739 
3740 
3741 
3742 
3743 
3744 
3745 
3746 
3747 
3748 
3749 
3750 
3751 #define SYS_fork    1
3752 #define SYS_exit    2
3753 #define SYS_wait    3
3754 #define SYS_pipe    4
3755 #define SYS_read    5
3756 #define SYS_kill    6
3757 #define SYS_exec    7
3758 #define SYS_fstat   8
3759 #define SYS_chdir   9
3760 #define SYS_dup    10
3761 #define SYS_getpid 11
3762 #define SYS_sbrk   12
3763 #define SYS_sleep  13
3764 #define SYS_uptime 14
3765 #define SYS_open   15
3766 #define SYS_write  16
3767 #define SYS_mknod  17
3768 #define SYS_unlink 18
3769 #define SYS_link   19
3770 #define SYS_mkdir  20
3771 #define SYS_close  21
3772 
3773 
3774 #define SYS_greet   22
3775 #define SYS_numvp   23
3776 #define SYS_numpp   24
3777 #define SYS_getptsize   25
3778 #define SYS_mmap    26
3779 #define SYS_munmap  27
3780 
3781 
3782 
3783 
3784 
3785 
3786 
3787 
3788 
3789 
3790 
3791 
3792 
3793 
3794 
3795 
3796 
3797 
3798 
3799 
3800 #include "types.h"
3801 #include "defs.h"
3802 #include "param.h"
3803 #include "memlayout.h"
3804 #include "mmu.h"
3805 #include "proc.h"
3806 #include "x86.h"
3807 #include "syscall.h"
3808 
3809 
3810 
3811 
3812 
3813 
3814 
3815 
3816 int
3817 fetchint(uint addr, int *ip)
3818 {
3819   struct proc *curproc = myproc();
3820 
3821   if(addr >= curproc->sz || addr+4 > curproc->sz)
3822     return -1;
3823   *ip = *(int*)(addr);
3824   return 0;
3825 }
3826 
3827 
3828 
3829 
3830 int
3831 fetchstr(uint addr, char **pp)
3832 {
3833   char *s, *ep;
3834   struct proc *curproc = myproc();
3835 
3836   if(addr >= curproc->sz)
3837     return -1;
3838   *pp = (char*)addr;
3839   ep = (char*)curproc->sz;
3840   for(s = *pp; s < ep; s++){
3841     if(*s == 0)
3842       return s - *pp;
3843   }
3844   return -1;
3845 }
3846 
3847 
3848 
3849 
3850 
3851 int
3852 argint(int n, int *ip)
3853 {
3854   return fetchint((myproc()->tf->esp) + 4 + 4*n, ip);
3855 }
3856 
3857 
3858 
3859 
3860 int
3861 argptr(int n, char **pp, int size)
3862 {
3863   int i;
3864   struct proc *curproc = myproc();
3865 
3866   if(argint(n, &i) < 0)
3867     return -1;
3868   if(size < 0 || (uint)i >= curproc->sz || (uint)i+size > curproc->sz)
3869     return -1;
3870   *pp = (char*)i;
3871   return 0;
3872 }
3873 
3874 
3875 
3876 
3877 
3878 int
3879 argstr(int n, char **pp)
3880 {
3881   int addr;
3882   if(argint(n, &addr) < 0)
3883     return -1;
3884   return fetchstr(addr, pp);
3885 }
3886 
3887 
3888 
3889 
3890 
3891 
3892 
3893 
3894 
3895 
3896 
3897 
3898 
3899 
3900 extern int sys_chdir(void);
3901 extern int sys_close(void);
3902 extern int sys_dup(void);
3903 extern int sys_exec(void);
3904 extern int sys_exit(void);
3905 extern int sys_fork(void);
3906 extern int sys_fstat(void);
3907 extern int sys_getpid(void);
3908 extern int sys_kill(void);
3909 extern int sys_link(void);
3910 extern int sys_mkdir(void);
3911 extern int sys_mknod(void);
3912 extern int sys_open(void);
3913 extern int sys_pipe(void);
3914 extern int sys_read(void);
3915 extern int sys_sbrk(void);
3916 extern int sys_sleep(void);
3917 extern int sys_unlink(void);
3918 extern int sys_wait(void);
3919 extern int sys_write(void);
3920 extern int sys_uptime(void);
3921 
3922 
3923 extern void sys_greet(void);
3924 extern int sys_numvp(void);
3925 extern int sys_numpp(void);
3926 extern int sys_getptsize(void);
3927 extern int sys_mmap(void);
3928 extern int sys_munmap(void);
3929 
3930 
3931 static int (*syscalls[])(void) = {
3932 [SYS_fork]    sys_fork,
3933 [SYS_exit]    sys_exit,
3934 [SYS_wait]    sys_wait,
3935 [SYS_pipe]    sys_pipe,
3936 [SYS_read]    sys_read,
3937 [SYS_kill]    sys_kill,
3938 [SYS_exec]    sys_exec,
3939 [SYS_fstat]   sys_fstat,
3940 [SYS_chdir]   sys_chdir,
3941 [SYS_dup]     sys_dup,
3942 [SYS_getpid]  sys_getpid,
3943 [SYS_sbrk]    sys_sbrk,
3944 [SYS_sleep]   sys_sleep,
3945 [SYS_uptime]  sys_uptime,
3946 [SYS_open]    sys_open,
3947 [SYS_write]   sys_write,
3948 [SYS_mknod]   sys_mknod,
3949 [SYS_unlink]  sys_unlink,
3950 [SYS_link]    sys_link,
3951 [SYS_mkdir]   sys_mkdir,
3952 [SYS_close]   sys_close,
3953 [SYS_greet]   sys_greet,
3954 [SYS_numvp]   sys_numvp,
3955 [SYS_numpp]   sys_numpp,
3956 [SYS_getptsize]   sys_getptsize,
3957 [SYS_mmap]    sys_mmap,
3958 [SYS_munmap]  sys_munmap,
3959 };
3960 
3961 void
3962 syscall(void)
3963 {
3964   int num;
3965   struct proc *curproc = myproc();
3966 
3967   num = curproc->tf->eax;
3968   if(num > 0 && num < NELEM(syscalls) && syscalls[num]) {
3969     curproc->tf->eax = syscalls[num]();
3970   } else {
3971     cprintf("%d %s: unknown sys call %d\n",
3972             curproc->pid, curproc->name, num);
3973     curproc->tf->eax = -1;
3974   }
3975 }
3976 
3977 
3978 
3979 
3980 
3981 
3982 
3983 
3984 
3985 
3986 
3987 
3988 
3989 
3990 
3991 
3992 
3993 
3994 
3995 
3996 
3997 
3998 
3999 
4000 #include "types.h"
4001 #include "x86.h"
4002 #include "defs.h"
4003 #include "date.h"
4004 #include "param.h"
4005 #include "memlayout.h"
4006 #include "mmu.h"
4007 #include "proc.h"
4008 
4009 int
4010 sys_fork(void)
4011 {
4012   return fork();
4013 }
4014 
4015 int
4016 sys_exit(void)
4017 {
4018   exit();
4019   return 0;  
4020 }
4021 
4022 int
4023 sys_wait(void)
4024 {
4025   return wait();
4026 }
4027 
4028 int
4029 sys_kill(void)
4030 {
4031   int pid;
4032 
4033   if(argint(0, &pid) < 0)
4034     return -1;
4035   return kill(pid);
4036 }
4037 
4038 int
4039 sys_getpid(void)
4040 {
4041   return myproc()->pid;
4042 }
4043 
4044 
4045 
4046 
4047 
4048 
4049 
4050 int
4051 sys_sbrk(void)
4052 {
4053   int addr;
4054   int n;
4055 
4056   if(argint(0, &n) < 0)
4057     return -1;
4058   addr = myproc()->sz;
4059   if(growproc(n) < 0)
4060     return -1;
4061   return addr;
4062 }
4063 
4064 int
4065 sys_sleep(void)
4066 {
4067   int n;
4068   uint ticks0;
4069 
4070   if(argint(0, &n) < 0)
4071     return -1;
4072   acquire(&tickslock);
4073   ticks0 = ticks;
4074   while(ticks - ticks0 < n){
4075     if(myproc()->killed){
4076       release(&tickslock);
4077       return -1;
4078     }
4079     sleep(&ticks, &tickslock);
4080   }
4081   release(&tickslock);
4082   return 0;
4083 }
4084 
4085 
4086 
4087 int
4088 sys_uptime(void)
4089 {
4090   uint xticks;
4091 
4092   acquire(&tickslock);
4093   xticks = ticks;
4094   release(&tickslock);
4095   return xticks;
4096 }
4097 
4098 
4099 
4100 struct buf {
4101   int flags;
4102   uint dev;
4103   uint blockno;
4104   struct sleeplock lock;
4105   uint refcnt;
4106   struct buf *prev; 
4107   struct buf *next;
4108   struct buf *qnext; 
4109   uchar data[BSIZE];
4110 };
4111 #define B_VALID 0x2  
4112 #define B_DIRTY 0x4  
4113 
4114 
4115 
4116 
4117 
4118 
4119 
4120 
4121 
4122 
4123 
4124 
4125 
4126 
4127 
4128 
4129 
4130 
4131 
4132 
4133 
4134 
4135 
4136 
4137 
4138 
4139 
4140 
4141 
4142 
4143 
4144 
4145 
4146 
4147 
4148 
4149 
4150 
4151 struct sleeplock {
4152   uint locked;       
4153   struct spinlock lk; 
4154 
4155   
4156   char *name;        
4157   int pid;           
4158 };
4159 
4160 
4161 
4162 
4163 
4164 
4165 
4166 
4167 
4168 
4169 
4170 
4171 
4172 
4173 
4174 
4175 
4176 
4177 
4178 
4179 
4180 
4181 
4182 
4183 
4184 
4185 
4186 
4187 
4188 
4189 
4190 
4191 
4192 
4193 
4194 
4195 
4196 
4197 
4198 
4199 
4200 #define O_RDONLY  0x000
4201 #define O_WRONLY  0x001
4202 #define O_RDWR    0x002
4203 #define O_CREATE  0x200
4204 
4205 
4206 
4207 
4208 
4209 
4210 
4211 
4212 
4213 
4214 
4215 
4216 
4217 
4218 
4219 
4220 
4221 
4222 
4223 
4224 
4225 
4226 
4227 
4228 
4229 
4230 
4231 
4232 
4233 
4234 
4235 
4236 
4237 
4238 
4239 
4240 
4241 
4242 
4243 
4244 
4245 
4246 
4247 
4248 
4249 
4250 #define T_DIR  1   
4251 #define T_FILE 2   
4252 #define T_DEV  3   
4253 
4254 struct stat {
4255   short type;  
4256   int dev;     
4257   uint ino;    
4258   short nlink; 
4259   uint size;   
4260 };
4261 
4262 
4263 
4264 
4265 
4266 
4267 
4268 
4269 
4270 
4271 
4272 
4273 
4274 
4275 
4276 
4277 
4278 
4279 
4280 
4281 
4282 
4283 
4284 
4285 
4286 
4287 
4288 
4289 
4290 
4291 
4292 
4293 
4294 
4295 
4296 
4297 
4298 
4299 
4300 
4301 
4302 
4303 
4304 #define ROOTINO 1  
4305 #define BSIZE 512  
4306 
4307 
4308 
4309 
4310 
4311 
4312 
4313 struct superblock {
4314   uint size;         
4315   uint nblocks;      
4316   uint ninodes;      
4317   uint nlog;         
4318   uint logstart;     
4319   uint inodestart;   
4320   uint bmapstart;    
4321 };
4322 
4323 #define NDIRECT 12
4324 #define NINDIRECT (BSIZE / sizeof(uint))
4325 #define MAXFILE (NDIRECT + NINDIRECT)
4326 
4327 
4328 struct dinode {
4329   short type;           
4330   short major;          
4331   short minor;          
4332   short nlink;          
4333   uint size;            
4334   uint addrs[NDIRECT+1];   
4335 };
4336 
4337 
4338 
4339 
4340 
4341 
4342 
4343 
4344 
4345 
4346 
4347 
4348 
4349 
4350 
4351 #define IPB           (BSIZE / sizeof(struct dinode))
4352 
4353 
4354 #define IBLOCK(i, sb)     ((i) / IPB + sb.inodestart)
4355 
4356 
4357 #define BPB           (BSIZE*8)
4358 
4359 
4360 #define BBLOCK(b, sb) (b/BPB + sb.bmapstart)
4361 
4362 
4363 #define DIRSIZ 14
4364 
4365 struct dirent {
4366   ushort inum;
4367   char name[DIRSIZ];
4368 };
4369 
4370 
4371 
4372 
4373 
4374 
4375 
4376 
4377 
4378 
4379 
4380 
4381 
4382 
4383 
4384 
4385 
4386 
4387 
4388 
4389 
4390 
4391 
4392 
4393 
4394 
4395 
4396 
4397 
4398 
4399 
4400 struct file {
4401   enum { FD_NONE, FD_PIPE, FD_INODE } type;
4402   int ref; 
4403   char readable;
4404   char writable;
4405   struct pipe *pipe;
4406   struct inode *ip;
4407   uint off;
4408 };
4409 
4410 
4411 
4412 struct inode {
4413   uint dev;           
4414   uint inum;          
4415   int ref;            
4416   struct sleeplock lock; 
4417   int valid;          
4418 
4419   short type;         
4420   short major;
4421   short minor;
4422   short nlink;
4423   uint size;
4424   uint addrs[NDIRECT+1];
4425 };
4426 
4427 
4428 
4429 struct devsw {
4430   int (*read)(struct inode*, char*, int);
4431   int (*write)(struct inode*, char*, int);
4432 };
4433 
4434 extern struct devsw devsw[];
4435 
4436 #define CONSOLE 1
4437 
4438 
4439 
4440 
4441 
4442 
4443 
4444 
4445 
4446 
4447 
4448 
4449 
4450 
4451 
4452 #include "types.h"
4453 #include "defs.h"
4454 #include "param.h"
4455 #include "memlayout.h"
4456 #include "mmu.h"
4457 #include "proc.h"
4458 #include "x86.h"
4459 #include "traps.h"
4460 #include "spinlock.h"
4461 #include "sleeplock.h"
4462 #include "fs.h"
4463 #include "buf.h"
4464 
4465 #define SECTOR_SIZE   512
4466 #define IDE_BSY       0x80
4467 #define IDE_DRDY      0x40
4468 #define IDE_DF        0x20
4469 #define IDE_ERR       0x01
4470 
4471 #define IDE_CMD_READ  0x20
4472 #define IDE_CMD_WRITE 0x30
4473 #define IDE_CMD_RDMUL 0xc4
4474 #define IDE_CMD_WRMUL 0xc5
4475 
4476 
4477 
4478 
4479 
4480 static struct spinlock idelock;
4481 static struct buf *idequeue;
4482 
4483 static int havedisk1;
4484 static void idestart(struct buf*);
4485 
4486 
4487 static int
4488 idewait(int checkerr)
4489 {
4490   int r;
4491 
4492   while(((r = inb(0x1f7)) & (IDE_BSY|IDE_DRDY)) != IDE_DRDY)
4493     ;
4494   if(checkerr && (r & (IDE_DF|IDE_ERR)) != 0)
4495     return -1;
4496   return 0;
4497 }
4498 
4499 
4500 void
4501 ideinit(void)
4502 {
4503   int i;
4504 
4505   initlock(&idelock, "ide");
4506   ioapicenable(IRQ_IDE, ncpu - 1);
4507   idewait(0);
4508 
4509   
4510   outb(0x1f6, 0xe0 | (1<<4));
4511   for(i=0; i<1000; i++){
4512     if(inb(0x1f7) != 0){
4513       havedisk1 = 1;
4514       break;
4515     }
4516   }
4517 
4518   
4519   outb(0x1f6, 0xe0 | (0<<4));
4520 }
4521 
4522 
4523 static void
4524 idestart(struct buf *b)
4525 {
4526   if(b == 0)
4527     panic("idestart");
4528   if(b->blockno >= FSSIZE)
4529     panic("incorrect blockno");
4530   int sector_per_block =  BSIZE/SECTOR_SIZE;
4531   int sector = b->blockno * sector_per_block;
4532   int read_cmd = (sector_per_block == 1) ? IDE_CMD_READ :  IDE_CMD_RDMUL;
4533   int write_cmd = (sector_per_block == 1) ? IDE_CMD_WRITE : IDE_CMD_WRMUL;
4534 
4535   if (sector_per_block > 7) panic("idestart");
4536 
4537   idewait(0);
4538   outb(0x3f6, 0);  
4539   outb(0x1f2, sector_per_block);  
4540   outb(0x1f3, sector & 0xff);
4541   outb(0x1f4, (sector >> 8) & 0xff);
4542   outb(0x1f5, (sector >> 16) & 0xff);
4543   outb(0x1f6, 0xe0 | ((b->dev&1)<<4) | ((sector>>24)&0x0f));
4544   if(b->flags & B_DIRTY){
4545     outb(0x1f7, write_cmd);
4546     outsl(0x1f0, b->data, BSIZE/4);
4547   } else {
4548     outb(0x1f7, read_cmd);
4549   }
4550 }
4551 
4552 
4553 void
4554 ideintr(void)
4555 {
4556   struct buf *b;
4557 
4558   
4559   acquire(&idelock);
4560 
4561   if((b = idequeue) == 0){
4562     release(&idelock);
4563     return;
4564   }
4565   idequeue = b->qnext;
4566 
4567   
4568   if(!(b->flags & B_DIRTY) && idewait(1) >= 0)
4569     insl(0x1f0, b->data, BSIZE/4);
4570 
4571   
4572   b->flags |= B_VALID;
4573   b->flags &= ~B_DIRTY;
4574   wakeup(b);
4575 
4576   
4577   if(idequeue != 0)
4578     idestart(idequeue);
4579 
4580   release(&idelock);
4581 }
4582 
4583 
4584 
4585 
4586 
4587 
4588 
4589 
4590 
4591 
4592 
4593 
4594 
4595 
4596 
4597 
4598 
4599 
4600 
4601 
4602 
4603 void
4604 iderw(struct buf *b)
4605 {
4606   struct buf **pp;
4607 
4608   if(!holdingsleep(&b->lock))
4609     panic("iderw: buf not locked");
4610   if((b->flags & (B_VALID|B_DIRTY)) == B_VALID)
4611     panic("iderw: nothing to do");
4612   if(b->dev != 0 && !havedisk1)
4613     panic("iderw: ide disk 1 not present");
4614 
4615   acquire(&idelock);  
4616 
4617   
4618   b->qnext = 0;
4619   for(pp=&idequeue; *pp; pp=&(*pp)->qnext)  
4620     ;
4621   *pp = b;
4622 
4623   
4624   if(idequeue == b)
4625     idestart(b);
4626 
4627   
4628   while((b->flags & (B_VALID|B_DIRTY)) != B_VALID){
4629     sleep(b, &idelock);
4630   }
4631 
4632 
4633   release(&idelock);
4634 }
4635 
4636 
4637 
4638 
4639 
4640 
4641 
4642 
4643 
4644 
4645 
4646 
4647 
4648 
4649 
4650 
4651 
4652 
4653 
4654 
4655 
4656 
4657 
4658 
4659 
4660 
4661 
4662 
4663 
4664 
4665 
4666 
4667 
4668 
4669 
4670 #include "types.h"
4671 #include "defs.h"
4672 #include "param.h"
4673 #include "spinlock.h"
4674 #include "sleeplock.h"
4675 #include "fs.h"
4676 #include "buf.h"
4677 
4678 struct {
4679   struct spinlock lock;
4680   struct buf buf[NBUF];
4681 
4682   
4683   
4684   struct buf head;
4685 } bcache;
4686 
4687 void
4688 binit(void)
4689 {
4690   struct buf *b;
4691 
4692   initlock(&bcache.lock, "bcache");
4693 
4694 
4695 
4696 
4697 
4698 
4699 
4700   
4701   bcache.head.prev = &bcache.head;
4702   bcache.head.next = &bcache.head;
4703   for(b = bcache.buf; b < bcache.buf+NBUF; b++){
4704     b->next = bcache.head.next;
4705     b->prev = &bcache.head;
4706     initsleeplock(&b->lock, "buffer");
4707     bcache.head.next->prev = b;
4708     bcache.head.next = b;
4709   }
4710 }
4711 
4712 
4713 
4714 
4715 static struct buf*
4716 bget(uint dev, uint blockno)
4717 {
4718   struct buf *b;
4719 
4720   acquire(&bcache.lock);
4721 
4722   
4723   for(b = bcache.head.next; b != &bcache.head; b = b->next){
4724     if(b->dev == dev && b->blockno == blockno){
4725       b->refcnt++;
4726       release(&bcache.lock);
4727       acquiresleep(&b->lock);
4728       return b;
4729     }
4730   }
4731 
4732   
4733   
4734   
4735   for(b = bcache.head.prev; b != &bcache.head; b = b->prev){
4736     if(b->refcnt == 0 && (b->flags & B_DIRTY) == 0) {
4737       b->dev = dev;
4738       b->blockno = blockno;
4739       b->flags = 0;
4740       b->refcnt = 1;
4741       release(&bcache.lock);
4742       acquiresleep(&b->lock);
4743       return b;
4744     }
4745   }
4746   panic("bget: no buffers");
4747 }
4748 
4749 
4750 
4751 struct buf*
4752 bread(uint dev, uint blockno)
4753 {
4754   struct buf *b;
4755 
4756   b = bget(dev, blockno);
4757   if((b->flags & B_VALID) == 0) {
4758     iderw(b);
4759   }
4760   return b;
4761 }
4762 
4763 
4764 void
4765 bwrite(struct buf *b)
4766 {
4767   if(!holdingsleep(&b->lock))
4768     panic("bwrite");
4769   b->flags |= B_DIRTY;
4770   iderw(b);
4771 }
4772 
4773 
4774 
4775 void
4776 brelse(struct buf *b)
4777 {
4778   if(!holdingsleep(&b->lock))
4779     panic("brelse");
4780 
4781   releasesleep(&b->lock);
4782 
4783   acquire(&bcache.lock);
4784   b->refcnt--;
4785   if (b->refcnt == 0) {
4786     
4787     b->next->prev = b->prev;
4788     b->prev->next = b->next;
4789     b->next = bcache.head.next;
4790     b->prev = &bcache.head;
4791     bcache.head.next->prev = b;
4792     bcache.head.next = b;
4793   }
4794 
4795   release(&bcache.lock);
4796 }
4797 
4798 
4799 
4800 
4801 
4802 
4803 
4804 
4805 
4806 
4807 
4808 
4809 
4810 
4811 
4812 
4813 
4814 
4815 
4816 
4817 
4818 
4819 
4820 
4821 
4822 
4823 
4824 
4825 
4826 
4827 
4828 
4829 
4830 
4831 
4832 
4833 
4834 
4835 
4836 
4837 
4838 
4839 
4840 
4841 
4842 
4843 
4844 
4845 
4846 
4847 
4848 
4849 
4850 
4851 
4852 #include "types.h"
4853 #include "defs.h"
4854 #include "param.h"
4855 #include "x86.h"
4856 #include "memlayout.h"
4857 #include "mmu.h"
4858 #include "proc.h"
4859 #include "spinlock.h"
4860 #include "sleeplock.h"
4861 
4862 void
4863 initsleeplock(struct sleeplock *lk, char *name)
4864 {
4865   initlock(&lk->lk, "sleep lock");
4866   lk->name = name;
4867   lk->locked = 0;
4868   lk->pid = 0;
4869 }
4870 
4871 void
4872 acquiresleep(struct sleeplock *lk)
4873 {
4874   acquire(&lk->lk);
4875   while (lk->locked) {
4876     sleep(lk, &lk->lk);
4877   }
4878   lk->locked = 1;
4879   lk->pid = myproc()->pid;
4880   release(&lk->lk);
4881 }
4882 
4883 void
4884 releasesleep(struct sleeplock *lk)
4885 {
4886   acquire(&lk->lk);
4887   lk->locked = 0;
4888   lk->pid = 0;
4889   wakeup(lk);
4890   release(&lk->lk);
4891 }
4892 
4893 
4894 
4895 
4896 
4897 
4898 
4899 
4900 int
4901 holdingsleep(struct sleeplock *lk)
4902 {
4903   int r;
4904 
4905   acquire(&lk->lk);
4906   r = lk->locked && (lk->pid == myproc()->pid);
4907   release(&lk->lk);
4908   return r;
4909 }
4910 
4911 
4912 
4913 
4914 
4915 
4916 
4917 
4918 
4919 
4920 
4921 
4922 
4923 
4924 
4925 
4926 
4927 
4928 
4929 
4930 
4931 
4932 
4933 
4934 
4935 
4936 
4937 
4938 
4939 
4940 
4941 
4942 
4943 
4944 
4945 
4946 
4947 
4948 
4949 
4950 #include "types.h"
4951 #include "defs.h"
4952 #include "param.h"
4953 #include "spinlock.h"
4954 #include "sleeplock.h"
4955 #include "fs.h"
4956 #include "buf.h"
4957 
4958 
4959 
4960 
4961 
4962 
4963 
4964 
4965 
4966 
4967 
4968 
4969 
4970 
4971 
4972 
4973 
4974 
4975 
4976 
4977 
4978 
4979 
4980 
4981 
4982 
4983 struct logheader {
4984   int n;
4985   int block[LOGSIZE];
4986 };
4987 
4988 struct log {
4989   struct spinlock lock;
4990   int start;
4991   int size;
4992   int outstanding; 
4993   int committing;  
4994   int dev;
4995   struct logheader lh;
4996 };
4997 
4998 
4999 
5000 struct log log;
5001 
5002 static void recover_from_log(void);
5003 static void commit();
5004 
5005 void
5006 initlog(int dev)
5007 {
5008   if (sizeof(struct logheader) >= BSIZE)
5009     panic("initlog: too big logheader");
5010 
5011   struct superblock sb;
5012   initlock(&log.lock, "log");
5013   readsb(dev, &sb);
5014   log.start = sb.logstart;
5015   log.size = sb.nlog;
5016   log.dev = dev;
5017   recover_from_log();
5018 }
5019 
5020 
5021 static void
5022 install_trans(void)
5023 {
5024   int tail;
5025 
5026   for (tail = 0; tail < log.lh.n; tail++) {
5027     struct buf *lbuf = bread(log.dev, log.start+tail+1); 
5028     struct buf *dbuf = bread(log.dev, log.lh.block[tail]); 
5029     memmove(dbuf->data, lbuf->data, BSIZE);  
5030     bwrite(dbuf);  
5031     brelse(lbuf);
5032     brelse(dbuf);
5033   }
5034 }
5035 
5036 
5037 static void
5038 read_head(void)
5039 {
5040   struct buf *buf = bread(log.dev, log.start);
5041   struct logheader *lh = (struct logheader *) (buf->data);
5042   int i;
5043   log.lh.n = lh->n;
5044   for (i = 0; i < log.lh.n; i++) {
5045     log.lh.block[i] = lh->block[i];
5046   }
5047   brelse(buf);
5048 }
5049 
5050 
5051 
5052 
5053 static void
5054 write_head(void)
5055 {
5056   struct buf *buf = bread(log.dev, log.start);
5057   struct logheader *hb = (struct logheader *) (buf->data);
5058   int i;
5059   hb->n = log.lh.n;
5060   for (i = 0; i < log.lh.n; i++) {
5061     hb->block[i] = log.lh.block[i];
5062   }
5063   bwrite(buf);
5064   brelse(buf);
5065 }
5066 
5067 static void
5068 recover_from_log(void)
5069 {
5070   read_head();
5071   install_trans(); 
5072   log.lh.n = 0;
5073   write_head(); 
5074 }
5075 
5076 
5077 void
5078 begin_op(void)
5079 {
5080   acquire(&log.lock);
5081   while(1){
5082     if(log.committing){
5083       sleep(&log, &log.lock);
5084     } else if(log.lh.n + (log.outstanding+1)*MAXOPBLOCKS > LOGSIZE){
5085       
5086       sleep(&log, &log.lock);
5087     } else {
5088       log.outstanding += 1;
5089       release(&log.lock);
5090       break;
5091     }
5092   }
5093 }
5094 
5095 
5096 
5097 
5098 
5099 
5100 
5101 
5102 void
5103 end_op(void)
5104 {
5105   int do_commit = 0;
5106 
5107   acquire(&log.lock);
5108   log.outstanding -= 1;
5109   if(log.committing)
5110     panic("log.committing");
5111   if(log.outstanding == 0){
5112     do_commit = 1;
5113     log.committing = 1;
5114   } else {
5115     
5116     
5117     
5118     wakeup(&log);
5119   }
5120   release(&log.lock);
5121 
5122   if(do_commit){
5123     
5124     
5125     commit();
5126     acquire(&log.lock);
5127     log.committing = 0;
5128     wakeup(&log);
5129     release(&log.lock);
5130   }
5131 }
5132 
5133 
5134 static void
5135 write_log(void)
5136 {
5137   int tail;
5138 
5139   for (tail = 0; tail < log.lh.n; tail++) {
5140     struct buf *to = bread(log.dev, log.start+tail+1); 
5141     struct buf *from = bread(log.dev, log.lh.block[tail]); 
5142     memmove(to->data, from->data, BSIZE);
5143     bwrite(to);  
5144     brelse(from);
5145     brelse(to);
5146   }
5147 }
5148 
5149 
5150 static void
5151 commit()
5152 {
5153   if (log.lh.n > 0) {
5154     write_log();     
5155     write_head();    
5156     install_trans(); 
5157     log.lh.n = 0;
5158     write_head();    
5159   }
5160 }
5161 
5162 
5163 
5164 
5165 
5166 
5167 
5168 
5169 
5170 
5171 void
5172 log_write(struct buf *b)
5173 {
5174   int i;
5175 
5176   if (log.lh.n >= LOGSIZE || log.lh.n >= log.size - 1)
5177     panic("too big a transaction");
5178   if (log.outstanding < 1)
5179     panic("log_write outside of trans");
5180 
5181   acquire(&log.lock);
5182   for (i = 0; i < log.lh.n; i++) {
5183     if (log.lh.block[i] == b->blockno)   
5184       break;
5185   }
5186   log.lh.block[i] = b->blockno;
5187   if (i == log.lh.n)
5188     log.lh.n++;
5189   b->flags |= B_DIRTY; 
5190   release(&log.lock);
5191 }
5192 
5193 
5194 
5195 
5196 
5197 
5198 
5199 
5200 
5201 
5202 
5203 
5204 
5205 
5206 
5207 
5208 
5209 
5210 
5211 #include "types.h"
5212 #include "defs.h"
5213 #include "param.h"
5214 #include "stat.h"
5215 #include "mmu.h"
5216 #include "proc.h"
5217 #include "spinlock.h"
5218 #include "sleeplock.h"
5219 #include "fs.h"
5220 #include "buf.h"
5221 #include "file.h"
5222 
5223 #define min(a, b) ((a) < (b) ? (a) : (b))
5224 static void itrunc(struct inode*);
5225 
5226 
5227 struct superblock sb;
5228 
5229 
5230 void
5231 readsb(int dev, struct superblock *sb)
5232 {
5233   struct buf *bp;
5234 
5235   bp = bread(dev, 1);
5236   memmove(sb, bp->data, sizeof(*sb));
5237   brelse(bp);
5238 }
5239 
5240 
5241 
5242 
5243 
5244 
5245 
5246 
5247 
5248 
5249 
5250 
5251 static void
5252 bzero(int dev, int bno)
5253 {
5254   struct buf *bp;
5255 
5256   bp = bread(dev, bno);
5257   memset(bp->data, 0, BSIZE);
5258   log_write(bp);
5259   brelse(bp);
5260 }
5261 
5262 
5263 
5264 
5265 static uint
5266 balloc(uint dev)
5267 {
5268   int b, bi, m;
5269   struct buf *bp;
5270 
5271   bp = 0;
5272   for(b = 0; b < sb.size; b += BPB){
5273     bp = bread(dev, BBLOCK(b, sb));
5274     for(bi = 0; bi < BPB && b + bi < sb.size; bi++){
5275       m = 1 << (bi % 8);
5276       if((bp->data[bi/8] & m) == 0){  
5277         bp->data[bi/8] |= m;  
5278         log_write(bp);
5279         brelse(bp);
5280         bzero(dev, b + bi);
5281         return b + bi;
5282       }
5283     }
5284     brelse(bp);
5285   }
5286   panic("balloc: out of blocks");
5287 }
5288 
5289 
5290 
5291 
5292 
5293 
5294 
5295 
5296 
5297 
5298 
5299 
5300 
5301 static void
5302 bfree(int dev, uint b)
5303 {
5304   struct buf *bp;
5305   int bi, m;
5306 
5307   bp = bread(dev, BBLOCK(b, sb));
5308   bi = b % BPB;
5309   m = 1 << (bi % 8);
5310   if((bp->data[bi/8] & m) == 0)
5311     panic("freeing free block");
5312   bp->data[bi/8] &= ~m;
5313   log_write(bp);
5314   brelse(bp);
5315 }
5316 
5317 
5318 
5319 
5320 
5321 
5322 
5323 
5324 
5325 
5326 
5327 
5328 
5329 
5330 
5331 
5332 
5333 
5334 
5335 
5336 
5337 
5338 
5339 
5340 
5341 
5342 
5343 
5344 
5345 
5346 
5347 
5348 
5349 
5350 
5351 
5352 
5353 
5354 
5355 
5356 
5357 
5358 
5359 
5360 
5361 
5362 
5363 
5364 
5365 
5366 
5367 
5368 
5369 
5370 
5371 
5372 
5373 
5374 
5375 
5376 
5377 
5378 
5379 
5380 
5381 
5382 
5383 
5384 
5385 
5386 struct {
5387   struct spinlock lock;
5388   struct inode inode[NINODE];
5389 } icache;
5390 
5391 void
5392 iinit(int dev)
5393 {
5394   int i = 0;
5395 
5396   initlock(&icache.lock, "icache");
5397   for(i = 0; i < NINODE; i++) {
5398     initsleeplock(&icache.inode[i].lock, "inode");
5399   }
5400   readsb(dev, &sb);
5401   cprintf("sb: size %d nblocks %d ninodes %d nlog %d logstart %d\
5402  inodestart %d bmap start %d\n", sb.size, sb.nblocks,
5403           sb.ninodes, sb.nlog, sb.logstart, sb.inodestart,
5404           sb.bmapstart);
5405 }
5406 
5407 static struct inode* iget(uint dev, uint inum);
5408 
5409 
5410 
5411 
5412 
5413 
5414 
5415 
5416 
5417 
5418 
5419 
5420 
5421 
5422 
5423 
5424 
5425 
5426 
5427 
5428 
5429 
5430 
5431 
5432 
5433 
5434 
5435 
5436 
5437 
5438 
5439 
5440 
5441 
5442 
5443 
5444 
5445 
5446 
5447 
5448 
5449 
5450 
5451 
5452 
5453 struct inode*
5454 ialloc(uint dev, short type)
5455 {
5456   int inum;
5457   struct buf *bp;
5458   struct dinode *dip;
5459 
5460   for(inum = 1; inum < sb.ninodes; inum++){
5461     bp = bread(dev, IBLOCK(inum, sb));
5462     dip = (struct dinode*)bp->data + inum%IPB;
5463     if(dip->type == 0){  
5464       memset(dip, 0, sizeof(*dip));
5465       dip->type = type;
5466       log_write(bp);   
5467       brelse(bp);
5468       return iget(dev, inum);
5469     }
5470     brelse(bp);
5471   }
5472   panic("ialloc: no inodes");
5473 }
5474 
5475 
5476 
5477 
5478 
5479 void
5480 iupdate(struct inode *ip)
5481 {
5482   struct buf *bp;
5483   struct dinode *dip;
5484 
5485   bp = bread(ip->dev, IBLOCK(ip->inum, sb));
5486   dip = (struct dinode*)bp->data + ip->inum%IPB;
5487   dip->type = ip->type;
5488   dip->major = ip->major;
5489   dip->minor = ip->minor;
5490   dip->nlink = ip->nlink;
5491   dip->size = ip->size;
5492   memmove(dip->addrs, ip->addrs, sizeof(ip->addrs));
5493   log_write(bp);
5494   brelse(bp);
5495 }
5496 
5497 
5498 
5499 
5500 
5501 
5502 
5503 static struct inode*
5504 iget(uint dev, uint inum)
5505 {
5506   struct inode *ip, *empty;
5507 
5508   acquire(&icache.lock);
5509 
5510   
5511   empty = 0;
5512   for(ip = &icache.inode[0]; ip < &icache.inode[NINODE]; ip++){
5513     if(ip->ref > 0 && ip->dev == dev && ip->inum == inum){
5514       ip->ref++;
5515       release(&icache.lock);
5516       return ip;
5517     }
5518     if(empty == 0 && ip->ref == 0)    
5519       empty = ip;
5520   }
5521 
5522   
5523   if(empty == 0)
5524     panic("iget: no inodes");
5525 
5526   ip = empty;
5527   ip->dev = dev;
5528   ip->inum = inum;
5529   ip->ref = 1;
5530   ip->valid = 0;
5531   release(&icache.lock);
5532 
5533   return ip;
5534 }
5535 
5536 
5537 
5538 struct inode*
5539 idup(struct inode *ip)
5540 {
5541   acquire(&icache.lock);
5542   ip->ref++;
5543   release(&icache.lock);
5544   return ip;
5545 }
5546 
5547 
5548 
5549 
5550 
5551 
5552 void
5553 ilock(struct inode *ip)
5554 {
5555   struct buf *bp;
5556   struct dinode *dip;
5557 
5558   if(ip == 0 || ip->ref < 1)
5559     panic("ilock");
5560 
5561   acquiresleep(&ip->lock);
5562 
5563   if(ip->valid == 0){
5564     bp = bread(ip->dev, IBLOCK(ip->inum, sb));
5565     dip = (struct dinode*)bp->data + ip->inum%IPB;
5566     ip->type = dip->type;
5567     ip->major = dip->major;
5568     ip->minor = dip->minor;
5569     ip->nlink = dip->nlink;
5570     ip->size = dip->size;
5571     memmove(ip->addrs, dip->addrs, sizeof(ip->addrs));
5572     brelse(bp);
5573     ip->valid = 1;
5574     if(ip->type == 0)
5575       panic("ilock: no type");
5576   }
5577 }
5578 
5579 
5580 void
5581 iunlock(struct inode *ip)
5582 {
5583   if(ip == 0 || !holdingsleep(&ip->lock) || ip->ref < 1)
5584     panic("iunlock");
5585 
5586   releasesleep(&ip->lock);
5587 }
5588 
5589 
5590 
5591 
5592 
5593 
5594 
5595 
5596 
5597 
5598 
5599 
5600 
5601 
5602 
5603 
5604 
5605 
5606 
5607 void
5608 iput(struct inode *ip)
5609 {
5610   acquiresleep(&ip->lock);
5611   if(ip->valid && ip->nlink == 0){
5612     acquire(&icache.lock);
5613     int r = ip->ref;
5614     release(&icache.lock);
5615     if(r == 1){
5616       
5617       itrunc(ip);
5618       ip->type = 0;
5619       iupdate(ip);
5620       ip->valid = 0;
5621     }
5622   }
5623   releasesleep(&ip->lock);
5624 
5625   acquire(&icache.lock);
5626   ip->ref--;
5627   release(&icache.lock);
5628 }
5629 
5630 
5631 void
5632 iunlockput(struct inode *ip)
5633 {
5634   iunlock(ip);
5635   iput(ip);
5636 }
5637 
5638 
5639 
5640 
5641 
5642 
5643 
5644 
5645 
5646 
5647 
5648 
5649 
5650 
5651 
5652 
5653 
5654 
5655 
5656 
5657 
5658 
5659 static uint
5660 bmap(struct inode *ip, uint bn)
5661 {
5662   uint addr, *a;
5663   struct buf *bp;
5664 
5665   if(bn < NDIRECT){
5666     if((addr = ip->addrs[bn]) == 0)
5667       ip->addrs[bn] = addr = balloc(ip->dev);
5668     return addr;
5669   }
5670   bn -= NDIRECT;
5671 
5672   if(bn < NINDIRECT){
5673     
5674     if((addr = ip->addrs[NDIRECT]) == 0)
5675       ip->addrs[NDIRECT] = addr = balloc(ip->dev);
5676     bp = bread(ip->dev, addr);
5677     a = (uint*)bp->data;
5678     if((addr = a[bn]) == 0){
5679       a[bn] = addr = balloc(ip->dev);
5680       log_write(bp);
5681     }
5682     brelse(bp);
5683     return addr;
5684   }
5685 
5686   panic("bmap: out of range");
5687 }
5688 
5689 
5690 
5691 
5692 
5693 
5694 
5695 
5696 
5697 
5698 
5699 
5700 
5701 
5702 
5703 
5704 
5705 static void
5706 itrunc(struct inode *ip)
5707 {
5708   int i, j;
5709   struct buf *bp;
5710   uint *a;
5711 
5712   for(i = 0; i < NDIRECT; i++){
5713     if(ip->addrs[i]){
5714       bfree(ip->dev, ip->addrs[i]);
5715       ip->addrs[i] = 0;
5716     }
5717   }
5718 
5719   if(ip->addrs[NDIRECT]){
5720     bp = bread(ip->dev, ip->addrs[NDIRECT]);
5721     a = (uint*)bp->data;
5722     for(j = 0; j < NINDIRECT; j++){
5723       if(a[j])
5724         bfree(ip->dev, a[j]);
5725     }
5726     brelse(bp);
5727     bfree(ip->dev, ip->addrs[NDIRECT]);
5728     ip->addrs[NDIRECT] = 0;
5729   }
5730 
5731   ip->size = 0;
5732   iupdate(ip);
5733 }
5734 
5735 
5736 
5737 void
5738 stati(struct inode *ip, struct stat *st)
5739 {
5740   st->dev = ip->dev;
5741   st->ino = ip->inum;
5742   st->type = ip->type;
5743   st->nlink = ip->nlink;
5744   st->size = ip->size;
5745 }
5746 
5747 
5748 
5749 
5750 
5751 
5752 int
5753 readi(struct inode *ip, char *dst, uint off, uint n)
5754 {
5755   uint tot, m;
5756   struct buf *bp;
5757 
5758   if(ip->type == T_DEV){
5759     if(ip->major < 0 || ip->major >= NDEV || !devsw[ip->major].read)
5760       return -1;
5761     return devsw[ip->major].read(ip, dst, n);
5762   }
5763 
5764   if(off > ip->size || off + n < off)
5765     return -1;
5766   if(off + n > ip->size)
5767     n = ip->size - off;
5768 
5769   for(tot=0; tot<n; tot+=m, off+=m, dst+=m){
5770     bp = bread(ip->dev, bmap(ip, off/BSIZE));
5771     m = min(n - tot, BSIZE - off%BSIZE);
5772     memmove(dst, bp->data + off%BSIZE, m);
5773     brelse(bp);
5774   }
5775   return n;
5776 }
5777 
5778 
5779 
5780 
5781 
5782 
5783 
5784 
5785 
5786 
5787 
5788 
5789 
5790 
5791 
5792 
5793 
5794 
5795 
5796 
5797 
5798 
5799 
5800 
5801 
5802 int
5803 writei(struct inode *ip, char *src, uint off, uint n)
5804 {
5805   uint tot, m;
5806   struct buf *bp;
5807 
5808   if(ip->type == T_DEV){
5809     if(ip->major < 0 || ip->major >= NDEV || !devsw[ip->major].write)
5810       return -1;
5811     return devsw[ip->major].write(ip, src, n);
5812   }
5813 
5814   if(off > ip->size || off + n < off)
5815     return -1;
5816   if(off + n > MAXFILE*BSIZE)
5817     return -1;
5818 
5819   for(tot=0; tot<n; tot+=m, off+=m, src+=m){
5820     bp = bread(ip->dev, bmap(ip, off/BSIZE));
5821     m = min(n - tot, BSIZE - off%BSIZE);
5822     memmove(bp->data + off%BSIZE, src, m);
5823     log_write(bp);
5824     brelse(bp);
5825   }
5826 
5827   if(n > 0 && off > ip->size){
5828     ip->size = off;
5829     iupdate(ip);
5830   }
5831   return n;
5832 }
5833 
5834 
5835 
5836 
5837 
5838 
5839 
5840 
5841 
5842 
5843 
5844 
5845 
5846 
5847 
5848 
5849 
5850 
5851 
5852 int
5853 namecmp(const char *s, const char *t)
5854 {
5855   return strncmp(s, t, DIRSIZ);
5856 }
5857 
5858 
5859 
5860 struct inode*
5861 dirlookup(struct inode *dp, char *name, uint *poff)
5862 {
5863   uint off, inum;
5864   struct dirent de;
5865 
5866   if(dp->type != T_DIR)
5867     panic("dirlookup not DIR");
5868 
5869   for(off = 0; off < dp->size; off += sizeof(de)){
5870     if(readi(dp, (char*)&de, off, sizeof(de)) != sizeof(de))
5871       panic("dirlookup read");
5872     if(de.inum == 0)
5873       continue;
5874     if(namecmp(name, de.name) == 0){
5875       
5876       if(poff)
5877         *poff = off;
5878       inum = de.inum;
5879       return iget(dp->dev, inum);
5880     }
5881   }
5882 
5883   return 0;
5884 }
5885 
5886 
5887 
5888 
5889 
5890 
5891 
5892 
5893 
5894 
5895 
5896 
5897 
5898 
5899 
5900 
5901 int
5902 dirlink(struct inode *dp, char *name, uint inum)
5903 {
5904   int off;
5905   struct dirent de;
5906   struct inode *ip;
5907 
5908   
5909   if((ip = dirlookup(dp, name, 0)) != 0){
5910     iput(ip);
5911     return -1;
5912   }
5913 
5914   
5915   for(off = 0; off < dp->size; off += sizeof(de)){
5916     if(readi(dp, (char*)&de, off, sizeof(de)) != sizeof(de))
5917       panic("dirlink read");
5918     if(de.inum == 0)
5919       break;
5920   }
5921 
5922   strncpy(de.name, name, DIRSIZ);
5923   de.inum = inum;
5924   if(writei(dp, (char*)&de, off, sizeof(de)) != sizeof(de))
5925     panic("dirlink");
5926 
5927   return 0;
5928 }
5929 
5930 
5931 
5932 
5933 
5934 
5935 
5936 
5937 
5938 
5939 
5940 
5941 
5942 
5943 
5944 
5945 
5946 
5947 
5948 
5949 
5950 
5951 
5952 
5953 
5954 
5955 
5956 
5957 
5958 
5959 
5960 
5961 
5962 
5963 
5964 static char*
5965 skipelem(char *path, char *name)
5966 {
5967   char *s;
5968   int len;
5969 
5970   while(*path == '/')
5971     path++;
5972   if(*path == 0)
5973     return 0;
5974   s = path;
5975   while(*path != '/' && *path != 0)
5976     path++;
5977   len = path - s;
5978   if(len >= DIRSIZ)
5979     memmove(name, s, DIRSIZ);
5980   else {
5981     memmove(name, s, len);
5982     name[len] = 0;
5983   }
5984   while(*path == '/')
5985     path++;
5986   return path;
5987 }
5988 
5989 
5990 
5991 
5992 
5993 
5994 
5995 
5996 
5997 
5998 
5999 
6000 
6001 
6002 
6003 
6004 static struct inode*
6005 namex(char *path, int nameiparent, char *name)
6006 {
6007   struct inode *ip, *next;
6008 
6009   if(*path == '/')
6010     ip = iget(ROOTDEV, ROOTINO);
6011   else
6012     ip = idup(myproc()->cwd);
6013 
6014   while((path = skipelem(path, name)) != 0){
6015     ilock(ip);
6016     if(ip->type != T_DIR){
6017       iunlockput(ip);
6018       return 0;
6019     }
6020     if(nameiparent && *path == '\0'){
6021       
6022       iunlock(ip);
6023       return ip;
6024     }
6025     if((next = dirlookup(ip, name, 0)) == 0){
6026       iunlockput(ip);
6027       return 0;
6028     }
6029     iunlockput(ip);
6030     ip = next;
6031   }
6032   if(nameiparent){
6033     iput(ip);
6034     return 0;
6035   }
6036   return ip;
6037 }
6038 
6039 struct inode*
6040 namei(char *path)
6041 {
6042   char name[DIRSIZ];
6043   return namex(path, 0, name);
6044 }
6045 
6046 
6047 
6048 
6049 
6050 struct inode*
6051 nameiparent(char *path, char *name)
6052 {
6053   return namex(path, 1, name);
6054 }
6055 
6056 
6057 
6058 
6059 
6060 
6061 
6062 
6063 
6064 
6065 
6066 
6067 
6068 
6069 
6070 
6071 
6072 
6073 
6074 
6075 
6076 
6077 
6078 
6079 
6080 
6081 
6082 
6083 
6084 
6085 
6086 
6087 
6088 
6089 
6090 
6091 
6092 
6093 
6094 
6095 
6096 
6097 
6098 
6099 
6100 
6101 
6102 
6103 
6104 #include "types.h"
6105 #include "defs.h"
6106 #include "param.h"
6107 #include "fs.h"
6108 #include "spinlock.h"
6109 #include "sleeplock.h"
6110 #include "file.h"
6111 
6112 struct devsw devsw[NDEV];
6113 struct {
6114   struct spinlock lock;
6115   struct file file[NFILE];
6116 } ftable;
6117 
6118 void
6119 fileinit(void)
6120 {
6121   initlock(&ftable.lock, "ftable");
6122 }
6123 
6124 
6125 struct file*
6126 filealloc(void)
6127 {
6128   struct file *f;
6129 
6130   acquire(&ftable.lock);
6131   for(f = ftable.file; f < ftable.file + NFILE; f++){
6132     if(f->ref == 0){
6133       f->ref = 1;
6134       release(&ftable.lock);
6135       return f;
6136     }
6137   }
6138   release(&ftable.lock);
6139   return 0;
6140 }
6141 
6142 
6143 
6144 
6145 
6146 
6147 
6148 
6149 
6150 
6151 struct file*
6152 filedup(struct file *f)
6153 {
6154   acquire(&ftable.lock);
6155   if(f->ref < 1)
6156     panic("filedup");
6157   f->ref++;
6158   release(&ftable.lock);
6159   return f;
6160 }
6161 
6162 
6163 void
6164 fileclose(struct file *f)
6165 {
6166   struct file ff;
6167 
6168   acquire(&ftable.lock);
6169   if(f->ref < 1)
6170     panic("fileclose");
6171   if(--f->ref > 0){
6172     release(&ftable.lock);
6173     return;
6174   }
6175   ff = *f;
6176   f->ref = 0;
6177   f->type = FD_NONE;
6178   release(&ftable.lock);
6179 
6180   if(ff.type == FD_PIPE)
6181     pipeclose(ff.pipe, ff.writable);
6182   else if(ff.type == FD_INODE){
6183     begin_op();
6184     iput(ff.ip);
6185     end_op();
6186   }
6187 }
6188 
6189 
6190 
6191 
6192 
6193 
6194 
6195 
6196 
6197 
6198 
6199 
6200 
6201 int
6202 filestat(struct file *f, struct stat *st)
6203 {
6204   if(f->type == FD_INODE){
6205     ilock(f->ip);
6206     stati(f->ip, st);
6207     iunlock(f->ip);
6208     return 0;
6209   }
6210   return -1;
6211 }
6212 
6213 
6214 int
6215 fileread(struct file *f, char *addr, int n)
6216 {
6217   int r;
6218 
6219   if(f->readable == 0)
6220     return -1;
6221   if(f->type == FD_PIPE)
6222     return piperead(f->pipe, addr, n);
6223   if(f->type == FD_INODE){
6224     ilock(f->ip);
6225     if((r = readi(f->ip, addr, f->off, n)) > 0)
6226       f->off += r;
6227     iunlock(f->ip);
6228     return r;
6229   }
6230   panic("fileread");
6231 }
6232 
6233 
6234 
6235 
6236 
6237 
6238 
6239 
6240 
6241 
6242 
6243 
6244 
6245 
6246 
6247 
6248 
6249 
6250 
6251 int
6252 filewrite(struct file *f, char *addr, int n)
6253 {
6254   int r;
6255 
6256   if(f->writable == 0)
6257     return -1;
6258   if(f->type == FD_PIPE)
6259     return pipewrite(f->pipe, addr, n);
6260   if(f->type == FD_INODE){
6261     
6262     
6263     
6264     
6265     
6266     
6267     int max = ((MAXOPBLOCKS-1-1-2) / 2) * 512;
6268     int i = 0;
6269     while(i < n){
6270       int n1 = n - i;
6271       if(n1 > max)
6272         n1 = max;
6273 
6274       begin_op();
6275       ilock(f->ip);
6276       if ((r = writei(f->ip, addr + i, f->off, n1)) > 0)
6277         f->off += r;
6278       iunlock(f->ip);
6279       end_op();
6280 
6281       if(r < 0)
6282         break;
6283       if(r != n1)
6284         panic("short filewrite");
6285       i += r;
6286     }
6287     return i == n ? n : -1;
6288   }
6289   panic("filewrite");
6290 }
6291 
6292 
6293 
6294 
6295 
6296 
6297 
6298 
6299 
6300 
6301 
6302 
6303 
6304 
6305 
6306 #include "types.h"
6307 #include "defs.h"
6308 #include "param.h"
6309 #include "stat.h"
6310 #include "mmu.h"
6311 #include "proc.h"
6312 #include "fs.h"
6313 #include "spinlock.h"
6314 #include "sleeplock.h"
6315 #include "file.h"
6316 #include "fcntl.h"
6317 
6318 
6319 
6320 static int
6321 argfd(int n, int *pfd, struct file **pf)
6322 {
6323   int fd;
6324   struct file *f;
6325 
6326   if(argint(n, &fd) < 0)
6327     return -1;
6328   if(fd < 0 || fd >= NOFILE || (f=myproc()->ofile[fd]) == 0)
6329     return -1;
6330   if(pfd)
6331     *pfd = fd;
6332   if(pf)
6333     *pf = f;
6334   return 0;
6335 }
6336 
6337 
6338 
6339 
6340 
6341 
6342 
6343 
6344 
6345 
6346 
6347 
6348 
6349 
6350 
6351 
6352 static int
6353 fdalloc(struct file *f)
6354 {
6355   int fd;
6356   struct proc *curproc = myproc();
6357 
6358   for(fd = 0; fd < NOFILE; fd++){
6359     if(curproc->ofile[fd] == 0){
6360       curproc->ofile[fd] = f;
6361       return fd;
6362     }
6363   }
6364   return -1;
6365 }
6366 
6367 int
6368 sys_dup(void)
6369 {
6370   struct file *f;
6371   int fd;
6372 
6373   if(argfd(0, 0, &f) < 0)
6374     return -1;
6375   if((fd=fdalloc(f)) < 0)
6376     return -1;
6377   filedup(f);
6378   return fd;
6379 }
6380 
6381 int
6382 sys_read(void)
6383 {
6384   struct file *f;
6385   int n;
6386   char *p;
6387 
6388   if(argfd(0, 0, &f) < 0 || argint(2, &n) < 0 || argptr(1, &p, n) < 0)
6389     return -1;
6390   return fileread(f, p, n);
6391 }
6392 
6393 
6394 
6395 
6396 
6397 
6398 
6399 
6400 int
6401 sys_write(void)
6402 {
6403   struct file *f;
6404   int n;
6405   char *p;
6406 
6407   if(argfd(0, 0, &f) < 0 || argint(2, &n) < 0 || argptr(1, &p, n) < 0)
6408     return -1;
6409   return filewrite(f, p, n);
6410 }
6411 
6412 int
6413 sys_close(void)
6414 {
6415   int fd;
6416   struct file *f;
6417 
6418   if(argfd(0, &fd, &f) < 0)
6419     return -1;
6420   myproc()->ofile[fd] = 0;
6421   fileclose(f);
6422   return 0;
6423 }
6424 
6425 int
6426 sys_fstat(void)
6427 {
6428   struct file *f;
6429   struct stat *st;
6430 
6431   if(argfd(0, 0, &f) < 0 || argptr(1, (void*)&st, sizeof(*st)) < 0)
6432     return -1;
6433   return filestat(f, st);
6434 }
6435 
6436 
6437 
6438 
6439 
6440 
6441 
6442 
6443 
6444 
6445 
6446 
6447 
6448 
6449 
6450 
6451 int
6452 sys_link(void)
6453 {
6454   char name[DIRSIZ], *new, *old;
6455   struct inode *dp, *ip;
6456 
6457   if(argstr(0, &old) < 0 || argstr(1, &new) < 0)
6458     return -1;
6459 
6460   begin_op();
6461   if((ip = namei(old)) == 0){
6462     end_op();
6463     return -1;
6464   }
6465 
6466   ilock(ip);
6467   if(ip->type == T_DIR){
6468     iunlockput(ip);
6469     end_op();
6470     return -1;
6471   }
6472 
6473   ip->nlink++;
6474   iupdate(ip);
6475   iunlock(ip);
6476 
6477   if((dp = nameiparent(new, name)) == 0)
6478     goto bad;
6479   ilock(dp);
6480   if(dp->dev != ip->dev || dirlink(dp, name, ip->inum) < 0){
6481     iunlockput(dp);
6482     goto bad;
6483   }
6484   iunlockput(dp);
6485   iput(ip);
6486 
6487   end_op();
6488 
6489   return 0;
6490 
6491 bad:
6492   ilock(ip);
6493   ip->nlink--;
6494   iupdate(ip);
6495   iunlockput(ip);
6496   end_op();
6497   return -1;
6498 }
6499 
6500 
6501 static int
6502 isdirempty(struct inode *dp)
6503 {
6504   int off;
6505   struct dirent de;
6506 
6507   for(off=2*sizeof(de); off<dp->size; off+=sizeof(de)){
6508     if(readi(dp, (char*)&de, off, sizeof(de)) != sizeof(de))
6509       panic("isdirempty: readi");
6510     if(de.inum != 0)
6511       return 0;
6512   }
6513   return 1;
6514 }
6515 
6516 
6517 
6518 
6519 
6520 
6521 
6522 
6523 
6524 
6525 
6526 
6527 
6528 
6529 
6530 
6531 
6532 
6533 
6534 
6535 
6536 
6537 
6538 
6539 
6540 
6541 
6542 
6543 
6544 
6545 
6546 
6547 
6548 
6549 
6550 int
6551 sys_unlink(void)
6552 {
6553   struct inode *ip, *dp;
6554   struct dirent de;
6555   char name[DIRSIZ], *path;
6556   uint off;
6557 
6558   if(argstr(0, &path) < 0)
6559     return -1;
6560 
6561   begin_op();
6562   if((dp = nameiparent(path, name)) == 0){
6563     end_op();
6564     return -1;
6565   }
6566 
6567   ilock(dp);
6568 
6569   
6570   if(namecmp(name, ".") == 0 || namecmp(name, "..") == 0)
6571     goto bad;
6572 
6573   if((ip = dirlookup(dp, name, &off)) == 0)
6574     goto bad;
6575   ilock(ip);
6576 
6577   if(ip->nlink < 1)
6578     panic("unlink: nlink < 1");
6579   if(ip->type == T_DIR && !isdirempty(ip)){
6580     iunlockput(ip);
6581     goto bad;
6582   }
6583 
6584   memset(&de, 0, sizeof(de));
6585   if(writei(dp, (char*)&de, off, sizeof(de)) != sizeof(de))
6586     panic("unlink: writei");
6587   if(ip->type == T_DIR){
6588     dp->nlink--;
6589     iupdate(dp);
6590   }
6591   iunlockput(dp);
6592 
6593   ip->nlink--;
6594   iupdate(ip);
6595   iunlockput(ip);
6596 
6597   end_op();
6598 
6599   return 0;
6600 bad:
6601   iunlockput(dp);
6602   end_op();
6603   return -1;
6604 }
6605 
6606 static struct inode*
6607 create(char *path, short type, short major, short minor)
6608 {
6609   struct inode *ip, *dp;
6610   char name[DIRSIZ];
6611 
6612   if((dp = nameiparent(path, name)) == 0)
6613     return 0;
6614   ilock(dp);
6615 
6616   if((ip = dirlookup(dp, name, 0)) != 0){
6617     iunlockput(dp);
6618     ilock(ip);
6619     if(type == T_FILE && ip->type == T_FILE)
6620       return ip;
6621     iunlockput(ip);
6622     return 0;
6623   }
6624 
6625   if((ip = ialloc(dp->dev, type)) == 0)
6626     panic("create: ialloc");
6627 
6628   ilock(ip);
6629   ip->major = major;
6630   ip->minor = minor;
6631   ip->nlink = 1;
6632   iupdate(ip);
6633 
6634   if(type == T_DIR){  
6635     dp->nlink++;  
6636     iupdate(dp);
6637     
6638     if(dirlink(ip, ".", ip->inum) < 0 || dirlink(ip, "..", dp->inum) < 0)
6639       panic("create dots");
6640   }
6641 
6642   if(dirlink(dp, name, ip->inum) < 0)
6643     panic("create: dirlink");
6644 
6645   iunlockput(dp);
6646 
6647   return ip;
6648 }
6649 
6650 int
6651 sys_open(void)
6652 {
6653   char *path;
6654   int fd, omode;
6655   struct file *f;
6656   struct inode *ip;
6657 
6658   if(argstr(0, &path) < 0 || argint(1, &omode) < 0)
6659     return -1;
6660 
6661   begin_op();
6662 
6663   if(omode & O_CREATE){
6664     ip = create(path, T_FILE, 0, 0);
6665     if(ip == 0){
6666       end_op();
6667       return -1;
6668     }
6669   } else {
6670     if((ip = namei(path)) == 0){
6671       end_op();
6672       return -1;
6673     }
6674     ilock(ip);
6675     if(ip->type == T_DIR && omode != O_RDONLY){
6676       iunlockput(ip);
6677       end_op();
6678       return -1;
6679     }
6680   }
6681 
6682   if((f = filealloc()) == 0 || (fd = fdalloc(f)) < 0){
6683     if(f)
6684       fileclose(f);
6685     iunlockput(ip);
6686     end_op();
6687     return -1;
6688   }
6689   iunlock(ip);
6690   end_op();
6691 
6692   f->type = FD_INODE;
6693   f->ip = ip;
6694   f->off = 0;
6695   f->readable = !(omode & O_WRONLY);
6696   f->writable = (omode & O_WRONLY) || (omode & O_RDWR);
6697   return fd;
6698 }
6699 
6700 int
6701 sys_mkdir(void)
6702 {
6703   char *path;
6704   struct inode *ip;
6705 
6706   begin_op();
6707   if(argstr(0, &path) < 0 || (ip = create(path, T_DIR, 0, 0)) == 0){
6708     end_op();
6709     return -1;
6710   }
6711   iunlockput(ip);
6712   end_op();
6713   return 0;
6714 }
6715 
6716 int
6717 sys_mknod(void)
6718 {
6719   struct inode *ip;
6720   char *path;
6721   int major, minor;
6722 
6723   begin_op();
6724   if((argstr(0, &path)) < 0 ||
6725      argint(1, &major) < 0 ||
6726      argint(2, &minor) < 0 ||
6727      (ip = create(path, T_DEV, major, minor)) == 0){
6728     end_op();
6729     return -1;
6730   }
6731   iunlockput(ip);
6732   end_op();
6733   return 0;
6734 }
6735 
6736 
6737 
6738 
6739 
6740 
6741 
6742 
6743 
6744 
6745 
6746 
6747 
6748 
6749 
6750 int
6751 sys_chdir(void)
6752 {
6753   char *path;
6754   struct inode *ip;
6755   struct proc *curproc = myproc();
6756 
6757   begin_op();
6758   if(argstr(0, &path) < 0 || (ip = namei(path)) == 0){
6759     end_op();
6760     return -1;
6761   }
6762   ilock(ip);
6763   if(ip->type != T_DIR){
6764     iunlockput(ip);
6765     end_op();
6766     return -1;
6767   }
6768   iunlock(ip);
6769   iput(curproc->cwd);
6770   end_op();
6771   curproc->cwd = ip;
6772   return 0;
6773 }
6774 
6775 int
6776 sys_exec(void)
6777 {
6778   char *path, *argv[MAXARG];
6779   int i;
6780   uint uargv, uarg;
6781 
6782   if(argstr(0, &path) < 0 || argint(1, (int*)&uargv) < 0){
6783     return -1;
6784   }
6785   memset(argv, 0, sizeof(argv));
6786   for(i=0;; i++){
6787     if(i >= NELEM(argv))
6788       return -1;
6789     if(fetchint(uargv+4*i, (int*)&uarg) < 0)
6790       return -1;
6791     if(uarg == 0){
6792       argv[i] = 0;
6793       break;
6794     }
6795     if(fetchstr(uarg, &argv[i]) < 0)
6796       return -1;
6797   }
6798   return exec(path, argv);
6799 }
6800 int
6801 sys_pipe(void)
6802 {
6803   int *fd;
6804   struct file *rf, *wf;
6805   int fd0, fd1;
6806 
6807   if(argptr(0, (void*)&fd, 2*sizeof(fd[0])) < 0)
6808     return -1;
6809   if(pipealloc(&rf, &wf) < 0)
6810     return -1;
6811   fd0 = -1;
6812   if((fd0 = fdalloc(rf)) < 0 || (fd1 = fdalloc(wf)) < 0){
6813     if(fd0 >= 0)
6814       myproc()->ofile[fd0] = 0;
6815     fileclose(rf);
6816     fileclose(wf);
6817     return -1;
6818   }
6819   fd[0] = fd0;
6820   fd[1] = fd1;
6821   return 0;
6822 }
6823 
6824 
6825 
6826 
6827 
6828 
6829 
6830 
6831 
6832 
6833 
6834 
6835 
6836 
6837 
6838 
6839 
6840 
6841 
6842 
6843 
6844 
6845 
6846 
6847 
6848 
6849 
6850 #include "types.h"
6851 #include "param.h"
6852 #include "memlayout.h"
6853 #include "mmu.h"
6854 #include "proc.h"
6855 #include "defs.h"
6856 #include "x86.h"
6857 #include "elf.h"
6858 
6859 int
6860 exec(char *path, char **argv)
6861 {
6862   char *s, *last;
6863   int i, off;
6864   uint argc, sz, sp, ustack[3+MAXARG+1];
6865   struct elfhdr elf;
6866   struct inode *ip;
6867   struct proghdr ph;
6868   pde_t *pgdir, *oldpgdir;
6869   struct proc *curproc = myproc();
6870 
6871   begin_op();
6872 
6873   if((ip = namei(path)) == 0){
6874     end_op();
6875     cprintf("exec: fail\n");
6876     return -1;
6877   }
6878   ilock(ip);
6879   pgdir = 0;
6880 
6881   
6882   if(readi(ip, (char*)&elf, 0, sizeof(elf)) != sizeof(elf))
6883     goto bad;
6884   if(elf.magic != ELF_MAGIC)
6885     goto bad;
6886 
6887   if((pgdir = setupkvm()) == 0)
6888     goto bad;
6889 
6890   
6891   sz = 0;
6892   for(i=0, off=elf.phoff; i<elf.phnum; i++, off+=sizeof(ph)){
6893     if(readi(ip, (char*)&ph, off, sizeof(ph)) != sizeof(ph))
6894       goto bad;
6895     if(ph.type != ELF_PROG_LOAD)
6896       continue;
6897     if(ph.memsz < ph.filesz)
6898       goto bad;
6899     if(ph.vaddr + ph.memsz < ph.vaddr)
6900       goto bad;
6901     if((sz = allocuvm(pgdir, sz, ph.vaddr + ph.memsz)) == 0)
6902       goto bad;
6903     if(ph.vaddr % PGSIZE != 0)
6904       goto bad;
6905     if(loaduvm(pgdir, (char*)ph.vaddr, ip, ph.off, ph.filesz) < 0)
6906       goto bad;
6907   }
6908   iunlockput(ip);
6909   end_op();
6910   ip = 0;
6911 
6912   
6913   
6914   sz = PGROUNDUP(sz);
6915   if((sz = allocuvm(pgdir, sz, sz + 2*PGSIZE)) == 0)
6916     goto bad;
6917   clearpteu(pgdir, (char*)(sz - 2*PGSIZE));
6918   sp = sz;
6919 
6920   
6921   for(argc = 0; argv[argc]; argc++) {
6922     if(argc >= MAXARG)
6923       goto bad;
6924     sp = (sp - (strlen(argv[argc]) + 1)) & ~3;
6925     if(copyout(pgdir, sp, argv[argc], strlen(argv[argc]) + 1) < 0)
6926       goto bad;
6927     ustack[3+argc] = sp;
6928   }
6929   ustack[3+argc] = 0;
6930 
6931   ustack[0] = 0xffffffff;  
6932   ustack[1] = argc;
6933   ustack[2] = sp - (argc+1)*4;  
6934 
6935   sp -= (3+argc+1) * 4;
6936   if(copyout(pgdir, sp, ustack, (3+argc+1)*4) < 0)
6937     goto bad;
6938 
6939   
6940   for(last=s=path; *s; s++)
6941     if(*s == '/')
6942       last = s+1;
6943   safestrcpy(curproc->name, last, sizeof(curproc->name));
6944 
6945   
6946   oldpgdir = curproc->pgdir;
6947   curproc->pgdir = pgdir;
6948   curproc->sz = sz;
6949   curproc->tf->eip = elf.entry;  
6950   curproc->tf->esp = sp;
6951   switchuvm(curproc);
6952   freevm(oldpgdir);
6953   return 0;
6954 
6955  bad:
6956   if(pgdir)
6957     freevm(pgdir);
6958   if(ip){
6959     iunlockput(ip);
6960     end_op();
6961   }
6962   return -1;
6963 }
6964 
6965 
6966 
6967 
6968 
6969 
6970 
6971 
6972 
6973 
6974 
6975 
6976 
6977 
6978 
6979 
6980 
6981 
6982 
6983 
6984 
6985 
6986 
6987 
6988 
6989 
6990 
6991 
6992 
6993 
6994 
6995 
6996 
6997 
6998 
6999 
7000 #include "types.h"
7001 #include "defs.h"
7002 #include "param.h"
7003 #include "mmu.h"
7004 #include "proc.h"
7005 #include "fs.h"
7006 #include "spinlock.h"
7007 #include "sleeplock.h"
7008 #include "file.h"
7009 
7010 #define PIPESIZE 512
7011 
7012 struct pipe {
7013   struct spinlock lock;
7014   char data[PIPESIZE];
7015   uint nread;     
7016   uint nwrite;    
7017   int readopen;   
7018   int writeopen;  
7019 };
7020 
7021 int
7022 pipealloc(struct file **f0, struct file **f1)
7023 {
7024   struct pipe *p;
7025 
7026   p = 0;
7027   *f0 = *f1 = 0;
7028   if((*f0 = filealloc()) == 0 || (*f1 = filealloc()) == 0)
7029     goto bad;
7030   if((p = (struct pipe*)kalloc()) == 0)
7031     goto bad;
7032   p->readopen = 1;
7033   p->writeopen = 1;
7034   p->nwrite = 0;
7035   p->nread = 0;
7036   initlock(&p->lock, "pipe");
7037   (*f0)->type = FD_PIPE;
7038   (*f0)->readable = 1;
7039   (*f0)->writable = 0;
7040   (*f0)->pipe = p;
7041   (*f1)->type = FD_PIPE;
7042   (*f1)->readable = 0;
7043   (*f1)->writable = 1;
7044   (*f1)->pipe = p;
7045   return 0;
7046 
7047 
7048 
7049 
7050  bad:
7051   if(p)
7052     kfree((char*)p);
7053   if(*f0)
7054     fileclose(*f0);
7055   if(*f1)
7056     fileclose(*f1);
7057   return -1;
7058 }
7059 
7060 void
7061 pipeclose(struct pipe *p, int writable)
7062 {
7063   acquire(&p->lock);
7064   if(writable){
7065     p->writeopen = 0;
7066     wakeup(&p->nread);
7067   } else {
7068     p->readopen = 0;
7069     wakeup(&p->nwrite);
7070   }
7071   if(p->readopen == 0 && p->writeopen == 0){
7072     release(&p->lock);
7073     kfree((char*)p);
7074   } else
7075     release(&p->lock);
7076 }
7077 
7078 
7079 int
7080 pipewrite(struct pipe *p, char *addr, int n)
7081 {
7082   int i;
7083 
7084   acquire(&p->lock);
7085   for(i = 0; i < n; i++){
7086     while(p->nwrite == p->nread + PIPESIZE){  
7087       if(p->readopen == 0 || myproc()->killed){
7088         release(&p->lock);
7089         return -1;
7090       }
7091       wakeup(&p->nread);
7092       sleep(&p->nwrite, &p->lock);  
7093     }
7094     p->data[p->nwrite++ % PIPESIZE] = addr[i];
7095   }
7096   wakeup(&p->nread);  
7097   release(&p->lock);
7098   return n;
7099 }
7100 int
7101 piperead(struct pipe *p, char *addr, int n)
7102 {
7103   int i;
7104 
7105   acquire(&p->lock);
7106   while(p->nread == p->nwrite && p->writeopen){  
7107     if(myproc()->killed){
7108       release(&p->lock);
7109       return -1;
7110     }
7111     sleep(&p->nread, &p->lock); 
7112   }
7113   for(i = 0; i < n; i++){  
7114     if(p->nread == p->nwrite)
7115       break;
7116     addr[i] = p->data[p->nread++ % PIPESIZE];
7117   }
7118   wakeup(&p->nwrite);  
7119   release(&p->lock);
7120   return i;
7121 }
7122 
7123 
7124 
7125 
7126 
7127 
7128 
7129 
7130 
7131 
7132 
7133 
7134 
7135 
7136 
7137 
7138 
7139 
7140 
7141 
7142 
7143 
7144 
7145 
7146 
7147 
7148 
7149 
7150 #include "types.h"
7151 #include "x86.h"
7152 
7153 void*
7154 memset(void *dst, int c, uint n)
7155 {
7156   if ((int)dst%4 == 0 && n%4 == 0){
7157     c &= 0xFF;
7158     stosl(dst, (c<<24)|(c<<16)|(c<<8)|c, n/4);
7159   } else
7160     stosb(dst, c, n);
7161   return dst;
7162 }
7163 
7164 int
7165 memcmp(const void *v1, const void *v2, uint n)
7166 {
7167   const uchar *s1, *s2;
7168 
7169   s1 = v1;
7170   s2 = v2;
7171   while(n-- > 0){
7172     if(*s1 != *s2)
7173       return *s1 - *s2;
7174     s1++, s2++;
7175   }
7176 
7177   return 0;
7178 }
7179 
7180 void*
7181 memmove(void *dst, const void *src, uint n)
7182 {
7183   const char *s;
7184   char *d;
7185 
7186   s = src;
7187   d = dst;
7188   if(s < d && s + n > d){
7189     s += n;
7190     d += n;
7191     while(n-- > 0)
7192       *--d = *--s;
7193   } else
7194     while(n-- > 0)
7195       *d++ = *s++;
7196 
7197   return dst;
7198 }
7199 
7200 
7201 void*
7202 memcpy(void *dst, const void *src, uint n)
7203 {
7204   return memmove(dst, src, n);
7205 }
7206 
7207 int
7208 strncmp(const char *p, const char *q, uint n)
7209 {
7210   while(n > 0 && *p && *p == *q)
7211     n--, p++, q++;
7212   if(n == 0)
7213     return 0;
7214   return (uchar)*p - (uchar)*q;
7215 }
7216 
7217 char*
7218 strncpy(char *s, const char *t, int n)
7219 {
7220   char *os;
7221 
7222   os = s;
7223   while(n-- > 0 && (*s++ = *t++) != 0)
7224     ;
7225   while(n-- > 0)
7226     *s++ = 0;
7227   return os;
7228 }
7229 
7230 
7231 char*
7232 safestrcpy(char *s, const char *t, int n)
7233 {
7234   char *os;
7235 
7236   os = s;
7237   if(n <= 0)
7238     return os;
7239   while(--n > 0 && (*s++ = *t++) != 0)
7240     ;
7241   *s = 0;
7242   return os;
7243 }
7244 
7245 
7246 
7247 
7248 
7249 
7250 int
7251 strlen(const char *s)
7252 {
7253   int n;
7254 
7255   for(n = 0; s[n]; n++)
7256     ;
7257   return n;
7258 }
7259 
7260 
7261 
7262 
7263 
7264 
7265 
7266 
7267 
7268 
7269 
7270 
7271 
7272 
7273 
7274 
7275 
7276 
7277 
7278 
7279 
7280 
7281 
7282 
7283 
7284 
7285 
7286 
7287 
7288 
7289 
7290 
7291 
7292 
7293 
7294 
7295 
7296 
7297 
7298 
7299 
7300 
7301 
7302 struct mp {             
7303   uchar signature[4];           
7304   void *physaddr;               
7305   uchar length;                 
7306   uchar specrev;                
7307   uchar checksum;               
7308   uchar type;                   
7309   uchar imcrp;
7310   uchar reserved[3];
7311 };
7312 
7313 struct mpconf {         
7314   uchar signature[4];           
7315   ushort length;                
7316   uchar version;                
7317   uchar checksum;               
7318   uchar product[20];            
7319   uint *oemtable;               
7320   ushort oemlength;             
7321   ushort entry;                 
7322   uint *lapicaddr;              
7323   ushort xlength;               
7324   uchar xchecksum;              
7325   uchar reserved;
7326 };
7327 
7328 struct mpproc {         
7329   uchar type;                   
7330   uchar apicid;                 
7331   uchar version;                
7332   uchar flags;                  
7333     #define MPBOOT 0x02           
7334   uchar signature[4];           
7335   uint feature;                 
7336   uchar reserved[8];
7337 };
7338 
7339 struct mpioapic {       
7340   uchar type;                   
7341   uchar apicno;                 
7342   uchar version;                
7343   uchar flags;                  
7344   uint *addr;                  
7345 };
7346 
7347 
7348 
7349 
7350 
7351 #define MPPROC    0x00  
7352 #define MPBUS     0x01  
7353 #define MPIOAPIC  0x02  
7354 #define MPIOINTR  0x03  
7355 #define MPLINTR   0x04  
7356 
7357 
7358 
7359 
7360 
7361 
7362 
7363 
7364 
7365 
7366 
7367 
7368 
7369 
7370 
7371 
7372 
7373 
7374 
7375 
7376 
7377 
7378 
7379 
7380 
7381 
7382 
7383 
7384 
7385 
7386 
7387 
7388 
7389 
7390 
7391 
7392 
7393 
7394 
7395 
7396 
7397 
7398 
7399 
7400 
7401 
7402 
7403 
7404 
7405 
7406 
7407 
7408 
7409 
7410 
7411 
7412 
7413 
7414 
7415 
7416 
7417 
7418 
7419 
7420 
7421 
7422 
7423 
7424 
7425 
7426 
7427 
7428 
7429 
7430 
7431 
7432 
7433 
7434 
7435 
7436 
7437 
7438 
7439 
7440 
7441 
7442 
7443 
7444 
7445 
7446 
7447 
7448 
7449 
7450 
7451 
7452 
7453 
7454 #include "types.h"
7455 #include "defs.h"
7456 #include "param.h"
7457 #include "memlayout.h"
7458 #include "mp.h"
7459 #include "x86.h"
7460 #include "mmu.h"
7461 #include "proc.h"
7462 
7463 struct cpu cpus[NCPU];
7464 int ncpu;
7465 uchar ioapicid;
7466 
7467 static uchar
7468 sum(uchar *addr, int len)
7469 {
7470   int i, sum;
7471 
7472   sum = 0;
7473   for(i=0; i<len; i++)
7474     sum += addr[i];
7475   return sum;
7476 }
7477 
7478 
7479 static struct mp*
7480 mpsearch1(uint a, int len)
7481 {
7482   uchar *e, *p, *addr;
7483 
7484   addr = P2V(a);
7485   e = addr+len;
7486   for(p = addr; p < e; p += sizeof(struct mp))
7487     if(memcmp(p, "_MP_", 4) == 0 && sum(p, sizeof(struct mp)) == 0)
7488       return (struct mp*)p;
7489   return 0;
7490 }
7491 
7492 
7493 
7494 
7495 
7496 
7497 
7498 
7499 
7500 
7501 
7502 
7503 
7504 
7505 static struct mp*
7506 mpsearch(void)
7507 {
7508   uchar *bda;
7509   uint p;
7510   struct mp *mp;
7511 
7512   bda = (uchar *) P2V(0x400);
7513   if((p = ((bda[0x0F]<<8)| bda[0x0E]) << 4)){
7514     if((mp = mpsearch1(p, 1024)))
7515       return mp;
7516   } else {
7517     p = ((bda[0x14]<<8)|bda[0x13])*1024;
7518     if((mp = mpsearch1(p-1024, 1024)))
7519       return mp;
7520   }
7521   return mpsearch1(0xF0000, 0x10000);
7522 }
7523 
7524 
7525 
7526 
7527 
7528 
7529 static struct mpconf*
7530 mpconfig(struct mp **pmp)
7531 {
7532   struct mpconf *conf;
7533   struct mp *mp;
7534 
7535   if((mp = mpsearch()) == 0 || mp->physaddr == 0)
7536     return 0;
7537   conf = (struct mpconf*) P2V((uint) mp->physaddr);
7538   if(memcmp(conf, "PCMP", 4) != 0)
7539     return 0;
7540   if(conf->version != 1 && conf->version != 4)
7541     return 0;
7542   if(sum((uchar*)conf, conf->length) != 0)
7543     return 0;
7544   *pmp = mp;
7545   return conf;
7546 }
7547 
7548 
7549 
7550 void
7551 mpinit(void)
7552 {
7553   uchar *p, *e;
7554   int ismp;
7555   struct mp *mp;
7556   struct mpconf *conf;
7557   struct mpproc *proc;
7558   struct mpioapic *ioapic;
7559 
7560   if((conf = mpconfig(&mp)) == 0)
7561     panic("Expect to run on an SMP");
7562   ismp = 1;
7563   lapic = (uint*)conf->lapicaddr;
7564   for(p=(uchar*)(conf+1), e=(uchar*)conf+conf->length; p<e; ){
7565     switch(*p){
7566     case MPPROC:
7567       proc = (struct mpproc*)p;
7568       if(ncpu < NCPU) {
7569         cpus[ncpu].apicid = proc->apicid;  
7570         ncpu++;
7571       }
7572       p += sizeof(struct mpproc);
7573       continue;
7574     case MPIOAPIC:
7575       ioapic = (struct mpioapic*)p;
7576       ioapicid = ioapic->apicno;
7577       p += sizeof(struct mpioapic);
7578       continue;
7579     case MPBUS:
7580     case MPIOINTR:
7581     case MPLINTR:
7582       p += 8;
7583       continue;
7584     default:
7585       ismp = 0;
7586       break;
7587     }
7588   }
7589   if(!ismp)
7590     panic("Didn't find a suitable machine");
7591 
7592   if(mp->imcrp){
7593     
7594     
7595     outb(0x22, 0x70);   
7596     outb(0x23, inb(0x23) | 1);  
7597   }
7598 }
7599 
7600 
7601 
7602 
7603 #include "param.h"
7604 #include "types.h"
7605 #include "defs.h"
7606 #include "date.h"
7607 #include "memlayout.h"
7608 #include "traps.h"
7609 #include "mmu.h"
7610 #include "x86.h"
7611 
7612 
7613 #define ID      (0x0020/4)   
7614 #define VER     (0x0030/4)   
7615 #define TPR     (0x0080/4)   
7616 #define EOI     (0x00B0/4)   
7617 #define SVR     (0x00F0/4)   
7618   #define ENABLE     0x00000100   
7619 #define ESR     (0x0280/4)   
7620 #define ICRLO   (0x0300/4)   
7621   #define INIT       0x00000500   
7622   #define STARTUP    0x00000600   
7623   #define DELIVS     0x00001000   
7624   #define ASSERT     0x00004000   
7625   #define DEASSERT   0x00000000
7626   #define LEVEL      0x00008000   
7627   #define BCAST      0x00080000   
7628   #define BUSY       0x00001000
7629   #define FIXED      0x00000000
7630 #define ICRHI   (0x0310/4)   
7631 #define TIMER   (0x0320/4)   
7632   #define X1         0x0000000B   
7633   #define PERIODIC   0x00020000   
7634 #define PCINT   (0x0340/4)   
7635 #define LINT0   (0x0350/4)   
7636 #define LINT1   (0x0360/4)   
7637 #define ERROR   (0x0370/4)   
7638   #define MASKED     0x00010000   
7639 #define TICR    (0x0380/4)   
7640 #define TCCR    (0x0390/4)   
7641 #define TDCR    (0x03E0/4)   
7642 
7643 volatile uint *lapic;  
7644 
7645 
7646 
7647 
7648 
7649 
7650 static void
7651 lapicw(int index, int value)
7652 {
7653   lapic[index] = value;
7654   lapic[ID];  
7655 }
7656 
7657 void
7658 lapicinit(void)
7659 {
7660   if(!lapic)
7661     return;
7662 
7663   
7664   lapicw(SVR, ENABLE | (T_IRQ0 + IRQ_SPURIOUS));
7665 
7666   
7667   
7668   
7669   
7670   lapicw(TDCR, X1);
7671   lapicw(TIMER, PERIODIC | (T_IRQ0 + IRQ_TIMER));
7672   lapicw(TICR, 10000000);
7673 
7674   
7675   lapicw(LINT0, MASKED);
7676   lapicw(LINT1, MASKED);
7677 
7678   
7679   
7680   if(((lapic[VER]>>16) & 0xFF) >= 4)
7681     lapicw(PCINT, MASKED);
7682 
7683   
7684   lapicw(ERROR, T_IRQ0 + IRQ_ERROR);
7685 
7686   
7687   lapicw(ESR, 0);
7688   lapicw(ESR, 0);
7689 
7690   
7691   lapicw(EOI, 0);
7692 
7693   
7694   lapicw(ICRHI, 0);
7695   lapicw(ICRLO, BCAST | INIT | LEVEL);
7696   while(lapic[ICRLO] & DELIVS)
7697     ;
7698 
7699 
7700   
7701   lapicw(TPR, 0);
7702 }
7703 
7704 int
7705 lapicid(void)
7706 {
7707   if (!lapic)
7708     return 0;
7709   return lapic[ID] >> 24;
7710 }
7711 
7712 
7713 void
7714 lapiceoi(void)
7715 {
7716   if(lapic)
7717     lapicw(EOI, 0);
7718 }
7719 
7720 
7721 
7722 void
7723 microdelay(int us)
7724 {
7725 }
7726 
7727 #define CMOS_PORT    0x70
7728 #define CMOS_RETURN  0x71
7729 
7730 
7731 
7732 void
7733 lapicstartap(uchar apicid, uint addr)
7734 {
7735   int i;
7736   ushort *wrv;
7737 
7738   
7739   
7740   
7741   outb(CMOS_PORT, 0xF);  
7742   outb(CMOS_PORT+1, 0x0A);
7743   wrv = (ushort*)P2V((0x40<<4 | 0x67));  
7744   wrv[0] = 0;
7745   wrv[1] = addr >> 4;
7746 
7747 
7748 
7749 
7750   
7751   
7752   lapicw(ICRHI, apicid<<24);
7753   lapicw(ICRLO, INIT | LEVEL | ASSERT);
7754   microdelay(200);
7755   lapicw(ICRLO, INIT | LEVEL);
7756   microdelay(100);    
7757 
7758   
7759   
7760   
7761   
7762   
7763   for(i = 0; i < 2; i++){
7764     lapicw(ICRHI, apicid<<24);
7765     lapicw(ICRLO, STARTUP | (addr>>12));
7766     microdelay(200);
7767   }
7768 }
7769 
7770 #define CMOS_STATA   0x0a
7771 #define CMOS_STATB   0x0b
7772 #define CMOS_UIP    (1 << 7)        
7773 
7774 #define SECS    0x00
7775 #define MINS    0x02
7776 #define HOURS   0x04
7777 #define DAY     0x07
7778 #define MONTH   0x08
7779 #define YEAR    0x09
7780 
7781 static uint
7782 cmos_read(uint reg)
7783 {
7784   outb(CMOS_PORT,  reg);
7785   microdelay(200);
7786 
7787   return inb(CMOS_RETURN);
7788 }
7789 
7790 static void
7791 fill_rtcdate(struct rtcdate *r)
7792 {
7793   r->second = cmos_read(SECS);
7794   r->minute = cmos_read(MINS);
7795   r->hour   = cmos_read(HOURS);
7796   r->day    = cmos_read(DAY);
7797   r->month  = cmos_read(MONTH);
7798   r->year   = cmos_read(YEAR);
7799 }
7800 
7801 void
7802 cmostime(struct rtcdate *r)
7803 {
7804   struct rtcdate t1, t2;
7805   int sb, bcd;
7806 
7807   sb = cmos_read(CMOS_STATB);
7808 
7809   bcd = (sb & (1 << 2)) == 0;
7810 
7811   
7812   for(;;) {
7813     fill_rtcdate(&t1);
7814     if(cmos_read(CMOS_STATA) & CMOS_UIP)
7815         continue;
7816     fill_rtcdate(&t2);
7817     if(memcmp(&t1, &t2, sizeof(t1)) == 0)
7818       break;
7819   }
7820 
7821   
7822   if(bcd) {
7823 #define    CONV(x)     (t1.x = ((t1.x >> 4) * 10) + (t1.x & 0xf))
7824     CONV(second);
7825     CONV(minute);
7826     CONV(hour  );
7827     CONV(day   );
7828     CONV(month );
7829     CONV(year  );
7830 #undef     CONV
7831   }
7832 
7833   *r = t1;
7834   r->year += 2000;
7835 }
7836 
7837 
7838 
7839 
7840 
7841 
7842 
7843 
7844 
7845 
7846 
7847 
7848 
7849 
7850 
7851 
7852 
7853 
7854 #include "types.h"
7855 #include "defs.h"
7856 #include "traps.h"
7857 
7858 #define IOAPIC  0xFEC00000   
7859 
7860 #define REG_ID     0x00  
7861 #define REG_VER    0x01  
7862 #define REG_TABLE  0x10  
7863 
7864 
7865 
7866 
7867 
7868 
7869 #define INT_DISABLED   0x00010000  
7870 #define INT_LEVEL      0x00008000  
7871 #define INT_ACTIVELOW  0x00002000  
7872 #define INT_LOGICAL    0x00000800  
7873 
7874 volatile struct ioapic *ioapic;
7875 
7876 
7877 struct ioapic {
7878   uint reg;
7879   uint pad[3];
7880   uint data;
7881 };
7882 
7883 static uint
7884 ioapicread(int reg)
7885 {
7886   ioapic->reg = reg;
7887   return ioapic->data;
7888 }
7889 
7890 static void
7891 ioapicwrite(int reg, uint data)
7892 {
7893   ioapic->reg = reg;
7894   ioapic->data = data;
7895 }
7896 
7897 
7898 
7899 
7900 void
7901 ioapicinit(void)
7902 {
7903   int i, id, maxintr;
7904 
7905   ioapic = (volatile struct ioapic*)IOAPIC;
7906   maxintr = (ioapicread(REG_VER) >> 16) & 0xFF;
7907   id = ioapicread(REG_ID) >> 24;
7908   if(id != ioapicid)
7909     cprintf("ioapicinit: id isn't equal to ioapicid; not a MP\n");
7910 
7911   
7912   
7913   for(i = 0; i <= maxintr; i++){
7914     ioapicwrite(REG_TABLE+2*i, INT_DISABLED | (T_IRQ0 + i));
7915     ioapicwrite(REG_TABLE+2*i+1, 0);
7916   }
7917 }
7918 
7919 void
7920 ioapicenable(int irq, int cpunum)
7921 {
7922   
7923   
7924   
7925   ioapicwrite(REG_TABLE+2*irq, T_IRQ0 + irq);
7926   ioapicwrite(REG_TABLE+2*irq+1, cpunum << 24);
7927 }
7928 
7929 
7930 
7931 
7932 
7933 
7934 
7935 
7936 
7937 
7938 
7939 
7940 
7941 
7942 
7943 
7944 
7945 
7946 
7947 
7948 
7949 
7950 
7951 
7952 #define KBSTATP         0x64    
7953 #define KBS_DIB         0x01    
7954 #define KBDATAP         0x60    
7955 
7956 #define NO              0
7957 
7958 #define SHIFT           (1<<0)
7959 #define CTL             (1<<1)
7960 #define ALT             (1<<2)
7961 
7962 #define CAPSLOCK        (1<<3)
7963 #define NUMLOCK         (1<<4)
7964 #define SCROLLLOCK      (1<<5)
7965 
7966 #define E0ESC           (1<<6)
7967 
7968 
7969 #define KEY_HOME        0xE0
7970 #define KEY_END         0xE1
7971 #define KEY_UP          0xE2
7972 #define KEY_DN          0xE3
7973 #define KEY_LF          0xE4
7974 #define KEY_RT          0xE5
7975 #define KEY_PGUP        0xE6
7976 #define KEY_PGDN        0xE7
7977 #define KEY_INS         0xE8
7978 #define KEY_DEL         0xE9
7979 
7980 
7981 #define C(x) (x - '@')
7982 
7983 static uchar shiftcode[256] =
7984 {
7985   [0x1D] CTL,
7986   [0x2A] SHIFT,
7987   [0x36] SHIFT,
7988   [0x38] ALT,
7989   [0x9D] CTL,
7990   [0xB8] ALT
7991 };
7992 
7993 static uchar togglecode[256] =
7994 {
7995   [0x3A] CAPSLOCK,
7996   [0x45] NUMLOCK,
7997   [0x46] SCROLLLOCK
7998 };
7999 
8000 static uchar normalmap[256] =
8001 {
8002   NO,   0x1B, '1',  '2',  '3',  '4',  '5',  '6',  
8003   '7',  '8',  '9',  '0',  '-',  '=',  '\b', '\t',
8004   'q',  'w',  'e',  'r',  't',  'y',  'u',  'i',  
8005   'o',  'p',  '[',  ']',  '\n', NO,   'a',  's',
8006   'd',  'f',  'g',  'h',  'j',  'k',  'l',  ';',  
8007   '\'', '`',  NO,   '\\', 'z',  'x',  'c',  'v',
8008   'b',  'n',  'm',  ',',  '.',  '/',  NO,   '*',  
8009   NO,   ' ',  NO,   NO,   NO,   NO,   NO,   NO,
8010   NO,   NO,   NO,   NO,   NO,   NO,   NO,   '7',  
8011   '8',  '9',  '-',  '4',  '5',  '6',  '+',  '1',
8012   '2',  '3',  '0',  '.',  NO,   NO,   NO,   NO,   
8013   [0x9C] '\n',      
8014   [0xB5] '/',       
8015   [0xC8] KEY_UP,    [0xD0] KEY_DN,
8016   [0xC9] KEY_PGUP,  [0xD1] KEY_PGDN,
8017   [0xCB] KEY_LF,    [0xCD] KEY_RT,
8018   [0x97] KEY_HOME,  [0xCF] KEY_END,
8019   [0xD2] KEY_INS,   [0xD3] KEY_DEL
8020 };
8021 
8022 static uchar shiftmap[256] =
8023 {
8024   NO,   033,  '!',  '@',  '#',  '$',  '%',  '^',  
8025   '&',  '*',  '(',  ')',  '_',  '+',  '\b', '\t',
8026   'Q',  'W',  'E',  'R',  'T',  'Y',  'U',  'I',  
8027   'O',  'P',  '{',  '}',  '\n', NO,   'A',  'S',
8028   'D',  'F',  'G',  'H',  'J',  'K',  'L',  ':',  
8029   '"',  '~',  NO,   '|',  'Z',  'X',  'C',  'V',
8030   'B',  'N',  'M',  '<',  '>',  '?',  NO,   '*',  
8031   NO,   ' ',  NO,   NO,   NO,   NO,   NO,   NO,
8032   NO,   NO,   NO,   NO,   NO,   NO,   NO,   '7',  
8033   '8',  '9',  '-',  '4',  '5',  '6',  '+',  '1',
8034   '2',  '3',  '0',  '.',  NO,   NO,   NO,   NO,   
8035   [0x9C] '\n',      
8036   [0xB5] '/',       
8037   [0xC8] KEY_UP,    [0xD0] KEY_DN,
8038   [0xC9] KEY_PGUP,  [0xD1] KEY_PGDN,
8039   [0xCB] KEY_LF,    [0xCD] KEY_RT,
8040   [0x97] KEY_HOME,  [0xCF] KEY_END,
8041   [0xD2] KEY_INS,   [0xD3] KEY_DEL
8042 };
8043 
8044 
8045 
8046 
8047 
8048 
8049 
8050 static uchar ctlmap[256] =
8051 {
8052   NO,      NO,      NO,      NO,      NO,      NO,      NO,      NO,
8053   NO,      NO,      NO,      NO,      NO,      NO,      NO,      NO,
8054   C('Q'),  C('W'),  C('E'),  C('R'),  C('T'),  C('Y'),  C('U'),  C('I'),
8055   C('O'),  C('P'),  NO,      NO,      '\r',    NO,      C('A'),  C('S'),
8056   C('D'),  C('F'),  C('G'),  C('H'),  C('J'),  C('K'),  C('L'),  NO,
8057   NO,      NO,      NO,      C('\\'), C('Z'),  C('X'),  C('C'),  C('V'),
8058   C('B'),  C('N'),  C('M'),  NO,      NO,      C('/'),  NO,      NO,
8059   [0x9C] '\r',      
8060   [0xB5] C('/'),    
8061   [0xC8] KEY_UP,    [0xD0] KEY_DN,
8062   [0xC9] KEY_PGUP,  [0xD1] KEY_PGDN,
8063   [0xCB] KEY_LF,    [0xCD] KEY_RT,
8064   [0x97] KEY_HOME,  [0xCF] KEY_END,
8065   [0xD2] KEY_INS,   [0xD3] KEY_DEL
8066 };
8067 
8068 
8069 
8070 
8071 
8072 
8073 
8074 
8075 
8076 
8077 
8078 
8079 
8080 
8081 
8082 
8083 
8084 
8085 
8086 
8087 
8088 
8089 
8090 
8091 
8092 
8093 
8094 
8095 
8096 
8097 
8098 
8099 
8100 #include "types.h"
8101 #include "x86.h"
8102 #include "defs.h"
8103 #include "kbd.h"
8104 
8105 int
8106 kbdgetc(void)
8107 {
8108   static uint shift;
8109   static uchar *charcode[4] = {
8110     normalmap, shiftmap, ctlmap, ctlmap
8111   };
8112   uint st, data, c;
8113 
8114   st = inb(KBSTATP);
8115   if((st & KBS_DIB) == 0)
8116     return -1;
8117   data = inb(KBDATAP);
8118 
8119   if(data == 0xE0){
8120     shift |= E0ESC;
8121     return 0;
8122   } else if(data & 0x80){
8123     
8124     data = (shift & E0ESC ? data : data & 0x7F);
8125     shift &= ~(shiftcode[data] | E0ESC);
8126     return 0;
8127   } else if(shift & E0ESC){
8128     
8129     data |= 0x80;
8130     shift &= ~E0ESC;
8131   }
8132 
8133   shift |= shiftcode[data];
8134   shift ^= togglecode[data];
8135   c = charcode[shift & (CTL | SHIFT)][data];
8136   if(shift & CAPSLOCK){
8137     if('a' <= c && c <= 'z')
8138       c += 'A' - 'a';
8139     else if('A' <= c && c <= 'Z')
8140       c += 'a' - 'A';
8141   }
8142   return c;
8143 }
8144 
8145 void
8146 kbdintr(void)
8147 {
8148   consoleintr(kbdgetc);
8149 }
8150 
8151 
8152 
8153 
8154 #include "types.h"
8155 #include "defs.h"
8156 #include "param.h"
8157 #include "traps.h"
8158 #include "spinlock.h"
8159 #include "sleeplock.h"
8160 #include "fs.h"
8161 #include "file.h"
8162 #include "memlayout.h"
8163 #include "mmu.h"
8164 #include "proc.h"
8165 #include "x86.h"
8166 
8167 static void consputc(int);
8168 
8169 static int panicked = 0;
8170 
8171 static struct {
8172   struct spinlock lock;
8173   int locking;
8174 } cons;
8175 
8176 static void
8177 printint(int xx, int base, int sign)
8178 {
8179   static char digits[] = "0123456789abcdef";
8180   char buf[16];
8181   int i;
8182   uint x;
8183 
8184   if(sign && (sign = xx < 0))
8185     x = -xx;
8186   else
8187     x = xx;
8188 
8189   i = 0;
8190   do{
8191     buf[i++] = digits[x % base];
8192   }while((x /= base) != 0);
8193 
8194   if(sign)
8195     buf[i++] = '-';
8196 
8197   while(--i >= 0)
8198     consputc(buf[i]);
8199 }
8200 
8201 
8202 
8203 
8204 
8205 
8206 
8207 
8208 
8209 
8210 
8211 
8212 
8213 
8214 
8215 
8216 
8217 
8218 
8219 
8220 
8221 
8222 
8223 
8224 
8225 
8226 
8227 
8228 
8229 
8230 
8231 
8232 
8233 
8234 
8235 
8236 
8237 
8238 
8239 
8240 
8241 
8242 
8243 
8244 
8245 
8246 
8247 
8248 
8249 
8250 
8251 void
8252 cprintf(char *fmt, ...)
8253 {
8254   int i, c, locking;
8255   uint *argp;
8256   char *s;
8257 
8258   locking = cons.locking;
8259   if(locking)
8260     acquire(&cons.lock);
8261 
8262   if (fmt == 0)
8263     panic("null fmt");
8264 
8265   argp = (uint*)(void*)(&fmt + 1);
8266   for(i = 0; (c = fmt[i] & 0xff) != 0; i++){
8267     if(c != '%'){
8268       consputc(c);
8269       continue;
8270     }
8271     c = fmt[++i] & 0xff;
8272     if(c == 0)
8273       break;
8274     switch(c){
8275     case 'd':
8276       printint(*argp++, 10, 1);
8277       break;
8278     case 'x':
8279     case 'p':
8280       printint(*argp++, 16, 0);
8281       break;
8282     case 's':
8283       if((s = (char*)*argp++) == 0)
8284         s = "(null)";
8285       for(; *s; s++)
8286         consputc(*s);
8287       break;
8288     case '%':
8289       consputc('%');
8290       break;
8291     default:
8292       
8293       consputc('%');
8294       consputc(c);
8295       break;
8296     }
8297   }
8298 
8299 
8300   if(locking)
8301     release(&cons.lock);
8302 }
8303 
8304 void
8305 panic(char *s)
8306 {
8307   int i;
8308   uint pcs[10];
8309 
8310   cli();
8311   cons.locking = 0;
8312   
8313   cprintf("lapicid %d: panic: ", lapicid());
8314   cprintf(s);
8315   cprintf("\n");
8316   getcallerpcs(&s, pcs);
8317   for(i=0; i<10; i++)
8318     cprintf(" %p", pcs[i]);
8319   panicked = 1; 
8320   for(;;)
8321     ;
8322 }
8323 
8324 
8325 
8326 
8327 
8328 
8329 
8330 
8331 
8332 
8333 
8334 
8335 
8336 
8337 
8338 
8339 
8340 
8341 
8342 
8343 
8344 
8345 
8346 
8347 
8348 
8349 
8350 #define BACKSPACE 0x100
8351 #define CRTPORT 0x3d4
8352 static ushort *crt = (ushort*)P2V(0xb8000);  
8353 
8354 static void
8355 cgaputc(int c)
8356 {
8357   int pos;
8358 
8359   
8360   outb(CRTPORT, 14);
8361   pos = inb(CRTPORT+1) << 8;
8362   outb(CRTPORT, 15);
8363   pos |= inb(CRTPORT+1);
8364 
8365   if(c == '\n')
8366     pos += 80 - pos%80;
8367   else if(c == BACKSPACE){
8368     if(pos > 0) --pos;
8369   } else
8370     crt[pos++] = (c&0xff) | 0x0700;  
8371 
8372   if(pos < 0 || pos > 25*80)
8373     panic("pos under/overflow");
8374 
8375   if((pos/80) >= 24){  
8376     memmove(crt, crt+80, sizeof(crt[0])*23*80);
8377     pos -= 80;
8378     memset(crt+pos, 0, sizeof(crt[0])*(24*80 - pos));
8379   }
8380 
8381   outb(CRTPORT, 14);
8382   outb(CRTPORT+1, pos>>8);
8383   outb(CRTPORT, 15);
8384   outb(CRTPORT+1, pos);
8385   crt[pos] = ' ' | 0x0700;
8386 }
8387 
8388 
8389 
8390 
8391 
8392 
8393 
8394 
8395 
8396 
8397 
8398 
8399 
8400 void
8401 consputc(int c)
8402 {
8403   if(panicked){
8404     cli();
8405     for(;;)
8406       ;
8407   }
8408 
8409   if(c == BACKSPACE){
8410     uartputc('\b'); uartputc(' '); uartputc('\b');
8411   } else
8412     uartputc(c);
8413   cgaputc(c);
8414 }
8415 
8416 #define INPUT_BUF 128
8417 struct {
8418   char buf[INPUT_BUF];
8419   uint r;  
8420   uint w;  
8421   uint e;  
8422 } input;
8423 
8424 #define C(x)  ((x)-'@')  
8425 
8426 void
8427 consoleintr(int (*getc)(void))
8428 {
8429   int c, doprocdump = 0;
8430 
8431   acquire(&cons.lock);
8432   while((c = getc()) >= 0){
8433     switch(c){
8434     case C('P'):  
8435       
8436       doprocdump = 1;
8437       break;
8438     case C('U'):  
8439       while(input.e != input.w &&
8440             input.buf[(input.e-1) % INPUT_BUF] != '\n'){
8441         input.e--;
8442         consputc(BACKSPACE);
8443       }
8444       break;
8445     case C('H'): case '\x7f':  
8446       if(input.e != input.w){
8447         input.e--;
8448         consputc(BACKSPACE);
8449       }
8450       break;
8451     default:
8452       if(c != 0 && input.e-input.r < INPUT_BUF){
8453         c = (c == '\r') ? '\n' : c;
8454         input.buf[input.e++ % INPUT_BUF] = c;
8455         consputc(c);
8456         if(c == '\n' || c == C('D') || input.e == input.r+INPUT_BUF){
8457           input.w = input.e;
8458           wakeup(&input.r);
8459         }
8460       }
8461       break;
8462     }
8463   }
8464   release(&cons.lock);
8465   if(doprocdump) {
8466     procdump();  
8467   }
8468 }
8469 
8470 int
8471 consoleread(struct inode *ip, char *dst, int n)
8472 {
8473   uint target;
8474   int c;
8475 
8476   iunlock(ip);
8477   target = n;
8478   acquire(&cons.lock);
8479   while(n > 0){
8480     while(input.r == input.w){
8481       if(myproc()->killed){
8482         release(&cons.lock);
8483         ilock(ip);
8484         return -1;
8485       }
8486       sleep(&input.r, &cons.lock);
8487     }
8488     c = input.buf[input.r++ % INPUT_BUF];
8489     if(c == C('D')){  
8490       if(n < target){
8491         
8492         
8493         input.r--;
8494       }
8495       break;
8496     }
8497     *dst++ = c;
8498     --n;
8499     if(c == '\n')
8500       break;
8501   }
8502   release(&cons.lock);
8503   ilock(ip);
8504 
8505   return target - n;
8506 }
8507 
8508 int
8509 consolewrite(struct inode *ip, char *buf, int n)
8510 {
8511   int i;
8512 
8513   iunlock(ip);
8514   acquire(&cons.lock);
8515   for(i = 0; i < n; i++)
8516     consputc(buf[i] & 0xff);
8517   release(&cons.lock);
8518   ilock(ip);
8519 
8520   return n;
8521 }
8522 
8523 void
8524 consoleinit(void)
8525 {
8526   initlock(&cons.lock, "console");
8527 
8528   devsw[CONSOLE].write = consolewrite;
8529   devsw[CONSOLE].read = consoleread;
8530   cons.locking = 1;
8531 
8532   ioapicenable(IRQ_KBD, 0);
8533 }
8534 
8535 
8536 
8537 
8538 
8539 
8540 
8541 
8542 
8543 
8544 
8545 
8546 
8547 
8548 
8549 
8550 
8551 
8552 #include "types.h"
8553 #include "defs.h"
8554 #include "param.h"
8555 #include "traps.h"
8556 #include "spinlock.h"
8557 #include "sleeplock.h"
8558 #include "fs.h"
8559 #include "file.h"
8560 #include "mmu.h"
8561 #include "proc.h"
8562 #include "x86.h"
8563 
8564 #define COM1    0x3f8
8565 
8566 static int uart;    
8567 
8568 void
8569 uartinit(void)
8570 {
8571   char *p;
8572 
8573   
8574   outb(COM1+2, 0);
8575 
8576   
8577   outb(COM1+3, 0x80);    
8578   outb(COM1+0, 115200/9600);
8579   outb(COM1+1, 0);
8580   outb(COM1+3, 0x03);    
8581   outb(COM1+4, 0);
8582   outb(COM1+1, 0x01);    
8583 
8584   
8585   if(inb(COM1+5) == 0xFF)
8586     return;
8587   uart = 1;
8588 
8589   
8590   
8591   inb(COM1+2);
8592   inb(COM1+0);
8593   ioapicenable(IRQ_COM1, 0);
8594 
8595   
8596   for(p="xv6...\n"; *p; p++)
8597     uartputc(*p);
8598 }
8599 
8600 void
8601 uartputc(int c)
8602 {
8603   int i;
8604 
8605   if(!uart)
8606     return;
8607   for(i = 0; i < 128 && !(inb(COM1+5) & 0x20); i++)
8608     microdelay(10);
8609   outb(COM1+0, c);
8610 }
8611 
8612 static int
8613 uartgetc(void)
8614 {
8615   if(!uart)
8616     return -1;
8617   if(!(inb(COM1+5) & 0x01))
8618     return -1;
8619   return inb(COM1+0);
8620 }
8621 
8622 void
8623 uartintr(void)
8624 {
8625   consoleintr(uartgetc);
8626 }
8627 
8628 
8629 
8630 
8631 
8632 
8633 
8634 
8635 
8636 
8637 
8638 
8639 
8640 
8641 
8642 
8643 
8644 
8645 
8646 
8647 
8648 
8649 
8650 
8651 
8652 
8653 
8654 
8655 
8656 
8657 
8658 .globl start
8659 start:
8660   pushl $argv
8661   pushl $init
8662   pushl $0  
8663   movl $SYS_exec, %eax
8664   int $T_SYSCALL
8665 
8666 
8667 exit:
8668   movl $SYS_exit, %eax
8669   int $T_SYSCALL
8670   jmp exit
8671 
8672 
8673 init:
8674   .string "/init\0"
8675 
8676 
8677 .p2align 2
8678 argv:
8679   .long init
8680   .long 0
8681 
8682 
8683 
8684 
8685 
8686 
8687 
8688 
8689 
8690 
8691 
8692 
8693 
8694 
8695 
8696 
8697 
8698 
8699 
8700 
8701 
8702 
8703 
8704   .globl name; \
8705   name: \
8706     movl $SYS_ 
8707     int $T_SYSCALL; \
8708     ret
8709 
8710 SYSCALL(fork)
8711 SYSCALL(exit)
8712 SYSCALL(wait)
8713 SYSCALL(pipe)
8714 SYSCALL(read)
8715 SYSCALL(write)
8716 SYSCALL(close)
8717 SYSCALL(kill)
8718 SYSCALL(exec)
8719 SYSCALL(open)
8720 SYSCALL(mknod)
8721 SYSCALL(unlink)
8722 SYSCALL(fstat)
8723 SYSCALL(link)
8724 SYSCALL(mkdir)
8725 SYSCALL(chdir)
8726 SYSCALL(dup)
8727 SYSCALL(getpid)
8728 SYSCALL(sbrk)
8729 SYSCALL(sleep)
8730 SYSCALL(uptime)
8731 
8732 SYSCALL(greet)
8733 SYSCALL(numvp)
8734 SYSCALL(numpp)
8735 SYSCALL(getptsize)
8736 SYSCALL(mmap)
8737 SYSCALL(munmap)
8738 
8739 
8740 
8741 
8742 
8743 
8744 
8745 
8746 
8747 
8748 
8749 
8750 
8751 
8752 #include "types.h"
8753 #include "stat.h"
8754 #include "user.h"
8755 #include "fcntl.h"
8756 
8757 char *argv[] = { "sh", 0 };
8758 
8759 int
8760 main(void)
8761 {
8762   int pid, wpid;
8763 
8764   if(open("console", O_RDWR) < 0){
8765     mknod("console", 1, 1);
8766     open("console", O_RDWR);
8767   }
8768   dup(0);  
8769   dup(0);  
8770 
8771   for(;;){
8772     printf(1, "init: starting sh\n");
8773     pid = fork();
8774     if(pid < 0){
8775       printf(1, "init: fork failed\n");
8776       exit();
8777     }
8778     if(pid == 0){
8779       exec("sh", argv);
8780       printf(1, "init: exec sh failed\n");
8781       exit();
8782     }
8783     while((wpid=wait()) >= 0 && wpid != pid)
8784       printf(1, "zombie!\n");
8785   }
8786 }
8787 
8788 
8789 
8790 
8791 
8792 
8793 
8794 
8795 
8796 
8797 
8798 
8799 
8800 
8801 
8802 #include "types.h"
8803 #include "user.h"
8804 #include "fcntl.h"
8805 
8806 
8807 #define EXEC  1
8808 #define REDIR 2
8809 #define PIPE  3
8810 #define LIST  4
8811 #define BACK  5
8812 
8813 #define MAXARGS 10
8814 
8815 struct cmd {
8816   int type;
8817 };
8818 
8819 struct execcmd {
8820   int type;
8821   char *argv[MAXARGS];
8822   char *eargv[MAXARGS];
8823 };
8824 
8825 struct redircmd {
8826   int type;
8827   struct cmd *cmd;
8828   char *file;
8829   char *efile;
8830   int mode;
8831   int fd;
8832 };
8833 
8834 struct pipecmd {
8835   int type;
8836   struct cmd *left;
8837   struct cmd *right;
8838 };
8839 
8840 struct listcmd {
8841   int type;
8842   struct cmd *left;
8843   struct cmd *right;
8844 };
8845 
8846 struct backcmd {
8847   int type;
8848   struct cmd *cmd;
8849 };
8850 int fork1(void);  
8851 void panic(char*);
8852 struct cmd *parsecmd(char*);
8853 
8854 
8855 void
8856 runcmd(struct cmd *cmd)
8857 {
8858   int p[2];
8859   struct backcmd *bcmd;
8860   struct execcmd *ecmd;
8861   struct listcmd *lcmd;
8862   struct pipecmd *pcmd;
8863   struct redircmd *rcmd;
8864 
8865   if(cmd == 0)
8866     exit();
8867 
8868   switch(cmd->type){
8869   default:
8870     panic("runcmd");
8871 
8872   case EXEC:
8873     ecmd = (struct execcmd*)cmd;
8874     if(ecmd->argv[0] == 0)
8875       exit();
8876     exec(ecmd->argv[0], ecmd->argv);
8877     printf(2, "exec %s failed\n", ecmd->argv[0]);
8878     break;
8879 
8880   case REDIR:
8881     rcmd = (struct redircmd*)cmd;
8882     close(rcmd->fd);
8883     if(open(rcmd->file, rcmd->mode) < 0){
8884       printf(2, "open %s failed\n", rcmd->file);
8885       exit();
8886     }
8887     runcmd(rcmd->cmd);
8888     break;
8889 
8890   case LIST:
8891     lcmd = (struct listcmd*)cmd;
8892     if(fork1() == 0)
8893       runcmd(lcmd->left);
8894     wait();
8895     runcmd(lcmd->right);
8896     break;
8897 
8898 
8899 
8900   case PIPE:
8901     pcmd = (struct pipecmd*)cmd;
8902     if(pipe(p) < 0)
8903       panic("pipe");
8904     if(fork1() == 0){
8905       close(1);
8906       dup(p[1]);
8907       close(p[0]);
8908       close(p[1]);
8909       runcmd(pcmd->left);
8910     }
8911     if(fork1() == 0){
8912       close(0);
8913       dup(p[0]);
8914       close(p[0]);
8915       close(p[1]);
8916       runcmd(pcmd->right);
8917     }
8918     close(p[0]);
8919     close(p[1]);
8920     wait();
8921     wait();
8922     break;
8923 
8924   case BACK:
8925     bcmd = (struct backcmd*)cmd;
8926     if(fork1() == 0)
8927       runcmd(bcmd->cmd);
8928     break;
8929   }
8930   exit();
8931 }
8932 
8933 int
8934 getcmd(char *buf, int nbuf)
8935 {
8936   printf(2, "$ ");
8937   memset(buf, 0, nbuf);
8938   gets(buf, nbuf);
8939   if(buf[0] == 0) 
8940     return -1;
8941   return 0;
8942 }
8943 
8944 
8945 
8946 
8947 
8948 
8949 
8950 int
8951 main(void)
8952 {
8953   static char buf[100];
8954   int fd;
8955 
8956   
8957   while((fd = open("console", O_RDWR)) >= 0){
8958     if(fd >= 3){
8959       close(fd);
8960       break;
8961     }
8962   }
8963 
8964   
8965   while(getcmd(buf, sizeof(buf)) >= 0){
8966     if(buf[0] == 'c' && buf[1] == 'd' && buf[2] == ' '){
8967       
8968       buf[strlen(buf)-1] = 0;  
8969       if(chdir(buf+3) < 0)
8970         printf(2, "cannot cd %s\n", buf+3);
8971       continue;
8972     }
8973     if(fork1() == 0)
8974       runcmd(parsecmd(buf));
8975     wait();
8976   }
8977   exit();
8978 }
8979 
8980 void
8981 panic(char *s)
8982 {
8983   printf(2, "%s\n", s);
8984   exit();
8985 }
8986 
8987 int
8988 fork1(void)
8989 {
8990   int pid;
8991 
8992   pid = fork();
8993   if(pid == -1)
8994     panic("fork");
8995   return pid;
8996 }
8997 
8998 
8999 
9000 
9001 
9002 struct cmd*
9003 execcmd(void)
9004 {
9005   struct execcmd *cmd;
9006 
9007   cmd = malloc(sizeof(*cmd));
9008   memset(cmd, 0, sizeof(*cmd));
9009   cmd->type = EXEC;
9010   return (struct cmd*)cmd;
9011 }
9012 
9013 struct cmd*
9014 redircmd(struct cmd *subcmd, char *file, char *efile, int mode, int fd)
9015 {
9016   struct redircmd *cmd;
9017 
9018   cmd = malloc(sizeof(*cmd));
9019   memset(cmd, 0, sizeof(*cmd));
9020   cmd->type = REDIR;
9021   cmd->cmd = subcmd;
9022   cmd->file = file;
9023   cmd->efile = efile;
9024   cmd->mode = mode;
9025   cmd->fd = fd;
9026   return (struct cmd*)cmd;
9027 }
9028 
9029 struct cmd*
9030 pipecmd(struct cmd *left, struct cmd *right)
9031 {
9032   struct pipecmd *cmd;
9033 
9034   cmd = malloc(sizeof(*cmd));
9035   memset(cmd, 0, sizeof(*cmd));
9036   cmd->type = PIPE;
9037   cmd->left = left;
9038   cmd->right = right;
9039   return (struct cmd*)cmd;
9040 }
9041 
9042 
9043 
9044 
9045 
9046 
9047 
9048 
9049 
9050 struct cmd*
9051 listcmd(struct cmd *left, struct cmd *right)
9052 {
9053   struct listcmd *cmd;
9054 
9055   cmd = malloc(sizeof(*cmd));
9056   memset(cmd, 0, sizeof(*cmd));
9057   cmd->type = LIST;
9058   cmd->left = left;
9059   cmd->right = right;
9060   return (struct cmd*)cmd;
9061 }
9062 
9063 struct cmd*
9064 backcmd(struct cmd *subcmd)
9065 {
9066   struct backcmd *cmd;
9067 
9068   cmd = malloc(sizeof(*cmd));
9069   memset(cmd, 0, sizeof(*cmd));
9070   cmd->type = BACK;
9071   cmd->cmd = subcmd;
9072   return (struct cmd*)cmd;
9073 }
9074 
9075 
9076 
9077 
9078 
9079 
9080 
9081 
9082 
9083 
9084 
9085 
9086 
9087 
9088 
9089 
9090 
9091 
9092 
9093 
9094 
9095 
9096 
9097 
9098 
9099 
9100 
9101 
9102 char whitespace[] = " \t\r\n\v";
9103 char symbols[] = "<|>&;()";
9104 
9105 int
9106 gettoken(char **ps, char *es, char **q, char **eq)
9107 {
9108   char *s;
9109   int ret;
9110 
9111   s = *ps;
9112   while(s < es && strchr(whitespace, *s))
9113     s++;
9114   if(q)
9115     *q = s;
9116   ret = *s;
9117   switch(*s){
9118   case 0:
9119     break;
9120   case '|':
9121   case '(':
9122   case ')':
9123   case ';':
9124   case '&':
9125   case '<':
9126     s++;
9127     break;
9128   case '>':
9129     s++;
9130     if(*s == '>'){
9131       ret = '+';
9132       s++;
9133     }
9134     break;
9135   default:
9136     ret = 'a';
9137     while(s < es && !strchr(whitespace, *s) && !strchr(symbols, *s))
9138       s++;
9139     break;
9140   }
9141   if(eq)
9142     *eq = s;
9143 
9144   while(s < es && strchr(whitespace, *s))
9145     s++;
9146   *ps = s;
9147   return ret;
9148 }
9149 
9150 int
9151 peek(char **ps, char *es, char *toks)
9152 {
9153   char *s;
9154 
9155   s = *ps;
9156   while(s < es && strchr(whitespace, *s))
9157     s++;
9158   *ps = s;
9159   return *s && strchr(toks, *s);
9160 }
9161 
9162 struct cmd *parseline(char**, char*);
9163 struct cmd *parsepipe(char**, char*);
9164 struct cmd *parseexec(char**, char*);
9165 struct cmd *nulterminate(struct cmd*);
9166 
9167 struct cmd*
9168 parsecmd(char *s)
9169 {
9170   char *es;
9171   struct cmd *cmd;
9172 
9173   es = s + strlen(s);
9174   cmd = parseline(&s, es);
9175   peek(&s, es, "");
9176   if(s != es){
9177     printf(2, "leftovers: %s\n", s);
9178     panic("syntax");
9179   }
9180   nulterminate(cmd);
9181   return cmd;
9182 }
9183 
9184 struct cmd*
9185 parseline(char **ps, char *es)
9186 {
9187   struct cmd *cmd;
9188 
9189   cmd = parsepipe(ps, es);
9190   while(peek(ps, es, "&")){
9191     gettoken(ps, es, 0, 0);
9192     cmd = backcmd(cmd);
9193   }
9194   if(peek(ps, es, ";")){
9195     gettoken(ps, es, 0, 0);
9196     cmd = listcmd(cmd, parseline(ps, es));
9197   }
9198   return cmd;
9199 }
9200 struct cmd*
9201 parsepipe(char **ps, char *es)
9202 {
9203   struct cmd *cmd;
9204 
9205   cmd = parseexec(ps, es);
9206   if(peek(ps, es, "|")){
9207     gettoken(ps, es, 0, 0);
9208     cmd = pipecmd(cmd, parsepipe(ps, es));
9209   }
9210   return cmd;
9211 }
9212 
9213 struct cmd*
9214 parseredirs(struct cmd *cmd, char **ps, char *es)
9215 {
9216   int tok;
9217   char *q, *eq;
9218 
9219   while(peek(ps, es, "<>")){
9220     tok = gettoken(ps, es, 0, 0);
9221     if(gettoken(ps, es, &q, &eq) != 'a')
9222       panic("missing file for redirection");
9223     switch(tok){
9224     case '<':
9225       cmd = redircmd(cmd, q, eq, O_RDONLY, 0);
9226       break;
9227     case '>':
9228       cmd = redircmd(cmd, q, eq, O_WRONLY|O_CREATE, 1);
9229       break;
9230     case '+':  
9231       cmd = redircmd(cmd, q, eq, O_WRONLY|O_CREATE, 1);
9232       break;
9233     }
9234   }
9235   return cmd;
9236 }
9237 
9238 
9239 
9240 
9241 
9242 
9243 
9244 
9245 
9246 
9247 
9248 
9249 
9250 struct cmd*
9251 parseblock(char **ps, char *es)
9252 {
9253   struct cmd *cmd;
9254 
9255   if(!peek(ps, es, "("))
9256     panic("parseblock");
9257   gettoken(ps, es, 0, 0);
9258   cmd = parseline(ps, es);
9259   if(!peek(ps, es, ")"))
9260     panic("syntax - missing )");
9261   gettoken(ps, es, 0, 0);
9262   cmd = parseredirs(cmd, ps, es);
9263   return cmd;
9264 }
9265 
9266 struct cmd*
9267 parseexec(char **ps, char *es)
9268 {
9269   char *q, *eq;
9270   int tok, argc;
9271   struct execcmd *cmd;
9272   struct cmd *ret;
9273 
9274   if(peek(ps, es, "("))
9275     return parseblock(ps, es);
9276 
9277   ret = execcmd();
9278   cmd = (struct execcmd*)ret;
9279 
9280   argc = 0;
9281   ret = parseredirs(ret, ps, es);
9282   while(!peek(ps, es, "|)&;")){
9283     if((tok=gettoken(ps, es, &q, &eq)) == 0)
9284       break;
9285     if(tok != 'a')
9286       panic("syntax");
9287     cmd->argv[argc] = q;
9288     cmd->eargv[argc] = eq;
9289     argc++;
9290     if(argc >= MAXARGS)
9291       panic("too many args");
9292     ret = parseredirs(ret, ps, es);
9293   }
9294   cmd->argv[argc] = 0;
9295   cmd->eargv[argc] = 0;
9296   return ret;
9297 }
9298 
9299 
9300 
9301 struct cmd*
9302 nulterminate(struct cmd *cmd)
9303 {
9304   int i;
9305   struct backcmd *bcmd;
9306   struct execcmd *ecmd;
9307   struct listcmd *lcmd;
9308   struct pipecmd *pcmd;
9309   struct redircmd *rcmd;
9310 
9311   if(cmd == 0)
9312     return 0;
9313 
9314   switch(cmd->type){
9315   case EXEC:
9316     ecmd = (struct execcmd*)cmd;
9317     for(i=0; ecmd->argv[i]; i++)
9318       *ecmd->eargv[i] = 0;
9319     break;
9320 
9321   case REDIR:
9322     rcmd = (struct redircmd*)cmd;
9323     nulterminate(rcmd->cmd);
9324     *rcmd->efile = 0;
9325     break;
9326 
9327   case PIPE:
9328     pcmd = (struct pipecmd*)cmd;
9329     nulterminate(pcmd->left);
9330     nulterminate(pcmd->right);
9331     break;
9332 
9333   case LIST:
9334     lcmd = (struct listcmd*)cmd;
9335     nulterminate(lcmd->left);
9336     nulterminate(lcmd->right);
9337     break;
9338 
9339   case BACK:
9340     bcmd = (struct backcmd*)cmd;
9341     nulterminate(bcmd->cmd);
9342     break;
9343   }
9344   return cmd;
9345 }
9346 
9347 
9348 
9349 
9350 
9351 
9352 
9353 
9354 
9355 
9356 
9357 
9358 
9359 .code16                       
9360 .globl start
9361 start:
9362   cli                         
9363 
9364   
9365   xorw    %ax,%ax             
9366   movw    %ax,%ds             
9367   movw    %ax,%es             
9368   movw    %ax,%ss             
9369 
9370   
9371   
9372 seta20.1:
9373   inb     $0x64,%al               
9374   testb   $0x2,%al
9375   jnz     seta20.1
9376 
9377   movb    $0xd1,%al               
9378   outb    %al,$0x64
9379 
9380 seta20.2:
9381   inb     $0x64,%al               
9382   testb   $0x2,%al
9383   jnz     seta20.2
9384 
9385   movb    $0xdf,%al               
9386   outb    %al,$0x60
9387 
9388   
9389   
9390   
9391   lgdt    gdtdesc
9392   movl    %cr0, %eax
9393   orl     $CR0_PE, %eax
9394   movl    %eax, %cr0
9395 
9396 
9397 
9398 
9399 
9400   
9401   
9402   
9403   ljmp    $(SEG_KCODE<<3), $start32
9404 
9405 .code32  
9406 start32:
9407   
9408   movw    $(SEG_KDATA<<3), %ax    
9409   movw    %ax, %ds                
9410   movw    %ax, %es                
9411   movw    %ax, %ss                
9412   movw    $0, %ax                 
9413   movw    %ax, %fs                
9414   movw    %ax, %gs                
9415 
9416   
9417   movl    $start, %esp
9418   call    bootmain
9419 
9420   
9421   
9422   movw    $0x8a00, %ax            
9423   movw    %ax, %dx
9424   outw    %ax, %dx
9425   movw    $0x8ae0, %ax            
9426   outw    %ax, %dx
9427 spin:
9428   jmp     spin
9429 
9430 
9431 .p2align 2                                
9432 gdt:
9433   SEG_NULLASM                             
9434   SEG_ASM(STA_X|STA_R, 0x0, 0xffffffff)   
9435   SEG_ASM(STA_W, 0x0, 0xffffffff)         
9436 
9437 gdtdesc:
9438   .word   (gdtdesc - gdt - 1)             
9439   .long   gdt                             
9440 
9441 
9442 
9443 
9444 
9445 
9446 
9447 
9448 
9449 
9450 
9451 
9452 
9453 
9454 
9455 
9456 
9457 #include "types.h"
9458 #include "elf.h"
9459 #include "x86.h"
9460 #include "memlayout.h"
9461 
9462 #define SECTSIZE  512
9463 
9464 void readseg(uchar*, uint, uint);
9465 
9466 void
9467 bootmain(void)
9468 {
9469   struct elfhdr *elf;
9470   struct proghdr *ph, *eph;
9471   void (*entry)(void);
9472   uchar* pa;
9473 
9474   elf = (struct elfhdr*)0x10000;  
9475 
9476   
9477   readseg((uchar*)elf, 4096, 0);
9478 
9479   
9480   if(elf->magic != ELF_MAGIC)
9481     return;  
9482 
9483   
9484   ph = (struct proghdr*)((uchar*)elf + elf->phoff);
9485   eph = ph + elf->phnum;
9486   for(; ph < eph; ph++){
9487     pa = (uchar*)ph->paddr;
9488     readseg(pa, ph->filesz, ph->off);
9489     if(ph->memsz > ph->filesz)
9490       stosb(pa + ph->filesz, 0, ph->memsz - ph->filesz);
9491   }
9492 
9493   
9494   
9495   entry = (void(*)(void))(elf->entry);
9496   entry();
9497 }
9498 
9499 
9500 void
9501 waitdisk(void)
9502 {
9503   
9504   while((inb(0x1F7) & 0xC0) != 0x40)
9505     ;
9506 }
9507 
9508 
9509 void
9510 readsect(void *dst, uint offset)
9511 {
9512   
9513   waitdisk();
9514   outb(0x1F2, 1);   
9515   outb(0x1F3, offset);
9516   outb(0x1F4, offset >> 8);
9517   outb(0x1F5, offset >> 16);
9518   outb(0x1F6, (offset >> 24) | 0xE0);
9519   outb(0x1F7, 0x20);  
9520 
9521   
9522   waitdisk();
9523   insl(0x1F0, dst, SECTSIZE/4);
9524 }
9525 
9526 
9527 
9528 void
9529 readseg(uchar* pa, uint count, uint offset)
9530 {
9531   uchar* epa;
9532 
9533   epa = pa + count;
9534 
9535   
9536   pa -= offset % SECTSIZE;
9537 
9538   
9539   offset = (offset / SECTSIZE) + 1;
9540 
9541   
9542   
9543   
9544   for(; pa < epa; pa += SECTSIZE, offset++)
9545     readsect(pa, offset);
9546 }
9547 
9548 
9549 
9550 /* Simple linker script for the JOS kernel.
9551    See the GNU ld 'info' manual ("info ld") to learn the syntax. */
9552 
9553 OUTPUT_FORMAT("elf32-i386", "elf32-i386", "elf32-i386")
9554 OUTPUT_ARCH(i386)
9555 ENTRY(_start)
9556 
9557 SECTIONS
9558 {
9559 	/* Link the kernel at this address: "." means the current address */
9560         /* Must be equal to KERNLINK */
9561 	. = 0x80100000;
9562 
9563 	.text : AT(0x100000) {
9564 		*(.text .stub .text.* .gnu.linkonce.t.*)
9565 	}
9566 
9567 	PROVIDE(etext = .);	/* Define the 'etext' symbol to this value */
9568 
9569 	.rodata : {
9570 		*(.rodata .rodata.* .gnu.linkonce.r.*)
9571 	}
9572 
9573 	/* Include debugging information in kernel memory */
9574 	.stab : {
9575 		PROVIDE(__STAB_BEGIN__ = .);
9576 		*(.stab);
9577 		PROVIDE(__STAB_END__ = .);
9578 	}
9579 
9580 	.stabstr : {
9581 		PROVIDE(__STABSTR_BEGIN__ = .);
9582 		*(.stabstr);
9583 		PROVIDE(__STABSTR_END__ = .);
9584 	}
9585 
9586 	/* Adjust the address for the data segment to the next page */
9587 	. = ALIGN(0x1000);
9588 
9589 	/* Conventionally, Unix linkers provide pseudo-symbols
9590 	 * etext, edata, and end, at the end of the text, data, and bss.
9591 	 * For the kernel mapping, we need the address at the beginning
9592 	 * of the data section, but that's not one of the conventional
9593 	 * symbols, because the convention started before there was a
9594 	 * read-only rodata section between text and data. */
9595 	PROVIDE(data = .);
9596 
9597 
9598 
9599 
9600 	/* The data segment */
9601 	.data : {
9602 		*(.data)
9603 	}
9604 
9605 	PROVIDE(edata = .);
9606 
9607 	.bss : {
9608 		*(.bss)
9609 	}
9610 
9611 	PROVIDE(end = .);
9612 
9613 	/DISCARD/ : {
9614 		*(.eh_frame .note.GNU-stack)
9615 	}
9616 }
9617 
9618 
9619 
9620 
9621 
9622 
9623 
9624 
9625 
9626 
9627 
9628 
9629 
9630 
9631 
9632 
9633 
9634 
9635 
9636 
9637 
9638 
9639 
9640 
9641 
9642 
9643 
9644 
9645 
9646 
9647 
9648 
9649 
