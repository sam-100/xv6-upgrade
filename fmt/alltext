0100 typedef unsigned int   uint;
0101 typedef unsigned short ushort;
0102 typedef unsigned char  uchar;
0103 typedef uint pde_t;
0104 
0105 
0106 
0107 
0108 
0109 
0110 
0111 
0112 
0113 
0114 
0115 
0116 
0117 
0118 
0119 
0120 
0121 
0122 
0123 
0124 
0125 
0126 
0127 
0128 
0129 
0130 
0131 
0132 
0133 
0134 
0135 
0136 
0137 
0138 
0139 
0140 
0141 
0142 
0143 
0144 
0145 
0146 
0147 
0148 
0149 
0150 #define NPROC        64  
0151 #define KSTACKSIZE 4096  
0152 #define NCPU          8  
0153 #define NOFILE       16  
0154 #define NFILE       100  
0155 #define NINODE       50  
0156 #define NDEV         10  
0157 #define ROOTDEV       1  
0158 #define MAXARG       32  
0159 #define MAXOPBLOCKS  10  
0160 #define LOGSIZE      (MAXOPBLOCKS*3)  
0161 #define NBUF         (MAXOPBLOCKS*3)  
0162 #define FSSIZE       1000  
0163 
0164 
0165 
0166 
0167 
0168 
0169 
0170 
0171 
0172 
0173 
0174 
0175 
0176 
0177 
0178 
0179 
0180 
0181 
0182 
0183 
0184 
0185 
0186 
0187 
0188 
0189 
0190 
0191 
0192 
0193 
0194 
0195 
0196 
0197 
0198 
0199 
0200 
0201 
0202 #define EXTMEM  0x100000            
0203 #define PHYSTOP 0xE000000           
0204 #define DEVSPACE 0xFE000000         
0205 
0206 
0207 #define KERNBASE 0x80000000         
0208 #define KERNLINK (KERNBASE+EXTMEM)  
0209 
0210 #define V2P(a) (((uint) (a)) - KERNBASE)
0211 #define P2V(a) ((void *)(((char *) (a)) + KERNBASE))
0212 
0213 #define V2P_WO(x) ((x) - KERNBASE)    
0214 #define P2V_WO(x) ((x) + KERNBASE)    
0215 
0216 
0217 
0218 
0219 
0220 
0221 
0222 
0223 
0224 
0225 
0226 
0227 
0228 
0229 
0230 
0231 
0232 
0233 
0234 
0235 
0236 
0237 
0238 
0239 
0240 
0241 
0242 
0243 
0244 
0245 
0246 
0247 
0248 
0249 
0250 struct buf;
0251 struct context;
0252 struct file;
0253 struct inode;
0254 struct pipe;
0255 struct proc;
0256 struct rtcdate;
0257 struct spinlock;
0258 struct sleeplock;
0259 struct stat;
0260 struct superblock;
0261 
0262 
0263 void            binit(void);
0264 struct buf*     bread(uint, uint);
0265 void            brelse(struct buf*);
0266 void            bwrite(struct buf*);
0267 
0268 
0269 void            consoleinit(void);
0270 void            cprintf(char*, ...);
0271 void            consoleintr(int(*)(void));
0272 void            panic(char*) __attribute__((noreturn));
0273 
0274 
0275 int             exec(char*, char**);
0276 
0277 
0278 struct file*    filealloc(void);
0279 void            fileclose(struct file*);
0280 struct file*    filedup(struct file*);
0281 void            fileinit(void);
0282 int             fileread(struct file*, char*, int n);
0283 int             filestat(struct file*, struct stat*);
0284 int             filewrite(struct file*, char*, int n);
0285 
0286 
0287 void            readsb(int dev, struct superblock *sb);
0288 int             dirlink(struct inode*, char*, uint);
0289 struct inode*   dirlookup(struct inode*, char*, uint*);
0290 struct inode*   ialloc(uint, short);
0291 struct inode*   idup(struct inode*);
0292 void            iinit(int dev);
0293 void            ilock(struct inode*);
0294 void            iput(struct inode*);
0295 void            iunlock(struct inode*);
0296 void            iunlockput(struct inode*);
0297 void            iupdate(struct inode*);
0298 int             namecmp(const char*, const char*);
0299 struct inode*   namei(char*);
0300 struct inode*   nameiparent(char*, char*);
0301 int             readi(struct inode*, char*, uint, uint);
0302 void            stati(struct inode*, struct stat*);
0303 int             writei(struct inode*, char*, uint, uint);
0304 
0305 
0306 void            ideinit(void);
0307 void            ideintr(void);
0308 void            iderw(struct buf*);
0309 
0310 
0311 void            ioapicenable(int irq, int cpu);
0312 extern uchar    ioapicid;
0313 void            ioapicinit(void);
0314 
0315 
0316 char*           kalloc(void);
0317 void            kfree(char*);
0318 void            kinit1(void*, void*);
0319 void            kinit2(void*, void*);
0320 
0321 
0322 void            kbdintr(void);
0323 
0324 
0325 void            cmostime(struct rtcdate *r);
0326 int             lapicid(void);
0327 extern volatile uint*    lapic;
0328 void            lapiceoi(void);
0329 void            lapicinit(void);
0330 void            lapicstartap(uchar, uint);
0331 void            microdelay(int);
0332 
0333 
0334 void            initlog(int dev);
0335 void            log_write(struct buf*);
0336 void            begin_op();
0337 void            end_op();
0338 
0339 
0340 extern int      ismp;
0341 void            mpinit(void);
0342 
0343 
0344 void            picenable(int);
0345 void            picinit(void);
0346 
0347 
0348 
0349 
0350 
0351 int             pipealloc(struct file**, struct file**);
0352 void            pipeclose(struct pipe*, int);
0353 int             piperead(struct pipe*, char*, int);
0354 int             pipewrite(struct pipe*, char*, int);
0355 
0356 
0357 
0358 int             cpuid(void);
0359 void            exit(void);
0360 int             fork(void);
0361 int             growproc(int);
0362 int             kill(int);
0363 struct cpu*     mycpu(void);
0364 struct proc*    myproc();
0365 void            pinit(void);
0366 void            procdump(void);
0367 void            scheduler(void) __attribute__((noreturn));
0368 void            sched(void);
0369 void            setproc(struct proc*);
0370 void            sleep(void*, struct spinlock*);
0371 void            userinit(void);
0372 int             wait(void);
0373 void            wakeup(void*);
0374 void            yield(void);
0375 
0376 void            greet(void);
0377 void*           growproc_lazy(int);
0378 
0379 
0380 void            swtch(struct context**, struct context*);
0381 
0382 
0383 void            acquire(struct spinlock*);
0384 void            getcallerpcs(void*, uint*);
0385 int             holding(struct spinlock*);
0386 void            initlock(struct spinlock*, char*);
0387 void            release(struct spinlock*);
0388 void            pushcli(void);
0389 void            popcli(void);
0390 
0391 
0392 void            acquiresleep(struct sleeplock*);
0393 void            releasesleep(struct sleeplock*);
0394 int             holdingsleep(struct sleeplock*);
0395 void            initsleeplock(struct sleeplock*, char*);
0396 
0397 
0398 
0399 
0400 
0401 int             memcmp(const void*, const void*, uint);
0402 void*           memmove(void*, const void*, uint);
0403 void*           memset(void*, int, uint);
0404 char*           safestrcpy(char*, const char*, int);
0405 int             strlen(const char*);
0406 int             strncmp(const char*, const char*, uint);
0407 char*           strncpy(char*, const char*, int);
0408 
0409 
0410 int             argint(int, int*);
0411 int             argptr(int, char**, int);
0412 int             argstr(int, char**);
0413 int             fetchint(uint, int*);
0414 int             fetchstr(uint, char**);
0415 void            syscall(void);
0416 
0417 
0418 void            timerinit(void);
0419 
0420 
0421 void            idtinit(void);
0422 extern uint     ticks;
0423 void            tvinit(void);
0424 extern struct spinlock tickslock;
0425 
0426 
0427 void            uartinit(void);
0428 void            uartintr(void);
0429 void            uartputc(int);
0430 
0431 
0432 void            seginit(void);
0433 void            kvmalloc(void);
0434 pde_t*          setupkvm(void);
0435 char*           uva2ka(pde_t*, char*);
0436 int             allocuvm(pde_t*, uint, uint);
0437 int             deallocuvm(pde_t*, uint, uint);
0438 void            freevm(pde_t*);
0439 void            inituvm(pde_t*, char*, uint);
0440 int             loaduvm(pde_t*, char*, struct inode*, uint, uint);
0441 pde_t*          copyuvm(pde_t*, uint);
0442 void            switchuvm(struct proc*);
0443 void            switchkvm(void);
0444 int             copyout(pde_t*, uint, void*, uint);
0445 void            clearpteu(pde_t *pgdir, char *uva);
0446 int             sys_numvp(void);
0447 int             sys_numpp(void);
0448 int             getptsize(void);
0449 int             sys_mmap(void);
0450 int             allocuvm_lazy(pde_t *pgdir, uint oldsz, uint newsz);
0451 int             sys_munmap(void);
0452 
0453 
0454 #define NELEM(x) (sizeof(x)/sizeof((x)[0]))
0455 
0456 
0457 
0458 
0459 
0460 
0461 
0462 
0463 
0464 
0465 
0466 
0467 
0468 
0469 
0470 
0471 
0472 
0473 
0474 
0475 
0476 
0477 
0478 
0479 
0480 
0481 
0482 
0483 
0484 
0485 
0486 
0487 
0488 
0489 
0490 
0491 
0492 
0493 
0494 
0495 
0496 
0497 
0498 
0499 
0500 
0501 
0502 static inline uchar
0503 inb(ushort port)
0504 {
0505   uchar data;
0506 
0507   asm volatile("in %1,%0" : "=a" (data) : "d" (port));
0508   return data;
0509 }
0510 
0511 static inline void
0512 insl(int port, void *addr, int cnt)
0513 {
0514   asm volatile("cld; rep insl" :
0515                "=D" (addr), "=c" (cnt) :
0516                "d" (port), "0" (addr), "1" (cnt) :
0517                "memory", "cc");
0518 }
0519 
0520 static inline void
0521 outb(ushort port, uchar data)
0522 {
0523   asm volatile("out %0,%1" : : "a" (data), "d" (port));
0524 }
0525 
0526 static inline void
0527 outw(ushort port, ushort data)
0528 {
0529   asm volatile("out %0,%1" : : "a" (data), "d" (port));
0530 }
0531 
0532 static inline void
0533 outsl(int port, const void *addr, int cnt)
0534 {
0535   asm volatile("cld; rep outsl" :
0536                "=S" (addr), "=c" (cnt) :
0537                "d" (port), "0" (addr), "1" (cnt) :
0538                "cc");
0539 }
0540 
0541 static inline void
0542 stosb(void *addr, int data, int cnt)
0543 {
0544   asm volatile("cld; rep stosb" :
0545                "=D" (addr), "=c" (cnt) :
0546                "0" (addr), "1" (cnt), "a" (data) :
0547                "memory", "cc");
0548 }
0549 
0550 static inline void
0551 stosl(void *addr, int data, int cnt)
0552 {
0553   asm volatile("cld; rep stosl" :
0554                "=D" (addr), "=c" (cnt) :
0555                "0" (addr), "1" (cnt), "a" (data) :
0556                "memory", "cc");
0557 }
0558 
0559 struct segdesc;
0560 
0561 static inline void
0562 lgdt(struct segdesc *p, int size)
0563 {
0564   volatile ushort pd[3];
0565 
0566   pd[0] = size-1;
0567   pd[1] = (uint)p;
0568   pd[2] = (uint)p >> 16;
0569 
0570   asm volatile("lgdt (%0)" : : "r" (pd));
0571 }
0572 
0573 struct gatedesc;
0574 
0575 static inline void
0576 lidt(struct gatedesc *p, int size)
0577 {
0578   volatile ushort pd[3];
0579 
0580   pd[0] = size-1;
0581   pd[1] = (uint)p;
0582   pd[2] = (uint)p >> 16;
0583 
0584   asm volatile("lidt (%0)" : : "r" (pd));
0585 }
0586 
0587 static inline void
0588 ltr(ushort sel)
0589 {
0590   asm volatile("ltr %0" : : "r" (sel));
0591 }
0592 
0593 static inline uint
0594 readeflags(void)
0595 {
0596   uint eflags;
0597   asm volatile("pushfl; popl %0" : "=r" (eflags));
0598   return eflags;
0599 }
0600 static inline void
0601 loadgs(ushort v)
0602 {
0603   asm volatile("movw %0, %%gs" : : "r" (v));
0604 }
0605 
0606 static inline void
0607 cli(void)
0608 {
0609   asm volatile("cli");
0610 }
0611 
0612 static inline void
0613 sti(void)
0614 {
0615   asm volatile("sti");
0616 }
0617 
0618 static inline uint
0619 xchg(volatile uint *addr, uint newval)
0620 {
0621   uint result;
0622 
0623   
0624   asm volatile("lock; xchgl %0, %1" :
0625                "+m" (*addr), "=a" (result) :
0626                "1" (newval) :
0627                "cc");
0628   return result;
0629 }
0630 
0631 static inline uint
0632 rcr2(void)
0633 {
0634   uint val;
0635   asm volatile("movl %%cr2,%0" : "=r" (val));
0636   return val;
0637 }
0638 
0639 static inline void
0640 lcr3(uint val)
0641 {
0642   asm volatile("movl %0,%%cr3" : : "r" (val));
0643 }
0644 
0645 
0646 
0647 
0648 
0649 
0650 
0651 
0652 struct trapframe {
0653   
0654   uint edi;
0655   uint esi;
0656   uint ebp;
0657   uint oesp;      
0658   uint ebx;
0659   uint edx;
0660   uint ecx;
0661   uint eax;
0662 
0663   
0664   ushort gs;
0665   ushort padding1;
0666   ushort fs;
0667   ushort padding2;
0668   ushort es;
0669   ushort padding3;
0670   ushort ds;
0671   ushort padding4;
0672   uint trapno;
0673 
0674   
0675   uint err;
0676   uint eip;
0677   ushort cs;
0678   ushort padding5;
0679   uint eflags;
0680 
0681   
0682   uint esp;
0683   ushort ss;
0684   ushort padding6;
0685 };
0686 
0687 
0688 
0689 
0690 
0691 
0692 
0693 
0694 
0695 
0696 
0697 
0698 
0699 
0700 
0701 
0702 
0703 
0704 #define SEG_NULLASM                                             \
0705         .word 0, 0;                                             \
0706         .byte 0, 0, 0, 0
0707 
0708 
0709 
0710 #define SEG_ASM(type,base,lim)                                  \
0711         .word (((lim) >> 12) & 0xffff), ((base) & 0xffff);      \
0712         .byte (((base) >> 16) & 0xff), (0x90 | (type)),         \
0713                 (0xC0 | (((lim) >> 28) & 0xf)), (((base) >> 24) & 0xff)
0714 
0715 #define STA_X     0x8       
0716 #define STA_W     0x2       
0717 #define STA_R     0x2       
0718 
0719 
0720 
0721 
0722 
0723 
0724 
0725 
0726 
0727 
0728 
0729 
0730 
0731 
0732 
0733 
0734 
0735 
0736 
0737 
0738 
0739 
0740 
0741 
0742 
0743 
0744 
0745 
0746 
0747 
0748 
0749 
0750 
0751 
0752 
0753 
0754 #define FL_IF           0x00000200      
0755 
0756 
0757 #define CR0_PE          0x00000001      
0758 #define CR0_WP          0x00010000      
0759 #define CR0_PG          0x80000000      
0760 
0761 #define CR4_PSE         0x00000010      
0762 
0763 
0764 #define SEG_KCODE 1  
0765 #define SEG_KDATA 2  
0766 #define SEG_UCODE 3  
0767 #define SEG_UDATA 4  
0768 #define SEG_TSS   5  
0769 
0770 
0771 #define NSEGS     6
0772 
0773 #ifndef __ASSEMBLER__
0774 
0775 struct segdesc {
0776   uint lim_15_0 : 16;  
0777   uint base_15_0 : 16; 
0778   uint base_23_16 : 8; 
0779   uint type : 4;       
0780   uint s : 1;          
0781   uint dpl : 2;        
0782   uint p : 1;          
0783   uint lim_19_16 : 4;  
0784   uint avl : 1;        
0785   uint rsv1 : 1;       
0786   uint db : 1;         
0787   uint g : 1;          
0788   uint base_31_24 : 8; 
0789 };
0790 
0791 
0792 
0793 
0794 
0795 
0796 
0797 
0798 
0799 
0800 
0801 #define SEG(type, base, lim, dpl) (struct segdesc)    \
0802 { ((lim) >> 12) & 0xffff, (uint)(base) & 0xffff,      \
0803   ((uint)(base) >> 16) & 0xff, type, 1, dpl, 1,       \
0804   (uint)(lim) >> 28, 0, 0, 1, 1, (uint)(base) >> 24 }
0805 #define SEG16(type, base, lim, dpl) (struct segdesc)  \
0806 { (lim) & 0xffff, (uint)(base) & 0xffff,              \
0807   ((uint)(base) >> 16) & 0xff, type, 1, dpl, 1,       \
0808   (uint)(lim) >> 16, 0, 0, 1, 0, (uint)(base) >> 24 }
0809 #endif
0810 
0811 #define DPL_USER    0x3     
0812 
0813 
0814 #define STA_X       0x8     
0815 #define STA_W       0x2     
0816 #define STA_R       0x2     
0817 
0818 
0819 #define STS_T32A    0x9     
0820 #define STS_IG32    0xE     
0821 #define STS_TG32    0xF     
0822 
0823 
0824 
0825 
0826 
0827 
0828 
0829 
0830 
0831 
0832 #define PDX(va)         (((uint)(va) >> PDXSHIFT) & 0x3FF)
0833 
0834 
0835 #define PTX(va)         (((uint)(va) >> PTXSHIFT) & 0x3FF)
0836 
0837 
0838 #define PGADDR(d, t, o) ((uint)((d) << PDXSHIFT | (t) << PTXSHIFT | (o)))
0839 
0840 
0841 #define NPDENTRIES      1024    
0842 #define NPTENTRIES      1024    
0843 #define PGSIZE          4096    
0844 
0845 #define PTXSHIFT        12      
0846 #define PDXSHIFT        22      
0847 
0848 #define PGROUNDUP(sz)  (((sz)+PGSIZE-1) & ~(PGSIZE-1))
0849 #define PGROUNDDOWN(a) (((a)) & ~(PGSIZE-1))
0850 
0851 #define PTE_P           0x001   
0852 #define PTE_W           0x002   
0853 #define PTE_U           0x004   
0854 #define PTE_PS          0x080   
0855 #define PTE_LAZY        0x200   
0856 
0857 
0858 #define PTE_ADDR(pte)   ((uint)(pte) & ~0xFFF)
0859 #define PTE_FLAGS(pte)  ((uint)(pte) &  0xFFF)
0860 
0861 #ifndef __ASSEMBLER__
0862 typedef uint pte_t;
0863 
0864 
0865 struct taskstate {
0866   uint link;         
0867   uint esp0;         
0868   ushort ss0;        
0869   ushort padding1;
0870   uint *esp1;
0871   ushort ss1;
0872   ushort padding2;
0873   uint *esp2;
0874   ushort ss2;
0875   ushort padding3;
0876   void *cr3;         
0877   uint *eip;         
0878   uint eflags;
0879   uint eax;          
0880   uint ecx;
0881   uint edx;
0882   uint ebx;
0883   uint *esp;
0884   uint *ebp;
0885   uint esi;
0886   uint edi;
0887   ushort es;         
0888   ushort padding4;
0889   ushort cs;
0890   ushort padding5;
0891   ushort ss;
0892   ushort padding6;
0893   ushort ds;
0894   ushort padding7;
0895   ushort fs;
0896   ushort padding8;
0897   ushort gs;
0898   ushort padding9;
0899   ushort ldt;
0900   ushort padding10;
0901   ushort t;          
0902   ushort iomb;       
0903 };
0904 
0905 
0906 struct gatedesc {
0907   uint off_15_0 : 16;   
0908   uint cs : 16;         
0909   uint args : 5;        
0910   uint rsv1 : 3;        
0911   uint type : 4;        
0912   uint s : 1;           
0913   uint dpl : 2;         
0914   uint p : 1;           
0915   uint off_31_16 : 16;  
0916 };
0917 
0918 
0919 
0920 
0921 
0922 
0923 
0924 
0925 
0926 #define SETGATE(gate, istrap, sel, off, d)                \
0927 {                                                         \
0928   (gate).off_15_0 = (uint)(off) & 0xffff;                \
0929   (gate).cs = (sel);                                      \
0930   (gate).args = 0;                                        \
0931   (gate).rsv1 = 0;                                        \
0932   (gate).type = (istrap) ? STS_TG32 : STS_IG32;           \
0933   (gate).s = 0;                                           \
0934   (gate).dpl = (d);                                       \
0935   (gate).p = 1;                                           \
0936   (gate).off_31_16 = (uint)(off) >> 16;                  \
0937 }
0938 
0939 #endif
0940 
0941 
0942 
0943 
0944 
0945 
0946 
0947 
0948 
0949 
0950 
0951 
0952 #define ELF_MAGIC 0x464C457FU  
0953 
0954 
0955 struct elfhdr {
0956   uint magic;  
0957   uchar elf[12];
0958   ushort type;
0959   ushort machine;
0960   uint version;
0961   uint entry;
0962   uint phoff;
0963   uint shoff;
0964   uint flags;
0965   ushort ehsize;
0966   ushort phentsize;
0967   ushort phnum;
0968   ushort shentsize;
0969   ushort shnum;
0970   ushort shstrndx;
0971 };
0972 
0973 
0974 struct proghdr {
0975   uint type;
0976   uint off;
0977   uint vaddr;
0978   uint paddr;
0979   uint filesz;
0980   uint memsz;
0981   uint flags;
0982   uint align;
0983 };
0984 
0985 
0986 #define ELF_PROG_LOAD           1
0987 
0988 
0989 #define ELF_PROG_FLAG_EXEC      1
0990 #define ELF_PROG_FLAG_WRITE     2
0991 #define ELF_PROG_FLAG_READ      4
0992 
0993 
0994 
0995 
0996 
0997 
0998 
0999 
1000 struct rtcdate {
1001   uint second;
1002   uint minute;
1003   uint hour;
1004   uint day;
1005   uint month;
1006   uint year;
1007 };
1008 
1009 
1010 
1011 
1012 
1013 
1014 
1015 
1016 
1017 
1018 
1019 
1020 
1021 
1022 
1023 
1024 
1025 
1026 
1027 
1028 
1029 
1030 
1031 
1032 
1033 
1034 
1035 
1036 
1037 
1038 
1039 
1040 
1041 
1042 
1043 
1044 
1045 
1046 
1047 
1048 
1049 
1050 
1051 
1052 
1053 
1054 
1055 
1056 
1057 
1058 
1059 
1060 
1061 
1062 
1063 
1064 
1065 
1066 
1067 
1068 
1069 
1070 
1071 
1072 
1073 
1074 
1075 
1076 .p2align 2
1077 .text
1078 .globl multiboot_header
1079 multiboot_header:
1080   
1081   
1082   .long magic
1083   .long flags
1084   .long (-magic-flags)
1085 
1086 
1087 
1088 
1089 .globl _start
1090 _start = V2P_WO(entry)
1091 
1092 
1093 .globl entry
1094 entry:
1095   
1096   movl    %cr4, %eax
1097   orl     $(CR4_PSE), %eax
1098   movl    %eax, %cr4
1099   
1100   movl    $(V2P_WO(entrypgdir)), %eax
1101   movl    %eax, %cr3
1102   
1103   movl    %cr0, %eax
1104   orl     $(CR0_PG|CR0_WP), %eax
1105   movl    %eax, %cr0
1106 
1107   
1108   movl $(stack + KSTACKSIZE), %esp
1109 
1110   
1111   
1112   
1113   
1114   mov $main, %eax
1115   jmp *%eax
1116 
1117 .comm stack, KSTACKSIZE
1118 
1119 
1120 
1121 
1122 
1123 
1124 
1125 
1126 
1127 
1128 
1129 
1130 
1131 
1132 
1133 
1134 
1135 
1136 
1137 
1138 
1139 
1140 
1141 
1142 
1143 
1144 
1145 
1146 
1147 
1148 
1149 
1150 
1151 
1152 
1153 
1154 
1155 
1156 
1157 
1158 
1159 
1160 
1161 
1162 
1163 
1164 
1165 
1166 
1167 
1168 
1169 
1170 
1171 .code16
1172 .globl start
1173 start:
1174   cli
1175 
1176   
1177   xorw    %ax,%ax
1178   movw    %ax,%ds
1179   movw    %ax,%es
1180   movw    %ax,%ss
1181 
1182   
1183   
1184   
1185   lgdt    gdtdesc
1186   movl    %cr0, %eax
1187   orl     $CR0_PE, %eax
1188   movl    %eax, %cr0
1189 
1190   
1191   
1192   
1193   ljmpl    $(SEG_KCODE<<3), $(start32)
1194 
1195 
1196 
1197 
1198 
1199 
1200 .code32  
1201 start32:
1202   
1203   movw    $(SEG_KDATA<<3), %ax    
1204   movw    %ax, %ds                
1205   movw    %ax, %es                
1206   movw    %ax, %ss                
1207   movw    $0, %ax                 
1208   movw    %ax, %fs                
1209   movw    %ax, %gs                
1210 
1211   
1212   movl    %cr4, %eax
1213   orl     $(CR4_PSE), %eax
1214   movl    %eax, %cr4
1215   
1216   movl    (start-12), %eax
1217   movl    %eax, %cr3
1218   
1219   movl    %cr0, %eax
1220   orl     $(CR0_PE|CR0_PG|CR0_WP), %eax
1221   movl    %eax, %cr0
1222 
1223   
1224   movl    (start-4), %esp
1225   
1226   call	 *(start-8)
1227 
1228   movw    $0x8a00, %ax
1229   movw    %ax, %dx
1230   outw    %ax, %dx
1231   movw    $0x8ae0, %ax
1232   outw    %ax, %dx
1233 spin:
1234   jmp     spin
1235 
1236 .p2align 2
1237 gdt:
1238   SEG_NULLASM
1239   SEG_ASM(STA_X|STA_R, 0, 0xffffffff)
1240   SEG_ASM(STA_W, 0, 0xffffffff)
1241 
1242 
1243 gdtdesc:
1244   .word   (gdtdesc - gdt - 1)
1245   .long   gdt
1246 
1247 
1248 
1249 
1250 #include "types.h"
1251 #include "defs.h"
1252 #include "param.h"
1253 #include "memlayout.h"
1254 #include "mmu.h"
1255 #include "proc.h"
1256 #include "x86.h"
1257 
1258 static void startothers(void);
1259 static void mpmain(void)  __attribute__((noreturn));
1260 extern pde_t *kpgdir;
1261 extern char end[]; 
1262 
1263 
1264 
1265 
1266 int
1267 main(void)
1268 {
1269   kinit1(end, P2V(4*1024*1024)); 
1270   kvmalloc();      
1271   mpinit();        
1272   lapicinit();     
1273   seginit();       
1274   picinit();       
1275   ioapicinit();    
1276   consoleinit();   
1277   uartinit();      
1278   pinit();         
1279   tvinit();        
1280   binit();         
1281   fileinit();      
1282   ideinit();       
1283   startothers();   
1284   kinit2(P2V(4*1024*1024), P2V(PHYSTOP)); 
1285   userinit();      
1286   mpmain();        
1287 }
1288 
1289 
1290 static void
1291 mpenter(void)
1292 {
1293   switchkvm();
1294   seginit();
1295   lapicinit();
1296   mpmain();
1297 }
1298 
1299 
1300 
1301 static void
1302 mpmain(void)
1303 {
1304   cprintf("cpu%d: starting %d\n", cpuid(), cpuid());
1305   idtinit();       
1306   xchg(&(mycpu()->started), 1); 
1307   scheduler();     
1308 }
1309 
1310 pde_t entrypgdir[];  
1311 
1312 
1313 static void
1314 startothers(void)
1315 {
1316   extern uchar _binary_entryother_start[], _binary_entryother_size[];
1317   uchar *code;
1318   struct cpu *c;
1319   char *stack;
1320 
1321   
1322   
1323   
1324   code = P2V(0x7000);
1325   memmove(code, _binary_entryother_start, (uint)_binary_entryother_size);
1326 
1327   for(c = cpus; c < cpus+ncpu; c++){
1328     if(c == mycpu())  
1329       continue;
1330 
1331     
1332     
1333     
1334     stack = kalloc();
1335     *(void**)(code-4) = stack + KSTACKSIZE;
1336     *(void(**)(void))(code-8) = mpenter;
1337     *(int**)(code-12) = (void *) V2P(entrypgdir);
1338 
1339     lapicstartap(c->apicid, V2P(code));
1340 
1341     
1342     while(c->started == 0)
1343       ;
1344   }
1345 }
1346 
1347 
1348 
1349 
1350 
1351 
1352 
1353 
1354 
1355 __attribute__((__aligned__(PGSIZE)))
1356 pde_t entrypgdir[NPDENTRIES] = {
1357   
1358   [0] = (0) | PTE_P | PTE_W | PTE_PS,
1359   
1360   [KERNBASE>>PDXSHIFT] = (0) | PTE_P | PTE_W | PTE_PS,
1361 };
1362 
1363 
1364 
1365 
1366 
1367 
1368 
1369 
1370 
1371 
1372 
1373 
1374 
1375 
1376 
1377 
1378 
1379 
1380 
1381 
1382 
1383 
1384 
1385 
1386 
1387 
1388 
1389 
1390 
1391 
1392 
1393 
1394 
1395 
1396 
1397 
1398 
1399 
1400 
1401 
1402 
1403 
1404 
1405 
1406 
1407 
1408 
1409 
1410 
1411 
1412 
1413 
1414 
1415 
1416 
1417 
1418 
1419 
1420 
1421 
1422 
1423 
1424 
1425 
1426 
1427 
1428 
1429 
1430 
1431 
1432 
1433 
1434 
1435 
1436 
1437 
1438 
1439 
1440 
1441 
1442 
1443 
1444 
1445 
1446 
1447 
1448 
1449 
1450 
1451 
1452 
1453 
1454 
1455 
1456 
1457 
1458 
1459 
1460 
1461 
1462 
1463 
1464 
1465 
1466 
1467 
1468 
1469 
1470 
1471 
1472 
1473 
1474 
1475 
1476 
1477 
1478 
1479 
1480 
1481 
1482 
1483 
1484 
1485 
1486 
1487 
1488 
1489 
1490 
1491 
1492 
1493 
1494 
1495 
1496 
1497 
1498 
1499 
1500 
1501 
1502 
1503 
1504 
1505 
1506 
1507 
1508 
1509 
1510 
1511 
1512 
1513 
1514 
1515 
1516 
1517 
1518 
1519 
1520 
1521 
1522 
1523 
1524 
1525 
1526 
1527 
1528 
1529 
1530 
1531 
1532 
1533 
1534 
1535 
1536 
1537 
1538 
1539 
1540 
1541 
1542 
1543 
1544 
1545 
1546 
1547 
1548 
1549 
1550 
1551 struct spinlock {
1552   uint locked;       
1553 
1554   
1555   char *name;        
1556   struct cpu *cpu;   
1557   uint pcs[10];      
1558                      
1559 };
1560 
1561 
1562 
1563 
1564 
1565 
1566 
1567 
1568 
1569 
1570 
1571 
1572 
1573 
1574 
1575 
1576 
1577 
1578 
1579 
1580 
1581 
1582 
1583 
1584 
1585 
1586 
1587 
1588 
1589 
1590 
1591 
1592 
1593 
1594 
1595 
1596 
1597 
1598 
1599 
1600 
1601 
1602 #include "types.h"
1603 #include "defs.h"
1604 #include "param.h"
1605 #include "x86.h"
1606 #include "memlayout.h"
1607 #include "mmu.h"
1608 #include "proc.h"
1609 #include "spinlock.h"
1610 
1611 void
1612 initlock(struct spinlock *lk, char *name)
1613 {
1614   lk->name = name;
1615   lk->locked = 0;
1616   lk->cpu = 0;
1617 }
1618 
1619 
1620 
1621 
1622 
1623 void
1624 acquire(struct spinlock *lk)
1625 {
1626   pushcli(); 
1627   if(holding(lk))
1628     panic("acquire");
1629 
1630   
1631   while(xchg(&lk->locked, 1) != 0)
1632     ;
1633 
1634   
1635   
1636   
1637   __sync_synchronize();
1638 
1639   
1640   lk->cpu = mycpu();
1641   getcallerpcs(&lk, lk->pcs);
1642 }
1643 
1644 
1645 
1646 
1647 
1648 
1649 
1650 
1651 void
1652 release(struct spinlock *lk)
1653 {
1654   if(!holding(lk))
1655     panic("release");
1656 
1657   lk->pcs[0] = 0;
1658   lk->cpu = 0;
1659 
1660   
1661   
1662   
1663   
1664   
1665   __sync_synchronize();
1666 
1667   
1668   
1669   
1670   asm volatile("movl $0, %0" : "+m" (lk->locked) : );
1671 
1672   popcli();
1673 }
1674 
1675 
1676 void
1677 getcallerpcs(void *v, uint pcs[])
1678 {
1679   uint *ebp;
1680   int i;
1681 
1682   ebp = (uint*)v - 2;
1683   for(i = 0; i < 10; i++){
1684     if(ebp == 0 || ebp < (uint*)KERNBASE || ebp == (uint*)0xffffffff)
1685       break;
1686     pcs[i] = ebp[1];     
1687     ebp = (uint*)ebp[0]; 
1688   }
1689   for(; i < 10; i++)
1690     pcs[i] = 0;
1691 }
1692 
1693 
1694 
1695 
1696 
1697 
1698 
1699 
1700 
1701 int
1702 holding(struct spinlock *lock)
1703 {
1704   int r;
1705   pushcli();
1706   r = lock->locked && lock->cpu == mycpu();
1707   popcli();
1708   return r;
1709 }
1710 
1711 
1712 
1713 
1714 
1715 
1716 void
1717 pushcli(void)
1718 {
1719   int eflags;
1720 
1721   eflags = readeflags();
1722   cli();
1723   if(mycpu()->ncli == 0)
1724     mycpu()->intena = eflags & FL_IF;
1725   mycpu()->ncli += 1;
1726 }
1727 
1728 void
1729 popcli(void)
1730 {
1731   if(readeflags()&FL_IF)
1732     panic("popcli - interruptible");
1733   if(--mycpu()->ncli < 0)
1734     panic("popcli");
1735   if(mycpu()->ncli == 0 && mycpu()->intena)
1736     sti();
1737 }
1738 
1739 
1740 
1741 
1742 
1743 
1744 
1745 
1746 
1747 
1748 
1749 
1750 #include "param.h"
1751 #include "types.h"
1752 #include "defs.h"
1753 #include "x86.h"
1754 #include "memlayout.h"
1755 #include "mmu.h"
1756 #include "proc.h"
1757 #include "elf.h"
1758 
1759 extern char data[];  
1760 pde_t *kpgdir;  
1761 
1762 
1763 
1764 void
1765 seginit(void)
1766 {
1767   struct cpu *c;
1768 
1769   
1770   
1771   
1772   
1773   c = &cpus[cpuid()];
1774   c->gdt[SEG_KCODE] = SEG(STA_X|STA_R, 0, 0xffffffff, 0);
1775   c->gdt[SEG_KDATA] = SEG(STA_W, 0, 0xffffffff, 0);
1776   c->gdt[SEG_UCODE] = SEG(STA_X|STA_R, 0, 0xffffffff, DPL_USER);
1777   c->gdt[SEG_UDATA] = SEG(STA_W, 0, 0xffffffff, DPL_USER);
1778   lgdt(c->gdt, sizeof(c->gdt));
1779 }
1780 
1781 
1782 
1783 
1784 static pte_t *
1785 walkpgdir(pde_t *pgdir, const void *va, int alloc)
1786 {
1787   pde_t *pde;
1788   pte_t *pgtab;
1789 
1790   pde = &pgdir[PDX(va)];
1791   if(*pde & PTE_P){
1792     pgtab = (pte_t*)P2V(PTE_ADDR(*pde));
1793   } else {
1794     if(!alloc || (pgtab = (pte_t*)kalloc()) == 0)
1795       return 0;
1796     
1797     memset(pgtab, 0, PGSIZE);
1798     
1799     
1800     
1801     *pde = V2P(pgtab) | PTE_P | PTE_W | PTE_U;
1802   }
1803   return &pgtab[PTX(va)];
1804 }
1805 
1806 
1807 
1808 
1809 static int
1810 mappages(pde_t *pgdir, void *va, uint size, uint pa, int perm)
1811 {
1812   char *a, *last;
1813   pte_t *pte;
1814 
1815   a = (char*)PGROUNDDOWN((uint)va);
1816   last = (char*)PGROUNDDOWN(((uint)va) + size - 1);
1817   for(;;){
1818     if((pte = walkpgdir(pgdir, a, 1)) == 0)
1819       return -1;
1820     if(*pte & PTE_P)
1821       panic("remap");
1822     *pte = pa | perm | PTE_P;
1823     if(a == last)
1824       break;
1825     a += PGSIZE;
1826     pa += PGSIZE;
1827   }
1828   return 0;
1829 }
1830 
1831 
1832 
1833 
1834 
1835 
1836 
1837 
1838 
1839 
1840 
1841 
1842 
1843 
1844 
1845 
1846 
1847 
1848 
1849 
1850 
1851 
1852 
1853 
1854 static struct kmap {
1855   void *virt;
1856   uint phys_start;
1857   uint phys_end;
1858   int perm;
1859 } kmap[] = {
1860  { (void*)KERNBASE, 0,             EXTMEM,    PTE_W}, 
1861  { (void*)KERNLINK, V2P(KERNLINK), V2P(data), 0},     
1862  { (void*)data,     V2P(data),     PHYSTOP,   PTE_W}, 
1863  { (void*)DEVSPACE, DEVSPACE,      0,         PTE_W}, 
1864 };
1865 
1866 
1867 pde_t*
1868 setupkvm(void)
1869 {
1870   pde_t *pgdir;
1871   struct kmap *k;
1872 
1873   if((pgdir = (pde_t*)kalloc()) == 0)
1874     return 0;
1875   memset(pgdir, 0, PGSIZE);
1876   if (P2V(PHYSTOP) > (void*)DEVSPACE)
1877     panic("PHYSTOP too high");
1878   for(k = kmap; k < &kmap[NELEM(kmap)]; k++)
1879     if(mappages(pgdir, k->virt, k->phys_end - k->phys_start,
1880                 (uint)k->phys_start, k->perm) < 0) {
1881       freevm(pgdir);
1882       return 0;
1883     }
1884   return pgdir;
1885 }
1886 
1887 
1888 
1889 void
1890 kvmalloc(void)
1891 {
1892   kpgdir = setupkvm();
1893   switchkvm();
1894 }
1895 
1896 
1897 
1898 
1899 
1900 
1901 
1902 void
1903 switchkvm(void)
1904 {
1905   lcr3(V2P(kpgdir));   
1906 }
1907 
1908 
1909 void
1910 switchuvm(struct proc *p)
1911 {
1912   if(p == 0)
1913     panic("switchuvm: no process");
1914   if(p->kstack == 0)
1915     panic("switchuvm: no kstack");
1916   if(p->pgdir == 0)
1917     panic("switchuvm: no pgdir");
1918 
1919   pushcli();
1920   mycpu()->gdt[SEG_TSS] = SEG16(STS_T32A, &mycpu()->ts,
1921                                 sizeof(mycpu()->ts)-1, 0);
1922   mycpu()->gdt[SEG_TSS].s = 0;
1923   mycpu()->ts.ss0 = SEG_KDATA << 3;
1924   mycpu()->ts.esp0 = (uint)p->kstack + KSTACKSIZE;
1925   
1926   
1927   mycpu()->ts.iomb = (ushort) 0xFFFF;
1928   ltr(SEG_TSS << 3);
1929   lcr3(V2P(p->pgdir));  
1930   popcli();
1931 }
1932 
1933 
1934 
1935 void
1936 inituvm(pde_t *pgdir, char *init, uint sz)
1937 {
1938   char *mem;
1939 
1940   if(sz >= PGSIZE)
1941     panic("inituvm: more than a page");
1942   mem = kalloc();
1943   memset(mem, 0, PGSIZE);
1944   mappages(pgdir, 0, PGSIZE, V2P(mem), PTE_W|PTE_U);
1945   memmove(mem, init, sz);
1946 }
1947 
1948 
1949 
1950 
1951 
1952 int
1953 loaduvm(pde_t *pgdir, char *addr, struct inode *ip, uint offset, uint sz)
1954 {
1955   uint i, pa, n;
1956   pte_t *pte;
1957 
1958   if((uint) addr % PGSIZE != 0)
1959     panic("loaduvm: addr must be page aligned");
1960   for(i = 0; i < sz; i += PGSIZE){
1961     if((pte = walkpgdir(pgdir, addr+i, 0)) == 0)
1962       panic("loaduvm: address should exist");
1963     pa = PTE_ADDR(*pte);
1964     if(sz - i < PGSIZE)
1965       n = sz - i;
1966     else
1967       n = PGSIZE;
1968     if(readi(ip, P2V(pa), offset+i, n) != n)
1969       return -1;
1970   }
1971   return 0;
1972 }
1973 
1974 
1975 
1976 int
1977 allocuvm(pde_t *pgdir, uint oldsz, uint newsz)
1978 {
1979   char *mem;
1980   uint a;
1981 
1982   if(newsz >= KERNBASE)
1983     return 0;
1984   if(newsz < oldsz)
1985     return oldsz;
1986 
1987   a = PGROUNDUP(oldsz);
1988   for(; a < newsz; a += PGSIZE){
1989     mem = kalloc();
1990     if(mem == 0){
1991       cprintf("allocuvm out of memory\n");
1992       deallocuvm(pgdir, newsz, oldsz);
1993       return 0;
1994     }
1995     memset(mem, 0, PGSIZE);
1996     if(mappages(pgdir, (char*)a, PGSIZE, V2P(mem), PTE_W|PTE_U) < 0){
1997       cprintf("allocuvm out of memory (2)\n");
1998       deallocuvm(pgdir, newsz, oldsz);
1999       kfree(mem);
2000       return 0;
2001     }
2002   }
2003   return newsz;
2004 }
2005 
2006 
2007 int
2008 allocuvm_lazy(pde_t *pgdir, uint oldsz, uint newsz) {
2009   char *mem;
2010   uint a;
2011 
2012   if(newsz >= KERNBASE)
2013     return 0;
2014   if(newsz < oldsz)
2015     return oldsz;
2016 
2017   a = PGROUNDUP(oldsz);
2018   for(; a < newsz; a += PGSIZE){
2019     if((pgdir[PDX(a)] & PTE_P) == 0) {
2020       
2021       char *mem = kalloc();
2022       if(mem == 0)
2023         panic("allocuvm_lazy");
2024       memset(mem, 0, PGSIZE);
2025       pgdir[PDX(a)] = V2P(mem) | PTE_P | PTE_W | PTE_U;
2026     }
2027 
2028     pte_t *pgtable = P2V(PTE_ADDR(pgdir[PDX(a)]));
2029     pgtable[PTX(a)] = 0;
2030     pgtable[PTX(a)] = PTE_W | PTE_U | PTE_LAZY;
2031   }
2032   return newsz;
2033 }
2034 
2035 
2036 
2037 
2038 
2039 int
2040 deallocuvm(pde_t *pgdir, uint oldsz, uint newsz)
2041 {
2042   pte_t *pte;
2043   uint a, pa;
2044 
2045   if(newsz >= oldsz)
2046     return oldsz;
2047 
2048 
2049 
2050   a = PGROUNDUP(newsz);
2051   for(; a  < oldsz; a += PGSIZE){
2052     pte = walkpgdir(pgdir, (char*)a, 0);
2053     if(!pte)
2054       a = PGADDR(PDX(a) + 1, 0, 0) - PGSIZE;
2055     else if((*pte & PTE_P) != 0){
2056       pa = PTE_ADDR(*pte);
2057       if(pa == 0)
2058         panic("kfree");
2059       char *v = P2V(pa);
2060       kfree(v);
2061       *pte = 0;
2062     }
2063   }
2064   return newsz;
2065 }
2066 
2067 
2068 
2069 void
2070 freevm(pde_t *pgdir)
2071 {
2072   uint i;
2073 
2074   if(pgdir == 0)
2075     panic("freevm: no pgdir");
2076   deallocuvm(pgdir, KERNBASE, 0);
2077   for(i = 0; i < NPDENTRIES; i++){
2078     if(pgdir[i] & PTE_P){
2079       char * v = P2V(PTE_ADDR(pgdir[i]));
2080       kfree(v);
2081     }
2082   }
2083   kfree((char*)pgdir);
2084 }
2085 
2086 
2087 
2088 void
2089 clearpteu(pde_t *pgdir, char *uva)
2090 {
2091   pte_t *pte;
2092 
2093   pte = walkpgdir(pgdir, uva, 0);
2094   if(pte == 0)
2095     panic("clearpteu");
2096   *pte &= ~PTE_U;
2097 }
2098 
2099 
2100 
2101 
2102 pde_t*
2103 copyuvm(pde_t *pgdir, uint sz)
2104 {
2105   pde_t *new_pgdir;
2106   if((new_pgdir = setupkvm()) == 0)
2107     return 0;
2108 
2109   for(int i=0; i<KERNBASE/(PGSIZE*NPTENTRIES); i++) {
2110     if((pgdir[i] & PTE_P) == 0)
2111       continue;
2112 
2113     pte_t *pgtable = P2V(PTE_ADDR(pgdir[i]));
2114     pte_t *new_pgtable = kalloc();
2115     if(new_pgtable == 0)
2116       goto bad;
2117     memmove(new_pgtable, pgtable, PGSIZE);
2118     for(int j=0; j<NPTENTRIES; j++) {
2119       pte_t pte = pgtable[j];
2120       uint flags = (pte & 0xfff);
2121 
2122       if((flags & (PTE_P | PTE_LAZY)) == 0)
2123         continue;
2124       if(flags & PTE_LAZY) {
2125         new_pgtable[j] = flags;
2126         continue;
2127       }
2128 
2129       char *mem = kalloc();
2130       if(mem == 0)
2131         goto bad;
2132       memmove(mem, (void*)(i*PGSIZE*NPTENTRIES+j*PGSIZE), PGSIZE);
2133       new_pgtable[j] = (V2P(mem) | flags);
2134     }
2135     new_pgdir[i] = ((uint)V2P(new_pgtable) | PTE_P | PTE_W | PTE_U);
2136   }
2137 
2138   return new_pgdir;
2139 bad:
2140   freevm(new_pgdir);
2141   return 0;
2142 }
2143 
2144 
2145 
2146 
2147 
2148 
2149 
2150 
2151 char*
2152 uva2ka(pde_t *pgdir, char *uva)
2153 {
2154   pte_t *pte;
2155 
2156   pte = walkpgdir(pgdir, uva, 0);
2157   if((*pte & PTE_P) == 0)
2158     return 0;
2159   if((*pte & PTE_U) == 0)
2160     return 0;
2161   return (char*)P2V(PTE_ADDR(*pte));
2162 }
2163 
2164 
2165 
2166 
2167 int
2168 copyout(pde_t *pgdir, uint va, void *p, uint len)
2169 {
2170   char *buf, *pa0;
2171   uint n, va0;
2172 
2173   buf = (char*)p;
2174   while(len > 0){
2175     va0 = (uint)PGROUNDDOWN(va);
2176     pa0 = uva2ka(pgdir, (char*)va0);
2177     if(pa0 == 0)
2178       return -1;
2179     n = PGSIZE - (va - va0);
2180     if(n > len)
2181       n = len;
2182     memmove(pa0 + (va - va0), buf, n);
2183     len -= n;
2184     buf += n;
2185     va = va0 + PGSIZE;
2186   }
2187   return 0;
2188 }
2189 
2190 
2191 
2192 
2193 
2194 
2195 
2196 
2197 
2198 
2199 
2200 
2201 
2202 
2203 
2204 
2205 
2206 
2207 
2208 
2209 
2210 
2211 
2212 
2213 
2214 
2215 
2216 
2217 
2218 
2219 
2220 
2221 
2222 
2223 
2224 
2225 
2226 
2227 
2228 
2229 
2230 
2231 
2232 
2233 
2234 
2235 
2236 
2237 
2238 
2239 
2240 
2241 
2242 
2243 
2244 
2245 
2246 
2247 
2248 
2249 
2250 
2251 
2252 
2253 
2254 
2255 
2256 
2257 
2258 
2259 
2260 
2261 
2262 
2263 
2264 
2265 
2266 
2267 
2268 
2269 
2270 
2271 
2272 
2273 
2274 
2275 
2276 
2277 
2278 
2279 
2280 
2281 
2282 
2283 
2284 
2285 
2286 
2287 
2288 
2289 
2290 
2291 
2292 
2293 
2294 
2295 
2296 
2297 
2298 
2299 
2300 
2301 
2302 
2303 
2304 int sys_numvp(void) {
2305   struct proc *p = myproc();
2306 
2307   pde_t *pgdir = p->pgdir;
2308   int cnt = 0;
2309 
2310   for(int i=0; i<NPDENTRIES/2; i++) {
2311     if((pgdir[i] & PTE_P) == 0)
2312       continue;
2313 
2314     pte_t *pgtable = (pte_t*)P2V(PTE_ADDR(pgdir[i]));
2315     for(int j=0; j<NPTENTRIES; j++) {
2316       if((pgtable[j] & (PTE_P | PTE_LAZY)) == 0)
2317         continue;
2318       cnt++;
2319     }
2320   }
2321   return cnt + 1;     
2322   
2323 }
2324 
2325 int sys_numpp(void) {
2326   struct proc *p = myproc();
2327 
2328   pde_t *pgdir = p->pgdir;
2329   int cnt = 0;
2330 
2331   for(int i=0; i<NPDENTRIES/2; i++) {
2332     if((pgdir[i] & PTE_P) == 0)
2333       continue;
2334 
2335     pte_t *pgtable = (pte_t*)P2V(PTE_ADDR(pgdir[i]));
2336     for(int j=0; j<NPTENTRIES; j++) {
2337       if((pgtable[j] & PTE_P) == 0)
2338         continue;
2339       cnt++;
2340     }
2341   }
2342   return cnt + 1;     
2343 }
2344 
2345 
2346 
2347 
2348 
2349 
2350 int sys_getptsize(void) {
2351   int cnt = 0;
2352 
2353   pde_t *pgdir = myproc()->pgdir;
2354   for(int i=0; i<NPDENTRIES; i++) {
2355     if(pgdir[i] & PTE_P)
2356       cnt++;
2357   }
2358   return cnt + 1;     
2359 }
2360 
2361 
2362 int sys_mmap(void) {
2363   int n;
2364   char *start;
2365   if(argint(0, (int*)(&start)))
2366     return -1;
2367   if(argint(1, &n) < 0)
2368     return -1;
2369 
2370   struct proc *curr_proc = myproc();
2371   
2372   if(n < 0)
2373     return -1;
2374   if(((uint)start & 0xfff) != 0) {
2375     cprintf("mmap: start address is not page aligned.\n");
2376     return -1;
2377   }
2378   if(start + PGROUNDUP(n) > KERNBASE) {
2379     cprintf("mmap: Invalid inputs to mmap(%x, %d).\n", start, n);
2380     return -1;
2381   }
2382 
2383 
2384   
2385   for(uint p=start; p < start + PGROUNDUP(n); p += PGSIZE) {
2386     pte_t *pte = walkpgdir(curr_proc->pgdir, p, 1);
2387     if(*pte & PTE_P) {
2388       cprintf("mmap: given range of pages are not free.\n");
2389       return -1;
2390     }
2391     *pte = 0 | PTE_LAZY;
2392   }
2393 
2394   switchuvm(curr_proc);
2395   return 0;
2396 }
2397 
2398 
2399 
2400 int sys_munmap(void) {
2401   char *start;
2402   int n;    
2403   if(argint(0, (int*)&start) < 0)
2404     return -1;
2405   if(argint(1, &n) < 0)
2406     return -1;
2407   cprintf("sys_munmap called with arguments: {start = %x, n = %d}\n", start, n);
2408 
2409   
2410   if(n < 0)
2411     return -1;
2412   if(((uint)start & 0xfff) != 0) {
2413     cprintf("munmap: start address is not page aligned.\n");
2414     return -1;
2415   }
2416   if(start + PGROUNDUP(n) > KERNBASE) {
2417     cprintf("munmap: Invalid inputs to mmap(%x, %d).\n", start, n);
2418     return -1;
2419   }
2420 
2421 
2422   
2423   struct proc *curr_proc = myproc();
2424   pde_t *pgdir = curr_proc->pgdir;
2425   for(uint addr=start; addr < start+PGROUNDUP(n); addr += PGSIZE) {
2426 
2427 
2428     pte_t *pte = walkpgdir(pgdir, addr, 0);
2429     if(pte == 0) {
2430       cprintf("munmap: Page doesn't exist at address %x\n", addr);
2431       return -1;
2432     }
2433 
2434     
2435     if(*pte & PTE_P)
2436       kfree(P2V(PTE_ADDR(*pte)));
2437     *pte = 0;
2438   }
2439 
2440   switchuvm(curr_proc);
2441 
2442 }
2443 
2444 
2445 
2446 
2447 
2448 
2449 
2450 
2451 struct cpu {
2452   uchar apicid;                
2453   struct context *scheduler;   
2454   struct taskstate ts;         
2455   struct segdesc gdt[NSEGS];   
2456   volatile uint started;       
2457   int ncli;                    
2458   int intena;                  
2459   struct proc *proc;           
2460 };
2461 
2462 extern struct cpu cpus[NCPU];
2463 extern int ncpu;
2464 
2465 
2466 
2467 
2468 
2469 
2470 
2471 
2472 
2473 
2474 
2475 
2476 struct context {
2477   uint edi;
2478   uint esi;
2479   uint ebx;
2480   uint ebp;
2481   uint eip;
2482 };
2483 
2484 enum procstate { UNUSED, EMBRYO, SLEEPING, RUNNABLE, RUNNING, ZOMBIE };
2485 
2486 
2487 struct proc {
2488   uint sz;                     
2489   pde_t* pgdir;                
2490   char *kstack;                
2491   enum procstate state;        
2492   int pid;                     
2493   struct proc *parent;         
2494   struct trapframe *tf;        
2495   struct context *context;     
2496   void *chan;                  
2497   int killed;                  
2498   struct file *ofile[NOFILE];  
2499   struct inode *cwd;           
2500   char name[16];               
2501   int shm_idx;                 
2502   char *shm_va;                
2503 };
2504 
2505 
2506 
2507 
2508 
2509 
2510 
2511 
2512 
2513 
2514 
2515 
2516 
2517 
2518 
2519 
2520 
2521 
2522 
2523 
2524 
2525 
2526 
2527 
2528 
2529 
2530 
2531 
2532 
2533 
2534 
2535 
2536 
2537 
2538 
2539 
2540 
2541 
2542 
2543 
2544 
2545 
2546 
2547 
2548 
2549 
2550 #include "types.h"
2551 #include "defs.h"
2552 #include "param.h"
2553 #include "memlayout.h"
2554 #include "mmu.h"
2555 #include "x86.h"
2556 #include "proc.h"
2557 #include "spinlock.h"
2558 #include "sh_mem.h"
2559 
2560 struct {
2561   struct spinlock lock;
2562   struct proc proc[NPROC];
2563 } ptable;
2564 
2565 static struct proc *initproc;
2566 
2567 int nextpid = 1;
2568 extern void forkret(void);
2569 extern void trapret(void);
2570 
2571 static void wakeup1(void *chan);
2572 
2573 void
2574 pinit(void)
2575 {
2576   initlock(&ptable.lock, "ptable");
2577 }
2578 
2579 
2580 int
2581 cpuid() {
2582   return mycpu()-cpus;
2583 }
2584 
2585 
2586 
2587 struct cpu*
2588 mycpu(void)
2589 {
2590   int apicid, i;
2591 
2592   if(readeflags()&FL_IF)
2593     panic("mycpu called with interrupts enabled\n");
2594 
2595   apicid = lapicid();
2596   
2597   
2598   for (i = 0; i < ncpu; ++i) {
2599     if (cpus[i].apicid == apicid)
2600       return &cpus[i];
2601   }
2602   panic("unknown apicid\n");
2603 }
2604 
2605 
2606 
2607 struct proc*
2608 myproc(void) {
2609   struct cpu *c;
2610   struct proc *p;
2611   pushcli();
2612   c = mycpu();
2613   p = c->proc;
2614   popcli();
2615   return p;
2616 }
2617 
2618 static int get_smallest_pid() {
2619   int pids[NPROC];
2620   for(int i=0; i<NPROC; i++)
2621     pids[i] = 0;  
2622 
2623   for(struct proc *p=ptable.proc; p < ptable.proc+NPROC; p++) {
2624     if(p->state != UNUSED) {
2625       pids[p->pid] = 1;
2626     }
2627   }
2628 
2629   int pid = -1;
2630   for(int i=0; i<NPROC; i++) {
2631     if(pids[i] == 0) {
2632       pid = i;
2633       break;
2634     }
2635   }
2636   return pid;
2637 
2638 }
2639 
2640 
2641 
2642 
2643 
2644 
2645 
2646 
2647 
2648 
2649 
2650 
2651 
2652 
2653 
2654 static struct proc*
2655 allocproc(void)
2656 {
2657   struct proc *p;
2658   char *sp;
2659 
2660   acquire(&ptable.lock);
2661 
2662   for(p = ptable.proc; p < &ptable.proc[NPROC]; p++)
2663     if(p->state == UNUSED)
2664       goto found;
2665 
2666   release(&ptable.lock);
2667   return 0;
2668 
2669 found:
2670   p->state = EMBRYO;
2671   
2672   p->pid = get_smallest_pid();
2673 
2674   release(&ptable.lock);
2675 
2676   
2677   if((p->kstack = kalloc()) == 0){
2678     p->state = UNUSED;
2679     return 0;
2680   }
2681   sp = p->kstack + KSTACKSIZE;
2682 
2683   
2684   sp -= sizeof *p->tf;
2685   p->tf = (struct trapframe*)sp;
2686 
2687   
2688   
2689   sp -= 4;
2690   *(uint*)sp = (uint)trapret;
2691 
2692   sp -= sizeof *p->context;
2693   p->context = (struct context*)sp;
2694   memset(p->context, 0, sizeof *p->context);
2695   p->context->eip = (uint)forkret;
2696 
2697   p->shm_idx = -1;
2698   p->shm_va = 0;
2699 
2700   return p;
2701 }
2702 
2703 
2704 
2705 void
2706 userinit(void)
2707 {
2708   struct proc *p;
2709   extern char _binary_initcode_start[], _binary_initcode_size[];
2710 
2711   p = allocproc();
2712 
2713   initproc = p;
2714   if((p->pgdir = setupkvm()) == 0)
2715     panic("userinit: out of memory?");
2716   inituvm(p->pgdir, _binary_initcode_start, (int)_binary_initcode_size);
2717   p->sz = PGSIZE;
2718   memset(p->tf, 0, sizeof(*p->tf));
2719   p->tf->cs = (SEG_UCODE << 3) | DPL_USER;
2720   p->tf->ds = (SEG_UDATA << 3) | DPL_USER;
2721   p->tf->es = p->tf->ds;
2722   p->tf->ss = p->tf->ds;
2723   p->tf->eflags = FL_IF;
2724   p->tf->esp = PGSIZE;
2725   p->tf->eip = 0;  
2726 
2727   safestrcpy(p->name, "initcode", sizeof(p->name));
2728   p->cwd = namei("/");
2729 
2730   
2731   
2732   
2733   
2734   acquire(&ptable.lock);
2735 
2736   p->state = RUNNABLE;
2737 
2738   release(&ptable.lock);
2739 }
2740 
2741 
2742 
2743 
2744 
2745 
2746 
2747 
2748 
2749 
2750 
2751 
2752 int
2753 growproc(int n)
2754 {
2755   uint sz;
2756   struct proc *curproc = myproc();
2757 
2758   sz = curproc->sz;
2759   if(n > 0){
2760     if((sz = allocuvm(curproc->pgdir, sz, sz + n)) == 0)
2761       return -1;
2762   } else if(n < 0){
2763     if((sz = deallocuvm(curproc->pgdir, sz, sz + n)) == 0)
2764       return -1;
2765   }
2766   curproc->sz = sz;
2767   switchuvm(curproc);
2768   return 0;
2769 }
2770 
2771 
2772 void *growproc_lazy(int n) {
2773   struct proc *curr_proc = myproc();
2774 
2775   int sz = curr_proc->sz;
2776   if(n > 0) {
2777     if((sz = allocuvm_lazy(curr_proc->pgdir, sz, sz + n)) == 0)
2778       return -1;
2779   } else if(n < 0){
2780     if((sz = deallocuvm(curr_proc->pgdir, sz, sz + n)) == 0)
2781       return -1;
2782   }
2783   curr_proc->sz = sz;
2784   switchuvm(curr_proc);
2785   return 0;
2786 }
2787 
2788 
2789 
2790 
2791 
2792 
2793 
2794 
2795 
2796 
2797 
2798 
2799 
2800 
2801 
2802 
2803 int
2804 fork(void)
2805 {
2806   int i, pid;
2807   struct proc *np;
2808   struct proc *curproc = myproc();
2809 
2810   
2811   if((np = allocproc()) == 0){
2812     return -1;
2813   }
2814 
2815   
2816   if((np->pgdir = copyuvm(curproc->pgdir, curproc->sz)) == 0){
2817     kfree(np->kstack);
2818     np->kstack = 0;
2819     np->state = UNUSED;
2820     return -1;
2821   }
2822   np->sz = curproc->sz;
2823   np->parent = curproc;
2824   *np->tf = *curproc->tf;
2825 
2826   
2827   np->tf->eax = 0;
2828 
2829   for(i = 0; i < NOFILE; i++)
2830     if(curproc->ofile[i])
2831       np->ofile[i] = filedup(curproc->ofile[i]);
2832   np->cwd = idup(curproc->cwd);
2833 
2834   safestrcpy(np->name, curproc->name, sizeof(curproc->name));
2835 
2836   pid = np->pid;
2837 
2838   acquire(&ptable.lock);
2839 
2840   np->state = RUNNABLE;
2841 
2842   release(&ptable.lock);
2843 
2844   return pid;
2845 }
2846 
2847 
2848 
2849 
2850 
2851 
2852 
2853 void
2854 exit(void)
2855 {
2856   struct proc *curproc = myproc();
2857   struct proc *p;
2858   int fd;
2859 
2860   if(curproc == initproc)
2861     panic("init exiting");
2862 
2863   
2864   for(fd = 0; fd < NOFILE; fd++){
2865     if(curproc->ofile[fd]){
2866       fileclose(curproc->ofile[fd]);
2867       curproc->ofile[fd] = 0;
2868     }
2869   }
2870 
2871   begin_op();
2872   iput(curproc->cwd);
2873   end_op();
2874   curproc->cwd = 0;
2875 
2876   acquire(&ptable.lock);
2877 
2878   
2879   wakeup1(curproc->parent);
2880 
2881   
2882   for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
2883     if(p->parent == curproc){
2884       p->parent = initproc;
2885       if(p->state == ZOMBIE)
2886         wakeup1(initproc);
2887     }
2888   }
2889 
2890   
2891   curproc->state = ZOMBIE;
2892   sched();
2893   panic("zombie exit");
2894 }
2895 
2896 
2897 
2898 
2899 
2900 
2901 
2902 int
2903 wait(void)
2904 {
2905   struct proc *p;
2906   int havekids, pid;
2907   struct proc *curproc = myproc();
2908 
2909   acquire(&ptable.lock);
2910   for(;;){
2911     
2912     havekids = 0;
2913     for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
2914       if(p->parent != curproc)
2915         continue;
2916       havekids = 1;
2917       if(p->state == ZOMBIE){
2918         
2919         pid = p->pid;
2920         kfree(p->kstack);
2921         p->kstack = 0;
2922         freevm(p->pgdir);
2923         p->pid = 0;
2924         p->parent = 0;
2925         p->name[0] = 0;
2926         p->killed = 0;
2927         p->state = UNUSED;
2928         release(&ptable.lock);
2929         return pid;
2930       }
2931     }
2932 
2933     
2934     if(!havekids || curproc->killed){
2935       release(&ptable.lock);
2936       return -1;
2937     }
2938 
2939     
2940     sleep(curproc, &ptable.lock);  
2941   }
2942 }
2943 
2944 
2945 
2946 
2947 
2948 
2949 
2950 
2951 
2952 
2953 
2954 
2955 
2956 
2957 void
2958 scheduler(void)
2959 {
2960   struct proc *p;
2961   struct cpu *c = mycpu();
2962   c->proc = 0;
2963 
2964   for(;;){
2965     
2966     sti();
2967 
2968     
2969     acquire(&ptable.lock);
2970     for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
2971       if(p->state != RUNNABLE)
2972         continue;
2973 
2974       
2975       
2976       
2977       c->proc = p;
2978       switchuvm(p);
2979       p->state = RUNNING;
2980 
2981       swtch(&(c->scheduler), p->context);
2982       switchkvm();
2983 
2984       
2985       
2986       c->proc = 0;
2987     }
2988     release(&ptable.lock);
2989 
2990   }
2991 }
2992 
2993 
2994 
2995 
2996 
2997 
2998 
2999 
3000 
3001 
3002 
3003 
3004 
3005 
3006 
3007 void
3008 sched(void)
3009 {
3010   int intena;
3011   struct proc *p = myproc();
3012 
3013   if(!holding(&ptable.lock))
3014     panic("sched ptable.lock");
3015   if(mycpu()->ncli != 1)
3016     panic("sched locks");
3017   if(p->state == RUNNING)
3018     panic("sched running");
3019   if(readeflags()&FL_IF)
3020     panic("sched interruptible");
3021   intena = mycpu()->intena;
3022   swtch(&p->context, mycpu()->scheduler);
3023   mycpu()->intena = intena;
3024 }
3025 
3026 
3027 void
3028 yield(void)
3029 {
3030   acquire(&ptable.lock);  
3031   myproc()->state = RUNNABLE;
3032   sched();
3033   release(&ptable.lock);
3034 }
3035 
3036 
3037 
3038 
3039 
3040 
3041 
3042 
3043 
3044 
3045 
3046 
3047 
3048 
3049 
3050 
3051 
3052 void
3053 forkret(void)
3054 {
3055   static int first = 1;
3056   
3057   release(&ptable.lock);
3058 
3059   if (first) {
3060     
3061     
3062     
3063     first = 0;
3064     iinit(ROOTDEV);
3065     initlog(ROOTDEV);
3066   }
3067 
3068   
3069 }
3070 
3071 
3072 
3073 void
3074 sleep(void *chan, struct spinlock *lk)
3075 {
3076   struct proc *p = myproc();
3077 
3078   if(p == 0)
3079     panic("sleep");
3080 
3081   if(lk == 0)
3082     panic("sleep without lk");
3083 
3084   
3085   
3086   
3087   
3088   
3089   
3090   if(lk != &ptable.lock){  
3091     acquire(&ptable.lock);  
3092     release(lk);
3093   }
3094   
3095   p->chan = chan;
3096   p->state = SLEEPING;
3097 
3098   sched();
3099 
3100   
3101   p->chan = 0;
3102 
3103   
3104   if(lk != &ptable.lock){  
3105     release(&ptable.lock);
3106     acquire(lk);
3107   }
3108 }
3109 
3110 
3111 
3112 
3113 
3114 
3115 
3116 
3117 
3118 
3119 
3120 
3121 
3122 
3123 
3124 
3125 
3126 
3127 
3128 
3129 
3130 
3131 
3132 
3133 
3134 
3135 
3136 
3137 
3138 
3139 
3140 
3141 
3142 
3143 
3144 
3145 
3146 
3147 
3148 
3149 
3150 
3151 
3152 static void
3153 wakeup1(void *chan)
3154 {
3155   struct proc *p;
3156 
3157   for(p = ptable.proc; p < &ptable.proc[NPROC]; p++)
3158     if(p->state == SLEEPING && p->chan == chan)
3159       p->state = RUNNABLE;
3160 }
3161 
3162 
3163 void
3164 wakeup(void *chan)
3165 {
3166   acquire(&ptable.lock);
3167   wakeup1(chan);
3168   release(&ptable.lock);
3169 }
3170 
3171 
3172 
3173 
3174 int
3175 kill(int pid)
3176 {
3177   struct proc *p;
3178 
3179   acquire(&ptable.lock);
3180   for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
3181     if(p->pid == pid){
3182       p->killed = 1;
3183       
3184       if(p->state == SLEEPING)
3185         p->state = RUNNABLE;
3186       release(&ptable.lock);
3187       return 0;
3188     }
3189   }
3190   release(&ptable.lock);
3191   return -1;
3192 }
3193 
3194 
3195 
3196 
3197 
3198 
3199 
3200 
3201 
3202 
3203 void
3204 procdump(void)
3205 {
3206   static char *states[] = {
3207   [UNUSED]    "unused",
3208   [EMBRYO]    "embryo",
3209   [SLEEPING]  "sleep ",
3210   [RUNNABLE]  "runble",
3211   [RUNNING]   "run   ",
3212   [ZOMBIE]    "zombie"
3213   };
3214   int i;
3215   struct proc *p;
3216   char *state;
3217   uint pc[10];
3218 
3219   for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
3220     if(p->state == UNUSED)
3221       continue;
3222     if(p->state >= 0 && p->state < NELEM(states) && states[p->state])
3223       state = states[p->state];
3224     else
3225       state = "???";
3226     cprintf("%d %s %s", p->pid, state, p->name);
3227     if(p->state == SLEEPING){
3228       getcallerpcs((uint*)p->context->ebp+2, pc);
3229       for(i=0; i<10 && pc[i] != 0; i++)
3230         cprintf(" %p", pc[i]);
3231     }
3232     cprintf("\n");
3233   }
3234 }
3235 
3236 
3237 void sys_greet(void) {
3238   char *name;
3239   argstr(0, &name);
3240 
3241   cprintf("Hello %s\n", name);
3242 }
3243 
3244 
3245 
3246 
3247 
3248 
3249 
3250 static char *map_last_page(uint pa, uint perm) {
3251   struct proc *p = myproc();
3252   pde_t *pgdir = p->pgdir;
3253   for(int i = (KERNBASE >> PDXSHIFT); i >= 0; i--) {
3254     pde_t *pde = &pgdir[i];
3255     if(!(*pde & PTE_P)) {
3256       char *va = kalloc();
3257       memset(va, 0, PGSIZE);
3258       *pde = (V2P(va) | PTE_P | PTE_W);    
3259     }
3260 
3261     pte_t *pgtable = P2V(PTE_ADDR(*pde));
3262     for(int j=NPTENTRIES-1; j >= 0; j--) {
3263       pte_t *pte = &pgtable[j];
3264       if(*pte & PTE_P)
3265         continue;
3266 
3267       *pte = (pa | PTE_P | perm);         
3268       return (char*)PGADDR(i, j, 0);
3269     }
3270   }
3271   return 0;
3272 }
3273 
3274 uint sys_shm_open(void) {
3275   struct proc *p = myproc();
3276   if(p->shm_va != 0)
3277     return p->shm_va;
3278 
3279   
3280   char *va;
3281   va = kalloc();
3282   if(va == 0) {
3283     cprintf("sys_shm_open: kalloc failed");
3284     return 0;
3285   }
3286   uint pa = (uint)V2P(va);
3287 
3288   char *uva;
3289   uva = map_last_page(pa, PTE_U | PTE_W);
3290   if(uva == 0) {
3291     cprintf("sys_shm_open: map_last_page failed.");
3292     return 0;
3293   }
3294 
3295   int idx = shm_add(pa);
3296   if(idx < 0) {
3297     cprintf("sys_shm_open: shm_add failed.\n");
3298     return 0;
3299   }
3300   p->shm_va = uva;
3301   p->shm_idx = idx;
3302 
3303   return uva;
3304 }
3305 
3306 uint sys_shm_get(void) {
3307   struct proc *p = myproc();
3308   return p->shm_va;
3309 }
3310 
3311 static pte_t *walkpgdir(pde_t *pgdir, char *uva) {
3312   pde_t *pde = &pgdir[PDX(uva)];
3313   if(!(*pde & PTE_P))   return 0;
3314   pte_t *pgtable = P2V(PTE_ADDR(*pde));
3315   pte_t *pte = &pgtable[PTX(uva)];
3316   return pte;
3317   return 0;
3318 }
3319 
3320 int sys_shm_close(void) {
3321   struct proc *p = myproc();
3322   if(p->shm_va == 0) {
3323     cprintf("sys_shm_close: attempted to close non-existing shared memory.");
3324     return -1;
3325   }
3326 
3327   int idx = p->shm_idx;
3328   pte_t *pte = walkpgdir(p->pgdir, p->shm_va);
3329   uint pa = PTE_ADDR(*pte);
3330   
3331   char *uva = p->shm_va;
3332 
3333   if(shm_remove(pa) < 0) {
3334     cprintf("sys_shm_close: shm_remove failed.");
3335     return -1;
3336   }
3337   *pte = 0;   
3338   p->shm_idx = -1;
3339   p->shm_va = 0;
3340 }
3341 
3342 
3343 
3344 
3345 
3346 
3347 
3348 
3349 
3350 
3351 
3352 
3353 
3354 
3355 
3356 
3357 
3358 .globl swtch
3359 swtch:
3360   movl 4(%esp), %eax
3361   movl 8(%esp), %edx
3362 
3363   
3364   pushl %ebp
3365   pushl %ebx
3366   pushl %esi
3367   pushl %edi
3368 
3369   
3370   movl %esp, (%eax)
3371   movl %edx, %esp
3372 
3373   
3374   popl %edi
3375   popl %esi
3376   popl %ebx
3377   popl %ebp
3378   ret
3379 
3380 
3381 
3382 
3383 
3384 
3385 
3386 
3387 
3388 
3389 
3390 
3391 
3392 
3393 
3394 
3395 
3396 
3397 
3398 
3399 
3400 
3401 
3402 
3403 
3404 #include "types.h"
3405 #include "defs.h"
3406 #include "param.h"
3407 #include "memlayout.h"
3408 #include "mmu.h"
3409 #include "spinlock.h"
3410 
3411 void freerange(void *vstart, void *vend);
3412 extern char end[]; 
3413                    
3414 
3415 struct run {
3416   struct run *next;
3417 };
3418 
3419 struct {
3420   struct spinlock lock;
3421   int use_lock;
3422   struct run *freelist;
3423 } kmem;
3424 
3425 
3426 
3427 
3428 
3429 
3430 void
3431 kinit1(void *vstart, void *vend)
3432 {
3433   initlock(&kmem.lock, "kmem");
3434   kmem.use_lock = 0;
3435   freerange(vstart, vend);
3436 }
3437 
3438 void
3439 kinit2(void *vstart, void *vend)
3440 {
3441   freerange(vstart, vend);
3442   kmem.use_lock = 1;
3443 }
3444 
3445 
3446 
3447 
3448 
3449 
3450 void
3451 freerange(void *vstart, void *vend)
3452 {
3453   char *p;
3454   p = (char*)PGROUNDUP((uint)vstart);
3455   for(; p + PGSIZE <= (char*)vend; p += PGSIZE)
3456     kfree(p);
3457 }
3458 
3459 
3460 
3461 
3462 
3463 void
3464 kfree(char *v)
3465 {
3466   struct run *r;
3467 
3468   if((uint)v % PGSIZE || v < end || V2P(v) >= PHYSTOP)
3469     panic("kfree");
3470 
3471   
3472   memset(v, 1, PGSIZE);
3473 
3474   if(kmem.use_lock)
3475     acquire(&kmem.lock);
3476   r = (struct run*)v;
3477   r->next = kmem.freelist;
3478   kmem.freelist = r;
3479   if(kmem.use_lock)
3480     release(&kmem.lock);
3481 }
3482 
3483 
3484 
3485 
3486 char*
3487 kalloc(void)
3488 {
3489   struct run *r;
3490 
3491   if(kmem.use_lock)
3492     acquire(&kmem.lock);
3493   r = kmem.freelist;
3494   if(r)
3495     kmem.freelist = r->next;
3496   if(kmem.use_lock)
3497     release(&kmem.lock);
3498   return (char*)r;
3499 }
3500 
3501 
3502 
3503 #define T_DIVIDE         0      
3504 #define T_DEBUG          1      
3505 #define T_NMI            2      
3506 #define T_BRKPT          3      
3507 #define T_OFLOW          4      
3508 #define T_BOUND          5      
3509 #define T_ILLOP          6      
3510 #define T_DEVICE         7      
3511 #define T_DBLFLT         8      
3512 
3513 #define T_TSS           10      
3514 #define T_SEGNP         11      
3515 #define T_STACK         12      
3516 #define T_GPFLT         13      
3517 #define T_PGFLT         14      
3518 
3519 #define T_FPERR         16      
3520 #define T_ALIGN         17      
3521 #define T_MCHK          18      
3522 #define T_SIMDERR       19      
3523 
3524 
3525 
3526 #define T_SYSCALL       64      
3527 #define T_DEFAULT      500      
3528 
3529 #define T_IRQ0          32      
3530 
3531 #define IRQ_TIMER        0
3532 #define IRQ_KBD          1
3533 #define IRQ_COM1         4
3534 #define IRQ_IDE         14
3535 #define IRQ_ERROR       19
3536 #define IRQ_SPURIOUS    31
3537 
3538 
3539 
3540 
3541 
3542 
3543 
3544 
3545 
3546 
3547 
3548 
3549 
3550 #!/usr/bin/perl -w
3551 
3552 # Generate vectors.S, the trap/interrupt entry points.
3553 # There has to be one entry point per interrupt number
3554 # since otherwise there's no way for trap() to discover
3555 # the interrupt number.
3556 
3557 print "# generated by vectors.pl - do not edit\n";
3558 print "# handlers\n";
3559 print ".globl alltraps\n";
3560 for(my $i = 0; $i < 256; $i++){
3561     print ".globl vector$i\n";
3562     print "vector$i:\n";
3563     if(!($i == 8 || ($i >= 10 && $i <= 14) || $i == 17)){
3564         print "  pushl \$0\n";
3565     }
3566     print "  pushl \$$i\n";
3567     print "  jmp alltraps\n";
3568 }
3569 
3570 print "\n# vector table\n";
3571 print ".data\n";
3572 print ".globl vectors\n";
3573 print "vectors:\n";
3574 for(my $i = 0; $i < 256; $i++){
3575     print "  .long vector$i\n";
3576 }
3577 
3578 # sample output:
3579 #   # handlers
3580 #   .globl alltraps
3581 #   .globl vector0
3582 #   vector0:
3583 #     pushl $0
3584 #     pushl $0
3585 #     jmp alltraps
3586 #   ...
3587 #
3588 #   # vector table
3589 #   .data
3590 #   .globl vectors
3591 #   vectors:
3592 #     .long vector0
3593 #     .long vector1
3594 #     .long vector2
3595 #   ...
3596 
3597 
3598 
3599 
3600 
3601 
3602   
3603 .globl alltraps
3604 alltraps:
3605   
3606   pushl %ds
3607   pushl %es
3608   pushl %fs
3609   pushl %gs
3610   pushal
3611 
3612   
3613   movw $(SEG_KDATA<<3), %ax
3614   movw %ax, %ds
3615   movw %ax, %es
3616 
3617   
3618   pushl %esp
3619   call trap
3620   addl $4, %esp
3621 
3622   
3623 .globl trapret
3624 trapret:
3625   popal
3626   popl %gs
3627   popl %fs
3628   popl %es
3629   popl %ds
3630   addl $0x8, %esp  
3631   iret
3632 
3633 
3634 
3635 
3636 
3637 
3638 
3639 
3640 
3641 
3642 
3643 
3644 
3645 
3646 
3647 
3648 
3649 
3650 #include "types.h"
3651 #include "defs.h"
3652 #include "param.h"
3653 #include "memlayout.h"
3654 #include "mmu.h"
3655 #include "proc.h"
3656 #include "x86.h"
3657 #include "traps.h"
3658 #include "spinlock.h"
3659 
3660 
3661 struct gatedesc idt[256];
3662 extern uint vectors[];  
3663 struct spinlock tickslock;
3664 uint ticks;
3665 
3666 void
3667 tvinit(void)
3668 {
3669   int i;
3670 
3671   for(i = 0; i < 256; i++)
3672     SETGATE(idt[i], 0, SEG_KCODE<<3, vectors[i], 0);
3673   SETGATE(idt[T_SYSCALL], 1, SEG_KCODE<<3, vectors[T_SYSCALL], DPL_USER);
3674 
3675   initlock(&tickslock, "time");
3676 }
3677 
3678 void
3679 idtinit(void)
3680 {
3681   lidt(idt, sizeof(idt));
3682 }
3683 
3684 static int is_page_lazy(char *addr) {
3685   pde_t *pgdir = myproc()->pgdir;
3686   if(pgdir[PDX(addr)] & PTE_P == 0)
3687     return 0;
3688 
3689   pte_t *pgtable = P2V(PTE_ADDR(pgdir[PDX(addr)]));
3690   return ((pgtable[PTX(addr)] & PTE_LAZY) != 0);
3691 }
3692 
3693 
3694 
3695 
3696 
3697 
3698 
3699 
3700 void
3701 trap(struct trapframe *tf)
3702 {
3703   if(tf->trapno == T_SYSCALL){
3704     if(myproc()->killed)
3705       exit();
3706     myproc()->tf = tf;
3707     syscall();
3708     if(myproc()->killed)
3709       exit();
3710     return;
3711   }
3712 
3713   if(tf->trapno == T_PGFLT) {
3714     struct proc *p = myproc();
3715     uint addr = rcr2();
3716 
3717     if(!is_page_lazy(addr))
3718       goto kill_process;
3719 
3720     pde_t *pgdir = p->pgdir;
3721     pte_t *pgtable = P2V(PTE_ADDR(pgdir[PDX(addr)]));
3722     pgtable[PTX(addr)] = 0;
3723     uint mem = (uint)kalloc();
3724     if(mem == 0) {
3725       cprintf("kalloc: out of physical memory!\n");
3726       goto kill_process;
3727     }
3728 
3729     pgtable[PTX(addr)] &= ~(PTE_LAZY);
3730     pgtable[PTX(addr)] = V2P(mem) | PTE_P | PTE_W | PTE_U;
3731     return;
3732 
3733 
3734   kill_process:
3735     cprintf("Page fault: Killing process %d\n", p->pid);
3736     exit();
3737   }
3738 
3739   switch(tf->trapno){
3740   case T_IRQ0 + IRQ_TIMER:
3741     if(cpuid() == 0){
3742       acquire(&tickslock);
3743       ticks++;
3744       wakeup(&ticks);
3745       release(&tickslock);
3746     }
3747     lapiceoi();
3748     break;
3749   case T_IRQ0 + IRQ_IDE:
3750     ideintr();
3751     lapiceoi();
3752     break;
3753   case T_IRQ0 + IRQ_IDE+1:
3754     
3755     break;
3756   case T_IRQ0 + IRQ_KBD:
3757     kbdintr();
3758     lapiceoi();
3759     break;
3760   case T_IRQ0 + IRQ_COM1:
3761     uartintr();
3762     lapiceoi();
3763     break;
3764   case T_IRQ0 + 7:
3765   case T_IRQ0 + IRQ_SPURIOUS:
3766     cprintf("cpu%d: spurious interrupt at %x:%x\n",
3767             cpuid(), tf->cs, tf->eip);
3768     lapiceoi();
3769     break;
3770 
3771 
3772   default:
3773     if(myproc() == 0 || (tf->cs&3) == 0){
3774       
3775       cprintf("unexpected trap %d from cpu %d eip %x (cr2=0x%x)\n",
3776               tf->trapno, cpuid(), tf->eip, rcr2());
3777       panic("trap");
3778     }
3779     
3780     cprintf("pid %d %s: trap %d err %d on cpu %d "
3781             "eip 0x%x addr 0x%x--kill proc\n",
3782             myproc()->pid, myproc()->name, tf->trapno,
3783             tf->err, cpuid(), tf->eip, rcr2());
3784     myproc()->killed = 1;
3785   }
3786 
3787   
3788   
3789   
3790   if(myproc() && myproc()->killed && (tf->cs&3) == DPL_USER)
3791     exit();
3792 
3793   
3794   
3795   if(myproc() && myproc()->state == RUNNING &&
3796      tf->trapno == T_IRQ0+IRQ_TIMER)
3797     yield();
3798 
3799 
3800   
3801   if(myproc() && myproc()->killed && (tf->cs&3) == DPL_USER)
3802     exit();
3803 }
3804 
3805 
3806 
3807 
3808 
3809 
3810 
3811 
3812 
3813 
3814 
3815 
3816 
3817 
3818 
3819 
3820 
3821 
3822 
3823 
3824 
3825 
3826 
3827 
3828 
3829 
3830 
3831 
3832 
3833 
3834 
3835 
3836 
3837 
3838 
3839 
3840 
3841 
3842 
3843 
3844 
3845 
3846 
3847 
3848 
3849 
3850 
3851 #define SYS_fork    1
3852 #define SYS_exit    2
3853 #define SYS_wait    3
3854 #define SYS_pipe    4
3855 #define SYS_read    5
3856 #define SYS_kill    6
3857 #define SYS_exec    7
3858 #define SYS_fstat   8
3859 #define SYS_chdir   9
3860 #define SYS_dup    10
3861 #define SYS_getpid 11
3862 #define SYS_sbrk   12
3863 #define SYS_sleep  13
3864 #define SYS_uptime 14
3865 #define SYS_open   15
3866 #define SYS_write  16
3867 #define SYS_mknod  17
3868 #define SYS_unlink 18
3869 #define SYS_link   19
3870 #define SYS_mkdir  20
3871 #define SYS_close  21
3872 
3873 
3874 #define SYS_greet   22
3875 #define SYS_numvp   23
3876 #define SYS_numpp   24
3877 #define SYS_getptsize   25
3878 #define SYS_mmap    26
3879 #define SYS_munmap  27
3880 #define SYS_shm_open    28
3881 #define SYS_shm_get     29
3882 #define SYS_shm_close   30
3883 
3884 
3885 
3886 
3887 
3888 
3889 
3890 
3891 
3892 
3893 
3894 
3895 
3896 
3897 
3898 
3899 
3900 #include "types.h"
3901 #include "defs.h"
3902 #include "param.h"
3903 #include "memlayout.h"
3904 #include "mmu.h"
3905 #include "proc.h"
3906 #include "x86.h"
3907 #include "syscall.h"
3908 
3909 
3910 
3911 
3912 
3913 
3914 
3915 
3916 int
3917 fetchint(uint addr, int *ip)
3918 {
3919   struct proc *curproc = myproc();
3920 
3921   if(addr >= curproc->sz || addr+4 > curproc->sz)
3922     return -1;
3923   *ip = *(int*)(addr);
3924   return 0;
3925 }
3926 
3927 
3928 
3929 
3930 int
3931 fetchstr(uint addr, char **pp)
3932 {
3933   char *s, *ep;
3934   struct proc *curproc = myproc();
3935 
3936   if(addr >= curproc->sz)
3937     return -1;
3938   *pp = (char*)addr;
3939   ep = (char*)curproc->sz;
3940   for(s = *pp; s < ep; s++){
3941     if(*s == 0)
3942       return s - *pp;
3943   }
3944   return -1;
3945 }
3946 
3947 
3948 
3949 
3950 
3951 int
3952 argint(int n, int *ip)
3953 {
3954   return fetchint((myproc()->tf->esp) + 4 + 4*n, ip);
3955 }
3956 
3957 
3958 
3959 
3960 int
3961 argptr(int n, char **pp, int size)
3962 {
3963   int i;
3964   struct proc *curproc = myproc();
3965 
3966   if(argint(n, &i) < 0)
3967     return -1;
3968   if(size < 0 || (uint)i >= curproc->sz || (uint)i+size > curproc->sz)
3969     return -1;
3970   *pp = (char*)i;
3971   return 0;
3972 }
3973 
3974 
3975 
3976 
3977 
3978 int
3979 argstr(int n, char **pp)
3980 {
3981   int addr;
3982   if(argint(n, &addr) < 0)
3983     return -1;
3984   return fetchstr(addr, pp);
3985 }
3986 
3987 
3988 
3989 
3990 
3991 
3992 
3993 
3994 
3995 
3996 
3997 
3998 
3999 
4000 extern int sys_chdir(void);
4001 extern int sys_close(void);
4002 extern int sys_dup(void);
4003 extern int sys_exec(void);
4004 extern int sys_exit(void);
4005 extern int sys_fork(void);
4006 extern int sys_fstat(void);
4007 extern int sys_getpid(void);
4008 extern int sys_kill(void);
4009 extern int sys_link(void);
4010 extern int sys_mkdir(void);
4011 extern int sys_mknod(void);
4012 extern int sys_open(void);
4013 extern int sys_pipe(void);
4014 extern int sys_read(void);
4015 extern int sys_sbrk(void);
4016 extern int sys_sleep(void);
4017 extern int sys_unlink(void);
4018 extern int sys_wait(void);
4019 extern int sys_write(void);
4020 extern int sys_uptime(void);
4021 
4022 
4023 extern void sys_greet(void);
4024 extern int sys_numvp(void);
4025 extern int sys_numpp(void);
4026 extern int sys_getptsize(void);
4027 extern int sys_mmap(void);
4028 extern int sys_munmap(void);
4029 extern uint sys_shm_open(void);
4030 extern uint sys_shm_get(void);
4031 extern int sys_shm_close(void);
4032 
4033 static int (*syscalls[])(void) = {
4034 [SYS_fork]    sys_fork,
4035 [SYS_exit]    sys_exit,
4036 [SYS_wait]    sys_wait,
4037 [SYS_pipe]    sys_pipe,
4038 [SYS_read]    sys_read,
4039 [SYS_kill]    sys_kill,
4040 [SYS_exec]    sys_exec,
4041 [SYS_fstat]   sys_fstat,
4042 [SYS_chdir]   sys_chdir,
4043 [SYS_dup]     sys_dup,
4044 [SYS_getpid]  sys_getpid,
4045 [SYS_sbrk]    sys_sbrk,
4046 [SYS_sleep]   sys_sleep,
4047 [SYS_uptime]  sys_uptime,
4048 [SYS_open]    sys_open,
4049 [SYS_write]   sys_write,
4050 [SYS_mknod]   sys_mknod,
4051 [SYS_unlink]  sys_unlink,
4052 [SYS_link]    sys_link,
4053 [SYS_mkdir]   sys_mkdir,
4054 [SYS_close]   sys_close,
4055 [SYS_greet]   sys_greet,
4056 [SYS_numvp]   sys_numvp,
4057 [SYS_numpp]   sys_numpp,
4058 [SYS_getptsize]   sys_getptsize,
4059 [SYS_mmap]    sys_mmap,
4060 [SYS_munmap]  sys_munmap,
4061 [SYS_shm_open]  sys_shm_open,
4062 [SYS_shm_get] sys_shm_get,
4063 [SYS_shm_close] sys_shm_close,
4064 };
4065 
4066 void
4067 syscall(void)
4068 {
4069   int num;
4070   struct proc *curproc = myproc();
4071 
4072   num = curproc->tf->eax;
4073   if(num > 0 && num < NELEM(syscalls) && syscalls[num]) {
4074     curproc->tf->eax = syscalls[num]();
4075   } else {
4076     cprintf("%d %s: unknown sys call %d\n",
4077             curproc->pid, curproc->name, num);
4078     curproc->tf->eax = -1;
4079   }
4080 }
4081 
4082 
4083 
4084 
4085 
4086 
4087 
4088 
4089 
4090 
4091 
4092 
4093 
4094 
4095 
4096 
4097 
4098 
4099 
4100 #include "types.h"
4101 #include "x86.h"
4102 #include "defs.h"
4103 #include "date.h"
4104 #include "param.h"
4105 #include "memlayout.h"
4106 #include "mmu.h"
4107 #include "proc.h"
4108 
4109 int
4110 sys_fork(void)
4111 {
4112   return fork();
4113 }
4114 
4115 int
4116 sys_exit(void)
4117 {
4118   exit();
4119   return 0;  
4120 }
4121 
4122 int
4123 sys_wait(void)
4124 {
4125   return wait();
4126 }
4127 
4128 int
4129 sys_kill(void)
4130 {
4131   int pid;
4132 
4133   if(argint(0, &pid) < 0)
4134     return -1;
4135   return kill(pid);
4136 }
4137 
4138 int
4139 sys_getpid(void)
4140 {
4141   return myproc()->pid;
4142 }
4143 
4144 
4145 
4146 
4147 
4148 
4149 
4150 int
4151 sys_sbrk(void)
4152 {
4153   int addr;
4154   int n;
4155 
4156   if(argint(0, &n) < 0)
4157     return -1;
4158   addr = myproc()->sz;
4159   if(growproc(n) < 0)
4160     return -1;
4161   return addr;
4162 }
4163 
4164 int
4165 sys_sleep(void)
4166 {
4167   int n;
4168   uint ticks0;
4169 
4170   if(argint(0, &n) < 0)
4171     return -1;
4172   acquire(&tickslock);
4173   ticks0 = ticks;
4174   while(ticks - ticks0 < n){
4175     if(myproc()->killed){
4176       release(&tickslock);
4177       return -1;
4178     }
4179     sleep(&ticks, &tickslock);
4180   }
4181   release(&tickslock);
4182   return 0;
4183 }
4184 
4185 
4186 
4187 int
4188 sys_uptime(void)
4189 {
4190   uint xticks;
4191 
4192   acquire(&tickslock);
4193   xticks = ticks;
4194   release(&tickslock);
4195   return xticks;
4196 }
4197 
4198 
4199 
4200 struct buf {
4201   int flags;
4202   uint dev;
4203   uint blockno;
4204   struct sleeplock lock;
4205   uint refcnt;
4206   struct buf *prev; 
4207   struct buf *next;
4208   struct buf *qnext; 
4209   uchar data[BSIZE];
4210 };
4211 #define B_VALID 0x2  
4212 #define B_DIRTY 0x4  
4213 
4214 
4215 
4216 
4217 
4218 
4219 
4220 
4221 
4222 
4223 
4224 
4225 
4226 
4227 
4228 
4229 
4230 
4231 
4232 
4233 
4234 
4235 
4236 
4237 
4238 
4239 
4240 
4241 
4242 
4243 
4244 
4245 
4246 
4247 
4248 
4249 
4250 
4251 struct sleeplock {
4252   uint locked;       
4253   struct spinlock lk; 
4254 
4255   
4256   char *name;        
4257   int pid;           
4258 };
4259 
4260 
4261 
4262 
4263 
4264 
4265 
4266 
4267 
4268 
4269 
4270 
4271 
4272 
4273 
4274 
4275 
4276 
4277 
4278 
4279 
4280 
4281 
4282 
4283 
4284 
4285 
4286 
4287 
4288 
4289 
4290 
4291 
4292 
4293 
4294 
4295 
4296 
4297 
4298 
4299 
4300 #define O_RDONLY  0x000
4301 #define O_WRONLY  0x001
4302 #define O_RDWR    0x002
4303 #define O_CREATE  0x200
4304 
4305 
4306 
4307 
4308 
4309 
4310 
4311 
4312 
4313 
4314 
4315 
4316 
4317 
4318 
4319 
4320 
4321 
4322 
4323 
4324 
4325 
4326 
4327 
4328 
4329 
4330 
4331 
4332 
4333 
4334 
4335 
4336 
4337 
4338 
4339 
4340 
4341 
4342 
4343 
4344 
4345 
4346 
4347 
4348 
4349 
4350 #define T_DIR  1   
4351 #define T_FILE 2   
4352 #define T_DEV  3   
4353 
4354 struct stat {
4355   short type;  
4356   int dev;     
4357   uint ino;    
4358   short nlink; 
4359   uint size;   
4360 };
4361 
4362 
4363 
4364 
4365 
4366 
4367 
4368 
4369 
4370 
4371 
4372 
4373 
4374 
4375 
4376 
4377 
4378 
4379 
4380 
4381 
4382 
4383 
4384 
4385 
4386 
4387 
4388 
4389 
4390 
4391 
4392 
4393 
4394 
4395 
4396 
4397 
4398 
4399 
4400 
4401 
4402 
4403 
4404 #define ROOTINO 1  
4405 #define BSIZE 512  
4406 
4407 
4408 
4409 
4410 
4411 
4412 
4413 struct superblock {
4414   uint size;         
4415   uint nblocks;      
4416   uint ninodes;      
4417   uint nlog;         
4418   uint logstart;     
4419   uint inodestart;   
4420   uint bmapstart;    
4421 };
4422 
4423 #define NDIRECT 12
4424 #define NINDIRECT (BSIZE / sizeof(uint))
4425 #define MAXFILE (NDIRECT + NINDIRECT)
4426 
4427 
4428 struct dinode {
4429   short type;           
4430   short major;          
4431   short minor;          
4432   short nlink;          
4433   uint size;            
4434   uint addrs[NDIRECT+1];   
4435 };
4436 
4437 
4438 
4439 
4440 
4441 
4442 
4443 
4444 
4445 
4446 
4447 
4448 
4449 
4450 
4451 #define IPB           (BSIZE / sizeof(struct dinode))
4452 
4453 
4454 #define IBLOCK(i, sb)     ((i) / IPB + sb.inodestart)
4455 
4456 
4457 #define BPB           (BSIZE*8)
4458 
4459 
4460 #define BBLOCK(b, sb) (b/BPB + sb.bmapstart)
4461 
4462 
4463 #define DIRSIZ 14
4464 
4465 struct dirent {
4466   ushort inum;
4467   char name[DIRSIZ];
4468 };
4469 
4470 
4471 
4472 
4473 
4474 
4475 
4476 
4477 
4478 
4479 
4480 
4481 
4482 
4483 
4484 
4485 
4486 
4487 
4488 
4489 
4490 
4491 
4492 
4493 
4494 
4495 
4496 
4497 
4498 
4499 
4500 struct file {
4501   enum { FD_NONE, FD_PIPE, FD_INODE } type;
4502   int ref; 
4503   char readable;
4504   char writable;
4505   struct pipe *pipe;
4506   struct inode *ip;
4507   uint off;
4508 };
4509 
4510 
4511 
4512 struct inode {
4513   uint dev;           
4514   uint inum;          
4515   int ref;            
4516   struct sleeplock lock; 
4517   int valid;          
4518 
4519   short type;         
4520   short major;
4521   short minor;
4522   short nlink;
4523   uint size;
4524   uint addrs[NDIRECT+1];
4525 };
4526 
4527 
4528 
4529 struct devsw {
4530   int (*read)(struct inode*, char*, int);
4531   int (*write)(struct inode*, char*, int);
4532 };
4533 
4534 extern struct devsw devsw[];
4535 
4536 #define CONSOLE 1
4537 
4538 
4539 
4540 
4541 
4542 
4543 
4544 
4545 
4546 
4547 
4548 
4549 
4550 
4551 
4552 #include "types.h"
4553 #include "defs.h"
4554 #include "param.h"
4555 #include "memlayout.h"
4556 #include "mmu.h"
4557 #include "proc.h"
4558 #include "x86.h"
4559 #include "traps.h"
4560 #include "spinlock.h"
4561 #include "sleeplock.h"
4562 #include "fs.h"
4563 #include "buf.h"
4564 
4565 #define SECTOR_SIZE   512
4566 #define IDE_BSY       0x80
4567 #define IDE_DRDY      0x40
4568 #define IDE_DF        0x20
4569 #define IDE_ERR       0x01
4570 
4571 #define IDE_CMD_READ  0x20
4572 #define IDE_CMD_WRITE 0x30
4573 #define IDE_CMD_RDMUL 0xc4
4574 #define IDE_CMD_WRMUL 0xc5
4575 
4576 
4577 
4578 
4579 
4580 static struct spinlock idelock;
4581 static struct buf *idequeue;
4582 
4583 static int havedisk1;
4584 static void idestart(struct buf*);
4585 
4586 
4587 static int
4588 idewait(int checkerr)
4589 {
4590   int r;
4591 
4592   while(((r = inb(0x1f7)) & (IDE_BSY|IDE_DRDY)) != IDE_DRDY)
4593     ;
4594   if(checkerr && (r & (IDE_DF|IDE_ERR)) != 0)
4595     return -1;
4596   return 0;
4597 }
4598 
4599 
4600 void
4601 ideinit(void)
4602 {
4603   int i;
4604 
4605   initlock(&idelock, "ide");
4606   ioapicenable(IRQ_IDE, ncpu - 1);
4607   idewait(0);
4608 
4609   
4610   outb(0x1f6, 0xe0 | (1<<4));
4611   for(i=0; i<1000; i++){
4612     if(inb(0x1f7) != 0){
4613       havedisk1 = 1;
4614       break;
4615     }
4616   }
4617 
4618   
4619   outb(0x1f6, 0xe0 | (0<<4));
4620 }
4621 
4622 
4623 static void
4624 idestart(struct buf *b)
4625 {
4626   if(b == 0)
4627     panic("idestart");
4628   if(b->blockno >= FSSIZE)
4629     panic("incorrect blockno");
4630   int sector_per_block =  BSIZE/SECTOR_SIZE;
4631   int sector = b->blockno * sector_per_block;
4632   int read_cmd = (sector_per_block == 1) ? IDE_CMD_READ :  IDE_CMD_RDMUL;
4633   int write_cmd = (sector_per_block == 1) ? IDE_CMD_WRITE : IDE_CMD_WRMUL;
4634 
4635   if (sector_per_block > 7) panic("idestart");
4636 
4637   idewait(0);
4638   outb(0x3f6, 0);  
4639   outb(0x1f2, sector_per_block);  
4640   outb(0x1f3, sector & 0xff);
4641   outb(0x1f4, (sector >> 8) & 0xff);
4642   outb(0x1f5, (sector >> 16) & 0xff);
4643   outb(0x1f6, 0xe0 | ((b->dev&1)<<4) | ((sector>>24)&0x0f));
4644   if(b->flags & B_DIRTY){
4645     outb(0x1f7, write_cmd);
4646     outsl(0x1f0, b->data, BSIZE/4);
4647   } else {
4648     outb(0x1f7, read_cmd);
4649   }
4650 }
4651 
4652 
4653 void
4654 ideintr(void)
4655 {
4656   struct buf *b;
4657 
4658   
4659   acquire(&idelock);
4660 
4661   if((b = idequeue) == 0){
4662     release(&idelock);
4663     return;
4664   }
4665   idequeue = b->qnext;
4666 
4667   
4668   if(!(b->flags & B_DIRTY) && idewait(1) >= 0)
4669     insl(0x1f0, b->data, BSIZE/4);
4670 
4671   
4672   b->flags |= B_VALID;
4673   b->flags &= ~B_DIRTY;
4674   wakeup(b);
4675 
4676   
4677   if(idequeue != 0)
4678     idestart(idequeue);
4679 
4680   release(&idelock);
4681 }
4682 
4683 
4684 
4685 
4686 
4687 
4688 
4689 
4690 
4691 
4692 
4693 
4694 
4695 
4696 
4697 
4698 
4699 
4700 
4701 
4702 
4703 void
4704 iderw(struct buf *b)
4705 {
4706   struct buf **pp;
4707 
4708   if(!holdingsleep(&b->lock))
4709     panic("iderw: buf not locked");
4710   if((b->flags & (B_VALID|B_DIRTY)) == B_VALID)
4711     panic("iderw: nothing to do");
4712   if(b->dev != 0 && !havedisk1)
4713     panic("iderw: ide disk 1 not present");
4714 
4715   acquire(&idelock);  
4716 
4717   
4718   b->qnext = 0;
4719   for(pp=&idequeue; *pp; pp=&(*pp)->qnext)  
4720     ;
4721   *pp = b;
4722 
4723   
4724   if(idequeue == b)
4725     idestart(b);
4726 
4727   
4728   while((b->flags & (B_VALID|B_DIRTY)) != B_VALID){
4729     sleep(b, &idelock);
4730   }
4731 
4732 
4733   release(&idelock);
4734 }
4735 
4736 
4737 
4738 
4739 
4740 
4741 
4742 
4743 
4744 
4745 
4746 
4747 
4748 
4749 
4750 
4751 
4752 
4753 
4754 
4755 
4756 
4757 
4758 
4759 
4760 
4761 
4762 
4763 
4764 
4765 
4766 
4767 
4768 
4769 
4770 #include "types.h"
4771 #include "defs.h"
4772 #include "param.h"
4773 #include "spinlock.h"
4774 #include "sleeplock.h"
4775 #include "fs.h"
4776 #include "buf.h"
4777 
4778 struct {
4779   struct spinlock lock;
4780   struct buf buf[NBUF];
4781 
4782   
4783   
4784   struct buf head;
4785 } bcache;
4786 
4787 void
4788 binit(void)
4789 {
4790   struct buf *b;
4791 
4792   initlock(&bcache.lock, "bcache");
4793 
4794 
4795 
4796 
4797 
4798 
4799 
4800   
4801   bcache.head.prev = &bcache.head;
4802   bcache.head.next = &bcache.head;
4803   for(b = bcache.buf; b < bcache.buf+NBUF; b++){
4804     b->next = bcache.head.next;
4805     b->prev = &bcache.head;
4806     initsleeplock(&b->lock, "buffer");
4807     bcache.head.next->prev = b;
4808     bcache.head.next = b;
4809   }
4810 }
4811 
4812 
4813 
4814 
4815 static struct buf*
4816 bget(uint dev, uint blockno)
4817 {
4818   struct buf *b;
4819 
4820   acquire(&bcache.lock);
4821 
4822   
4823   for(b = bcache.head.next; b != &bcache.head; b = b->next){
4824     if(b->dev == dev && b->blockno == blockno){
4825       b->refcnt++;
4826       release(&bcache.lock);
4827       acquiresleep(&b->lock);
4828       return b;
4829     }
4830   }
4831 
4832   
4833   
4834   
4835   for(b = bcache.head.prev; b != &bcache.head; b = b->prev){
4836     if(b->refcnt == 0 && (b->flags & B_DIRTY) == 0) {
4837       b->dev = dev;
4838       b->blockno = blockno;
4839       b->flags = 0;
4840       b->refcnt = 1;
4841       release(&bcache.lock);
4842       acquiresleep(&b->lock);
4843       return b;
4844     }
4845   }
4846   panic("bget: no buffers");
4847 }
4848 
4849 
4850 
4851 struct buf*
4852 bread(uint dev, uint blockno)
4853 {
4854   struct buf *b;
4855 
4856   b = bget(dev, blockno);
4857   if((b->flags & B_VALID) == 0) {
4858     iderw(b);
4859   }
4860   return b;
4861 }
4862 
4863 
4864 void
4865 bwrite(struct buf *b)
4866 {
4867   if(!holdingsleep(&b->lock))
4868     panic("bwrite");
4869   b->flags |= B_DIRTY;
4870   iderw(b);
4871 }
4872 
4873 
4874 
4875 void
4876 brelse(struct buf *b)
4877 {
4878   if(!holdingsleep(&b->lock))
4879     panic("brelse");
4880 
4881   releasesleep(&b->lock);
4882 
4883   acquire(&bcache.lock);
4884   b->refcnt--;
4885   if (b->refcnt == 0) {
4886     
4887     b->next->prev = b->prev;
4888     b->prev->next = b->next;
4889     b->next = bcache.head.next;
4890     b->prev = &bcache.head;
4891     bcache.head.next->prev = b;
4892     bcache.head.next = b;
4893   }
4894 
4895   release(&bcache.lock);
4896 }
4897 
4898 
4899 
4900 
4901 
4902 
4903 
4904 
4905 
4906 
4907 
4908 
4909 
4910 
4911 
4912 
4913 
4914 
4915 
4916 
4917 
4918 
4919 
4920 
4921 
4922 
4923 
4924 
4925 
4926 
4927 
4928 
4929 
4930 
4931 
4932 
4933 
4934 
4935 
4936 
4937 
4938 
4939 
4940 
4941 
4942 
4943 
4944 
4945 
4946 
4947 
4948 
4949 
4950 
4951 
4952 #include "types.h"
4953 #include "defs.h"
4954 #include "param.h"
4955 #include "x86.h"
4956 #include "memlayout.h"
4957 #include "mmu.h"
4958 #include "proc.h"
4959 #include "spinlock.h"
4960 #include "sleeplock.h"
4961 
4962 void
4963 initsleeplock(struct sleeplock *lk, char *name)
4964 {
4965   initlock(&lk->lk, "sleep lock");
4966   lk->name = name;
4967   lk->locked = 0;
4968   lk->pid = 0;
4969 }
4970 
4971 void
4972 acquiresleep(struct sleeplock *lk)
4973 {
4974   acquire(&lk->lk);
4975   while (lk->locked) {
4976     sleep(lk, &lk->lk);
4977   }
4978   lk->locked = 1;
4979   lk->pid = myproc()->pid;
4980   release(&lk->lk);
4981 }
4982 
4983 void
4984 releasesleep(struct sleeplock *lk)
4985 {
4986   acquire(&lk->lk);
4987   lk->locked = 0;
4988   lk->pid = 0;
4989   wakeup(lk);
4990   release(&lk->lk);
4991 }
4992 
4993 
4994 
4995 
4996 
4997 
4998 
4999 
5000 int
5001 holdingsleep(struct sleeplock *lk)
5002 {
5003   int r;
5004 
5005   acquire(&lk->lk);
5006   r = lk->locked && (lk->pid == myproc()->pid);
5007   release(&lk->lk);
5008   return r;
5009 }
5010 
5011 
5012 
5013 
5014 
5015 
5016 
5017 
5018 
5019 
5020 
5021 
5022 
5023 
5024 
5025 
5026 
5027 
5028 
5029 
5030 
5031 
5032 
5033 
5034 
5035 
5036 
5037 
5038 
5039 
5040 
5041 
5042 
5043 
5044 
5045 
5046 
5047 
5048 
5049 
5050 #include "types.h"
5051 #include "defs.h"
5052 #include "param.h"
5053 #include "spinlock.h"
5054 #include "sleeplock.h"
5055 #include "fs.h"
5056 #include "buf.h"
5057 
5058 
5059 
5060 
5061 
5062 
5063 
5064 
5065 
5066 
5067 
5068 
5069 
5070 
5071 
5072 
5073 
5074 
5075 
5076 
5077 
5078 
5079 
5080 
5081 
5082 
5083 struct logheader {
5084   int n;
5085   int block[LOGSIZE];
5086 };
5087 
5088 struct log {
5089   struct spinlock lock;
5090   int start;
5091   int size;
5092   int outstanding; 
5093   int committing;  
5094   int dev;
5095   struct logheader lh;
5096 };
5097 
5098 
5099 
5100 struct log log;
5101 
5102 static void recover_from_log(void);
5103 static void commit();
5104 
5105 void
5106 initlog(int dev)
5107 {
5108   if (sizeof(struct logheader) >= BSIZE)
5109     panic("initlog: too big logheader");
5110 
5111   struct superblock sb;
5112   initlock(&log.lock, "log");
5113   readsb(dev, &sb);
5114   log.start = sb.logstart;
5115   log.size = sb.nlog;
5116   log.dev = dev;
5117   recover_from_log();
5118 }
5119 
5120 
5121 static void
5122 install_trans(void)
5123 {
5124   int tail;
5125 
5126   for (tail = 0; tail < log.lh.n; tail++) {
5127     struct buf *lbuf = bread(log.dev, log.start+tail+1); 
5128     struct buf *dbuf = bread(log.dev, log.lh.block[tail]); 
5129     memmove(dbuf->data, lbuf->data, BSIZE);  
5130     bwrite(dbuf);  
5131     brelse(lbuf);
5132     brelse(dbuf);
5133   }
5134 }
5135 
5136 
5137 static void
5138 read_head(void)
5139 {
5140   struct buf *buf = bread(log.dev, log.start);
5141   struct logheader *lh = (struct logheader *) (buf->data);
5142   int i;
5143   log.lh.n = lh->n;
5144   for (i = 0; i < log.lh.n; i++) {
5145     log.lh.block[i] = lh->block[i];
5146   }
5147   brelse(buf);
5148 }
5149 
5150 
5151 
5152 
5153 static void
5154 write_head(void)
5155 {
5156   struct buf *buf = bread(log.dev, log.start);
5157   struct logheader *hb = (struct logheader *) (buf->data);
5158   int i;
5159   hb->n = log.lh.n;
5160   for (i = 0; i < log.lh.n; i++) {
5161     hb->block[i] = log.lh.block[i];
5162   }
5163   bwrite(buf);
5164   brelse(buf);
5165 }
5166 
5167 static void
5168 recover_from_log(void)
5169 {
5170   read_head();
5171   install_trans(); 
5172   log.lh.n = 0;
5173   write_head(); 
5174 }
5175 
5176 
5177 void
5178 begin_op(void)
5179 {
5180   acquire(&log.lock);
5181   while(1){
5182     if(log.committing){
5183       sleep(&log, &log.lock);
5184     } else if(log.lh.n + (log.outstanding+1)*MAXOPBLOCKS > LOGSIZE){
5185       
5186       sleep(&log, &log.lock);
5187     } else {
5188       log.outstanding += 1;
5189       release(&log.lock);
5190       break;
5191     }
5192   }
5193 }
5194 
5195 
5196 
5197 
5198 
5199 
5200 
5201 
5202 void
5203 end_op(void)
5204 {
5205   int do_commit = 0;
5206 
5207   acquire(&log.lock);
5208   log.outstanding -= 1;
5209   if(log.committing)
5210     panic("log.committing");
5211   if(log.outstanding == 0){
5212     do_commit = 1;
5213     log.committing = 1;
5214   } else {
5215     
5216     
5217     
5218     wakeup(&log);
5219   }
5220   release(&log.lock);
5221 
5222   if(do_commit){
5223     
5224     
5225     commit();
5226     acquire(&log.lock);
5227     log.committing = 0;
5228     wakeup(&log);
5229     release(&log.lock);
5230   }
5231 }
5232 
5233 
5234 static void
5235 write_log(void)
5236 {
5237   int tail;
5238 
5239   for (tail = 0; tail < log.lh.n; tail++) {
5240     struct buf *to = bread(log.dev, log.start+tail+1); 
5241     struct buf *from = bread(log.dev, log.lh.block[tail]); 
5242     memmove(to->data, from->data, BSIZE);
5243     bwrite(to);  
5244     brelse(from);
5245     brelse(to);
5246   }
5247 }
5248 
5249 
5250 static void
5251 commit()
5252 {
5253   if (log.lh.n > 0) {
5254     write_log();     
5255     write_head();    
5256     install_trans(); 
5257     log.lh.n = 0;
5258     write_head();    
5259   }
5260 }
5261 
5262 
5263 
5264 
5265 
5266 
5267 
5268 
5269 
5270 
5271 void
5272 log_write(struct buf *b)
5273 {
5274   int i;
5275 
5276   if (log.lh.n >= LOGSIZE || log.lh.n >= log.size - 1)
5277     panic("too big a transaction");
5278   if (log.outstanding < 1)
5279     panic("log_write outside of trans");
5280 
5281   acquire(&log.lock);
5282   for (i = 0; i < log.lh.n; i++) {
5283     if (log.lh.block[i] == b->blockno)   
5284       break;
5285   }
5286   log.lh.block[i] = b->blockno;
5287   if (i == log.lh.n)
5288     log.lh.n++;
5289   b->flags |= B_DIRTY; 
5290   release(&log.lock);
5291 }
5292 
5293 
5294 
5295 
5296 
5297 
5298 
5299 
5300 
5301 
5302 
5303 
5304 
5305 
5306 
5307 
5308 
5309 
5310 
5311 #include "types.h"
5312 #include "defs.h"
5313 #include "param.h"
5314 #include "stat.h"
5315 #include "mmu.h"
5316 #include "proc.h"
5317 #include "spinlock.h"
5318 #include "sleeplock.h"
5319 #include "fs.h"
5320 #include "buf.h"
5321 #include "file.h"
5322 
5323 #define min(a, b) ((a) < (b) ? (a) : (b))
5324 static void itrunc(struct inode*);
5325 
5326 
5327 struct superblock sb;
5328 
5329 
5330 void
5331 readsb(int dev, struct superblock *sb)
5332 {
5333   struct buf *bp;
5334 
5335   bp = bread(dev, 1);
5336   memmove(sb, bp->data, sizeof(*sb));
5337   brelse(bp);
5338 }
5339 
5340 
5341 
5342 
5343 
5344 
5345 
5346 
5347 
5348 
5349 
5350 
5351 static void
5352 bzero(int dev, int bno)
5353 {
5354   struct buf *bp;
5355 
5356   bp = bread(dev, bno);
5357   memset(bp->data, 0, BSIZE);
5358   log_write(bp);
5359   brelse(bp);
5360 }
5361 
5362 
5363 
5364 
5365 static uint
5366 balloc(uint dev)
5367 {
5368   int b, bi, m;
5369   struct buf *bp;
5370 
5371   bp = 0;
5372   for(b = 0; b < sb.size; b += BPB){
5373     bp = bread(dev, BBLOCK(b, sb));
5374     for(bi = 0; bi < BPB && b + bi < sb.size; bi++){
5375       m = 1 << (bi % 8);
5376       if((bp->data[bi/8] & m) == 0){  
5377         bp->data[bi/8] |= m;  
5378         log_write(bp);
5379         brelse(bp);
5380         bzero(dev, b + bi);
5381         return b + bi;
5382       }
5383     }
5384     brelse(bp);
5385   }
5386   panic("balloc: out of blocks");
5387 }
5388 
5389 
5390 
5391 
5392 
5393 
5394 
5395 
5396 
5397 
5398 
5399 
5400 
5401 static void
5402 bfree(int dev, uint b)
5403 {
5404   struct buf *bp;
5405   int bi, m;
5406 
5407   bp = bread(dev, BBLOCK(b, sb));
5408   bi = b % BPB;
5409   m = 1 << (bi % 8);
5410   if((bp->data[bi/8] & m) == 0)
5411     panic("freeing free block");
5412   bp->data[bi/8] &= ~m;
5413   log_write(bp);
5414   brelse(bp);
5415 }
5416 
5417 
5418 
5419 
5420 
5421 
5422 
5423 
5424 
5425 
5426 
5427 
5428 
5429 
5430 
5431 
5432 
5433 
5434 
5435 
5436 
5437 
5438 
5439 
5440 
5441 
5442 
5443 
5444 
5445 
5446 
5447 
5448 
5449 
5450 
5451 
5452 
5453 
5454 
5455 
5456 
5457 
5458 
5459 
5460 
5461 
5462 
5463 
5464 
5465 
5466 
5467 
5468 
5469 
5470 
5471 
5472 
5473 
5474 
5475 
5476 
5477 
5478 
5479 
5480 
5481 
5482 
5483 
5484 
5485 
5486 struct {
5487   struct spinlock lock;
5488   struct inode inode[NINODE];
5489 } icache;
5490 
5491 void
5492 iinit(int dev)
5493 {
5494   int i = 0;
5495 
5496   initlock(&icache.lock, "icache");
5497   for(i = 0; i < NINODE; i++) {
5498     initsleeplock(&icache.inode[i].lock, "inode");
5499   }
5500   readsb(dev, &sb);
5501   cprintf("sb: size %d nblocks %d ninodes %d nlog %d logstart %d\
5502  inodestart %d bmap start %d\n", sb.size, sb.nblocks,
5503           sb.ninodes, sb.nlog, sb.logstart, sb.inodestart,
5504           sb.bmapstart);
5505 }
5506 
5507 static struct inode* iget(uint dev, uint inum);
5508 
5509 
5510 
5511 
5512 
5513 
5514 
5515 
5516 
5517 
5518 
5519 
5520 
5521 
5522 
5523 
5524 
5525 
5526 
5527 
5528 
5529 
5530 
5531 
5532 
5533 
5534 
5535 
5536 
5537 
5538 
5539 
5540 
5541 
5542 
5543 
5544 
5545 
5546 
5547 
5548 
5549 
5550 
5551 
5552 
5553 struct inode*
5554 ialloc(uint dev, short type)
5555 {
5556   int inum;
5557   struct buf *bp;
5558   struct dinode *dip;
5559 
5560   for(inum = 1; inum < sb.ninodes; inum++){
5561     bp = bread(dev, IBLOCK(inum, sb));
5562     dip = (struct dinode*)bp->data + inum%IPB;
5563     if(dip->type == 0){  
5564       memset(dip, 0, sizeof(*dip));
5565       dip->type = type;
5566       log_write(bp);   
5567       brelse(bp);
5568       return iget(dev, inum);
5569     }
5570     brelse(bp);
5571   }
5572   panic("ialloc: no inodes");
5573 }
5574 
5575 
5576 
5577 
5578 
5579 void
5580 iupdate(struct inode *ip)
5581 {
5582   struct buf *bp;
5583   struct dinode *dip;
5584 
5585   bp = bread(ip->dev, IBLOCK(ip->inum, sb));
5586   dip = (struct dinode*)bp->data + ip->inum%IPB;
5587   dip->type = ip->type;
5588   dip->major = ip->major;
5589   dip->minor = ip->minor;
5590   dip->nlink = ip->nlink;
5591   dip->size = ip->size;
5592   memmove(dip->addrs, ip->addrs, sizeof(ip->addrs));
5593   log_write(bp);
5594   brelse(bp);
5595 }
5596 
5597 
5598 
5599 
5600 
5601 
5602 
5603 static struct inode*
5604 iget(uint dev, uint inum)
5605 {
5606   struct inode *ip, *empty;
5607 
5608   acquire(&icache.lock);
5609 
5610   
5611   empty = 0;
5612   for(ip = &icache.inode[0]; ip < &icache.inode[NINODE]; ip++){
5613     if(ip->ref > 0 && ip->dev == dev && ip->inum == inum){
5614       ip->ref++;
5615       release(&icache.lock);
5616       return ip;
5617     }
5618     if(empty == 0 && ip->ref == 0)    
5619       empty = ip;
5620   }
5621 
5622   
5623   if(empty == 0)
5624     panic("iget: no inodes");
5625 
5626   ip = empty;
5627   ip->dev = dev;
5628   ip->inum = inum;
5629   ip->ref = 1;
5630   ip->valid = 0;
5631   release(&icache.lock);
5632 
5633   return ip;
5634 }
5635 
5636 
5637 
5638 struct inode*
5639 idup(struct inode *ip)
5640 {
5641   acquire(&icache.lock);
5642   ip->ref++;
5643   release(&icache.lock);
5644   return ip;
5645 }
5646 
5647 
5648 
5649 
5650 
5651 
5652 void
5653 ilock(struct inode *ip)
5654 {
5655   struct buf *bp;
5656   struct dinode *dip;
5657 
5658   if(ip == 0 || ip->ref < 1)
5659     panic("ilock");
5660 
5661   acquiresleep(&ip->lock);
5662 
5663   if(ip->valid == 0){
5664     bp = bread(ip->dev, IBLOCK(ip->inum, sb));
5665     dip = (struct dinode*)bp->data + ip->inum%IPB;
5666     ip->type = dip->type;
5667     ip->major = dip->major;
5668     ip->minor = dip->minor;
5669     ip->nlink = dip->nlink;
5670     ip->size = dip->size;
5671     memmove(ip->addrs, dip->addrs, sizeof(ip->addrs));
5672     brelse(bp);
5673     ip->valid = 1;
5674     if(ip->type == 0)
5675       panic("ilock: no type");
5676   }
5677 }
5678 
5679 
5680 void
5681 iunlock(struct inode *ip)
5682 {
5683   if(ip == 0 || !holdingsleep(&ip->lock) || ip->ref < 1)
5684     panic("iunlock");
5685 
5686   releasesleep(&ip->lock);
5687 }
5688 
5689 
5690 
5691 
5692 
5693 
5694 
5695 
5696 
5697 
5698 
5699 
5700 
5701 
5702 
5703 
5704 
5705 
5706 
5707 void
5708 iput(struct inode *ip)
5709 {
5710   acquiresleep(&ip->lock);
5711   if(ip->valid && ip->nlink == 0){
5712     acquire(&icache.lock);
5713     int r = ip->ref;
5714     release(&icache.lock);
5715     if(r == 1){
5716       
5717       itrunc(ip);
5718       ip->type = 0;
5719       iupdate(ip);
5720       ip->valid = 0;
5721     }
5722   }
5723   releasesleep(&ip->lock);
5724 
5725   acquire(&icache.lock);
5726   ip->ref--;
5727   release(&icache.lock);
5728 }
5729 
5730 
5731 void
5732 iunlockput(struct inode *ip)
5733 {
5734   iunlock(ip);
5735   iput(ip);
5736 }
5737 
5738 
5739 
5740 
5741 
5742 
5743 
5744 
5745 
5746 
5747 
5748 
5749 
5750 
5751 
5752 
5753 
5754 
5755 
5756 
5757 
5758 
5759 static uint
5760 bmap(struct inode *ip, uint bn)
5761 {
5762   uint addr, *a;
5763   struct buf *bp;
5764 
5765   if(bn < NDIRECT){
5766     if((addr = ip->addrs[bn]) == 0)
5767       ip->addrs[bn] = addr = balloc(ip->dev);
5768     return addr;
5769   }
5770   bn -= NDIRECT;
5771 
5772   if(bn < NINDIRECT){
5773     
5774     if((addr = ip->addrs[NDIRECT]) == 0)
5775       ip->addrs[NDIRECT] = addr = balloc(ip->dev);
5776     bp = bread(ip->dev, addr);
5777     a = (uint*)bp->data;
5778     if((addr = a[bn]) == 0){
5779       a[bn] = addr = balloc(ip->dev);
5780       log_write(bp);
5781     }
5782     brelse(bp);
5783     return addr;
5784   }
5785 
5786   panic("bmap: out of range");
5787 }
5788 
5789 
5790 
5791 
5792 
5793 
5794 
5795 
5796 
5797 
5798 
5799 
5800 
5801 
5802 
5803 
5804 
5805 static void
5806 itrunc(struct inode *ip)
5807 {
5808   int i, j;
5809   struct buf *bp;
5810   uint *a;
5811 
5812   for(i = 0; i < NDIRECT; i++){
5813     if(ip->addrs[i]){
5814       bfree(ip->dev, ip->addrs[i]);
5815       ip->addrs[i] = 0;
5816     }
5817   }
5818 
5819   if(ip->addrs[NDIRECT]){
5820     bp = bread(ip->dev, ip->addrs[NDIRECT]);
5821     a = (uint*)bp->data;
5822     for(j = 0; j < NINDIRECT; j++){
5823       if(a[j])
5824         bfree(ip->dev, a[j]);
5825     }
5826     brelse(bp);
5827     bfree(ip->dev, ip->addrs[NDIRECT]);
5828     ip->addrs[NDIRECT] = 0;
5829   }
5830 
5831   ip->size = 0;
5832   iupdate(ip);
5833 }
5834 
5835 
5836 
5837 void
5838 stati(struct inode *ip, struct stat *st)
5839 {
5840   st->dev = ip->dev;
5841   st->ino = ip->inum;
5842   st->type = ip->type;
5843   st->nlink = ip->nlink;
5844   st->size = ip->size;
5845 }
5846 
5847 
5848 
5849 
5850 
5851 
5852 int
5853 readi(struct inode *ip, char *dst, uint off, uint n)
5854 {
5855   uint tot, m;
5856   struct buf *bp;
5857 
5858   if(ip->type == T_DEV){
5859     if(ip->major < 0 || ip->major >= NDEV || !devsw[ip->major].read)
5860       return -1;
5861     return devsw[ip->major].read(ip, dst, n);
5862   }
5863 
5864   if(off > ip->size || off + n < off)
5865     return -1;
5866   if(off + n > ip->size)
5867     n = ip->size - off;
5868 
5869   for(tot=0; tot<n; tot+=m, off+=m, dst+=m){
5870     bp = bread(ip->dev, bmap(ip, off/BSIZE));
5871     m = min(n - tot, BSIZE - off%BSIZE);
5872     memmove(dst, bp->data + off%BSIZE, m);
5873     brelse(bp);
5874   }
5875   return n;
5876 }
5877 
5878 
5879 
5880 
5881 
5882 
5883 
5884 
5885 
5886 
5887 
5888 
5889 
5890 
5891 
5892 
5893 
5894 
5895 
5896 
5897 
5898 
5899 
5900 
5901 
5902 int
5903 writei(struct inode *ip, char *src, uint off, uint n)
5904 {
5905   uint tot, m;
5906   struct buf *bp;
5907 
5908   if(ip->type == T_DEV){
5909     if(ip->major < 0 || ip->major >= NDEV || !devsw[ip->major].write)
5910       return -1;
5911     return devsw[ip->major].write(ip, src, n);
5912   }
5913 
5914   if(off > ip->size || off + n < off)
5915     return -1;
5916   if(off + n > MAXFILE*BSIZE)
5917     return -1;
5918 
5919   for(tot=0; tot<n; tot+=m, off+=m, src+=m){
5920     bp = bread(ip->dev, bmap(ip, off/BSIZE));
5921     m = min(n - tot, BSIZE - off%BSIZE);
5922     memmove(bp->data + off%BSIZE, src, m);
5923     log_write(bp);
5924     brelse(bp);
5925   }
5926 
5927   if(n > 0 && off > ip->size){
5928     ip->size = off;
5929     iupdate(ip);
5930   }
5931   return n;
5932 }
5933 
5934 
5935 
5936 
5937 
5938 
5939 
5940 
5941 
5942 
5943 
5944 
5945 
5946 
5947 
5948 
5949 
5950 
5951 
5952 int
5953 namecmp(const char *s, const char *t)
5954 {
5955   return strncmp(s, t, DIRSIZ);
5956 }
5957 
5958 
5959 
5960 struct inode*
5961 dirlookup(struct inode *dp, char *name, uint *poff)
5962 {
5963   uint off, inum;
5964   struct dirent de;
5965 
5966   if(dp->type != T_DIR)
5967     panic("dirlookup not DIR");
5968 
5969   for(off = 0; off < dp->size; off += sizeof(de)){
5970     if(readi(dp, (char*)&de, off, sizeof(de)) != sizeof(de))
5971       panic("dirlookup read");
5972     if(de.inum == 0)
5973       continue;
5974     if(namecmp(name, de.name) == 0){
5975       
5976       if(poff)
5977         *poff = off;
5978       inum = de.inum;
5979       return iget(dp->dev, inum);
5980     }
5981   }
5982 
5983   return 0;
5984 }
5985 
5986 
5987 
5988 
5989 
5990 
5991 
5992 
5993 
5994 
5995 
5996 
5997 
5998 
5999 
6000 
6001 int
6002 dirlink(struct inode *dp, char *name, uint inum)
6003 {
6004   int off;
6005   struct dirent de;
6006   struct inode *ip;
6007 
6008   
6009   if((ip = dirlookup(dp, name, 0)) != 0){
6010     iput(ip);
6011     return -1;
6012   }
6013 
6014   
6015   for(off = 0; off < dp->size; off += sizeof(de)){
6016     if(readi(dp, (char*)&de, off, sizeof(de)) != sizeof(de))
6017       panic("dirlink read");
6018     if(de.inum == 0)
6019       break;
6020   }
6021 
6022   strncpy(de.name, name, DIRSIZ);
6023   de.inum = inum;
6024   if(writei(dp, (char*)&de, off, sizeof(de)) != sizeof(de))
6025     panic("dirlink");
6026 
6027   return 0;
6028 }
6029 
6030 
6031 
6032 
6033 
6034 
6035 
6036 
6037 
6038 
6039 
6040 
6041 
6042 
6043 
6044 
6045 
6046 
6047 
6048 
6049 
6050 
6051 
6052 
6053 
6054 
6055 
6056 
6057 
6058 
6059 
6060 
6061 
6062 
6063 
6064 static char*
6065 skipelem(char *path, char *name)
6066 {
6067   char *s;
6068   int len;
6069 
6070   while(*path == '/')
6071     path++;
6072   if(*path == 0)
6073     return 0;
6074   s = path;
6075   while(*path != '/' && *path != 0)
6076     path++;
6077   len = path - s;
6078   if(len >= DIRSIZ)
6079     memmove(name, s, DIRSIZ);
6080   else {
6081     memmove(name, s, len);
6082     name[len] = 0;
6083   }
6084   while(*path == '/')
6085     path++;
6086   return path;
6087 }
6088 
6089 
6090 
6091 
6092 
6093 
6094 
6095 
6096 
6097 
6098 
6099 
6100 
6101 
6102 
6103 
6104 static struct inode*
6105 namex(char *path, int nameiparent, char *name)
6106 {
6107   struct inode *ip, *next;
6108 
6109   if(*path == '/')
6110     ip = iget(ROOTDEV, ROOTINO);
6111   else
6112     ip = idup(myproc()->cwd);
6113 
6114   while((path = skipelem(path, name)) != 0){
6115     ilock(ip);
6116     if(ip->type != T_DIR){
6117       iunlockput(ip);
6118       return 0;
6119     }
6120     if(nameiparent && *path == '\0'){
6121       
6122       iunlock(ip);
6123       return ip;
6124     }
6125     if((next = dirlookup(ip, name, 0)) == 0){
6126       iunlockput(ip);
6127       return 0;
6128     }
6129     iunlockput(ip);
6130     ip = next;
6131   }
6132   if(nameiparent){
6133     iput(ip);
6134     return 0;
6135   }
6136   return ip;
6137 }
6138 
6139 struct inode*
6140 namei(char *path)
6141 {
6142   char name[DIRSIZ];
6143   return namex(path, 0, name);
6144 }
6145 
6146 
6147 
6148 
6149 
6150 struct inode*
6151 nameiparent(char *path, char *name)
6152 {
6153   return namex(path, 1, name);
6154 }
6155 
6156 
6157 
6158 
6159 
6160 
6161 
6162 
6163 
6164 
6165 
6166 
6167 
6168 
6169 
6170 
6171 
6172 
6173 
6174 
6175 
6176 
6177 
6178 
6179 
6180 
6181 
6182 
6183 
6184 
6185 
6186 
6187 
6188 
6189 
6190 
6191 
6192 
6193 
6194 
6195 
6196 
6197 
6198 
6199 
6200 
6201 
6202 
6203 
6204 #include "types.h"
6205 #include "defs.h"
6206 #include "param.h"
6207 #include "fs.h"
6208 #include "spinlock.h"
6209 #include "sleeplock.h"
6210 #include "file.h"
6211 
6212 struct devsw devsw[NDEV];
6213 struct {
6214   struct spinlock lock;
6215   struct file file[NFILE];
6216 } ftable;
6217 
6218 void
6219 fileinit(void)
6220 {
6221   initlock(&ftable.lock, "ftable");
6222 }
6223 
6224 
6225 struct file*
6226 filealloc(void)
6227 {
6228   struct file *f;
6229 
6230   acquire(&ftable.lock);
6231   for(f = ftable.file; f < ftable.file + NFILE; f++){
6232     if(f->ref == 0){
6233       f->ref = 1;
6234       release(&ftable.lock);
6235       return f;
6236     }
6237   }
6238   release(&ftable.lock);
6239   return 0;
6240 }
6241 
6242 
6243 
6244 
6245 
6246 
6247 
6248 
6249 
6250 
6251 struct file*
6252 filedup(struct file *f)
6253 {
6254   acquire(&ftable.lock);
6255   if(f->ref < 1)
6256     panic("filedup");
6257   f->ref++;
6258   release(&ftable.lock);
6259   return f;
6260 }
6261 
6262 
6263 void
6264 fileclose(struct file *f)
6265 {
6266   struct file ff;
6267 
6268   acquire(&ftable.lock);
6269   if(f->ref < 1)
6270     panic("fileclose");
6271   if(--f->ref > 0){
6272     release(&ftable.lock);
6273     return;
6274   }
6275   ff = *f;
6276   f->ref = 0;
6277   f->type = FD_NONE;
6278   release(&ftable.lock);
6279 
6280   if(ff.type == FD_PIPE)
6281     pipeclose(ff.pipe, ff.writable);
6282   else if(ff.type == FD_INODE){
6283     begin_op();
6284     iput(ff.ip);
6285     end_op();
6286   }
6287 }
6288 
6289 
6290 
6291 
6292 
6293 
6294 
6295 
6296 
6297 
6298 
6299 
6300 
6301 int
6302 filestat(struct file *f, struct stat *st)
6303 {
6304   if(f->type == FD_INODE){
6305     ilock(f->ip);
6306     stati(f->ip, st);
6307     iunlock(f->ip);
6308     return 0;
6309   }
6310   return -1;
6311 }
6312 
6313 
6314 int
6315 fileread(struct file *f, char *addr, int n)
6316 {
6317   int r;
6318 
6319   if(f->readable == 0)
6320     return -1;
6321   if(f->type == FD_PIPE)
6322     return piperead(f->pipe, addr, n);
6323   if(f->type == FD_INODE){
6324     ilock(f->ip);
6325     if((r = readi(f->ip, addr, f->off, n)) > 0)
6326       f->off += r;
6327     iunlock(f->ip);
6328     return r;
6329   }
6330   panic("fileread");
6331 }
6332 
6333 
6334 
6335 
6336 
6337 
6338 
6339 
6340 
6341 
6342 
6343 
6344 
6345 
6346 
6347 
6348 
6349 
6350 
6351 int
6352 filewrite(struct file *f, char *addr, int n)
6353 {
6354   int r;
6355 
6356   if(f->writable == 0)
6357     return -1;
6358   if(f->type == FD_PIPE)
6359     return pipewrite(f->pipe, addr, n);
6360   if(f->type == FD_INODE){
6361     
6362     
6363     
6364     
6365     
6366     
6367     int max = ((MAXOPBLOCKS-1-1-2) / 2) * 512;
6368     int i = 0;
6369     while(i < n){
6370       int n1 = n - i;
6371       if(n1 > max)
6372         n1 = max;
6373 
6374       begin_op();
6375       ilock(f->ip);
6376       if ((r = writei(f->ip, addr + i, f->off, n1)) > 0)
6377         f->off += r;
6378       iunlock(f->ip);
6379       end_op();
6380 
6381       if(r < 0)
6382         break;
6383       if(r != n1)
6384         panic("short filewrite");
6385       i += r;
6386     }
6387     return i == n ? n : -1;
6388   }
6389   panic("filewrite");
6390 }
6391 
6392 
6393 
6394 
6395 
6396 
6397 
6398 
6399 
6400 
6401 
6402 
6403 
6404 
6405 
6406 #include "types.h"
6407 #include "defs.h"
6408 #include "param.h"
6409 #include "stat.h"
6410 #include "mmu.h"
6411 #include "proc.h"
6412 #include "fs.h"
6413 #include "spinlock.h"
6414 #include "sleeplock.h"
6415 #include "file.h"
6416 #include "fcntl.h"
6417 
6418 
6419 
6420 static int
6421 argfd(int n, int *pfd, struct file **pf)
6422 {
6423   int fd;
6424   struct file *f;
6425 
6426   if(argint(n, &fd) < 0)
6427     return -1;
6428   if(fd < 0 || fd >= NOFILE || (f=myproc()->ofile[fd]) == 0)
6429     return -1;
6430   if(pfd)
6431     *pfd = fd;
6432   if(pf)
6433     *pf = f;
6434   return 0;
6435 }
6436 
6437 
6438 
6439 
6440 
6441 
6442 
6443 
6444 
6445 
6446 
6447 
6448 
6449 
6450 
6451 
6452 static int
6453 fdalloc(struct file *f)
6454 {
6455   int fd;
6456   struct proc *curproc = myproc();
6457 
6458   for(fd = 0; fd < NOFILE; fd++){
6459     if(curproc->ofile[fd] == 0){
6460       curproc->ofile[fd] = f;
6461       return fd;
6462     }
6463   }
6464   return -1;
6465 }
6466 
6467 int
6468 sys_dup(void)
6469 {
6470   struct file *f;
6471   int fd;
6472 
6473   if(argfd(0, 0, &f) < 0)
6474     return -1;
6475   if((fd=fdalloc(f)) < 0)
6476     return -1;
6477   filedup(f);
6478   return fd;
6479 }
6480 
6481 int
6482 sys_read(void)
6483 {
6484   struct file *f;
6485   int n;
6486   char *p;
6487 
6488   if(argfd(0, 0, &f) < 0 || argint(2, &n) < 0 || argptr(1, &p, n) < 0)
6489     return -1;
6490   return fileread(f, p, n);
6491 }
6492 
6493 
6494 
6495 
6496 
6497 
6498 
6499 
6500 int
6501 sys_write(void)
6502 {
6503   struct file *f;
6504   int n;
6505   char *p;
6506 
6507   if(argfd(0, 0, &f) < 0 || argint(2, &n) < 0 || argptr(1, &p, n) < 0)
6508     return -1;
6509   return filewrite(f, p, n);
6510 }
6511 
6512 int
6513 sys_close(void)
6514 {
6515   int fd;
6516   struct file *f;
6517 
6518   if(argfd(0, &fd, &f) < 0)
6519     return -1;
6520   myproc()->ofile[fd] = 0;
6521   fileclose(f);
6522   return 0;
6523 }
6524 
6525 int
6526 sys_fstat(void)
6527 {
6528   struct file *f;
6529   struct stat *st;
6530 
6531   if(argfd(0, 0, &f) < 0 || argptr(1, (void*)&st, sizeof(*st)) < 0)
6532     return -1;
6533   return filestat(f, st);
6534 }
6535 
6536 
6537 
6538 
6539 
6540 
6541 
6542 
6543 
6544 
6545 
6546 
6547 
6548 
6549 
6550 
6551 int
6552 sys_link(void)
6553 {
6554   char name[DIRSIZ], *new, *old;
6555   struct inode *dp, *ip;
6556 
6557   if(argstr(0, &old) < 0 || argstr(1, &new) < 0)
6558     return -1;
6559 
6560   begin_op();
6561   if((ip = namei(old)) == 0){
6562     end_op();
6563     return -1;
6564   }
6565 
6566   ilock(ip);
6567   if(ip->type == T_DIR){
6568     iunlockput(ip);
6569     end_op();
6570     return -1;
6571   }
6572 
6573   ip->nlink++;
6574   iupdate(ip);
6575   iunlock(ip);
6576 
6577   if((dp = nameiparent(new, name)) == 0)
6578     goto bad;
6579   ilock(dp);
6580   if(dp->dev != ip->dev || dirlink(dp, name, ip->inum) < 0){
6581     iunlockput(dp);
6582     goto bad;
6583   }
6584   iunlockput(dp);
6585   iput(ip);
6586 
6587   end_op();
6588 
6589   return 0;
6590 
6591 bad:
6592   ilock(ip);
6593   ip->nlink--;
6594   iupdate(ip);
6595   iunlockput(ip);
6596   end_op();
6597   return -1;
6598 }
6599 
6600 
6601 static int
6602 isdirempty(struct inode *dp)
6603 {
6604   int off;
6605   struct dirent de;
6606 
6607   for(off=2*sizeof(de); off<dp->size; off+=sizeof(de)){
6608     if(readi(dp, (char*)&de, off, sizeof(de)) != sizeof(de))
6609       panic("isdirempty: readi");
6610     if(de.inum != 0)
6611       return 0;
6612   }
6613   return 1;
6614 }
6615 
6616 
6617 
6618 
6619 
6620 
6621 
6622 
6623 
6624 
6625 
6626 
6627 
6628 
6629 
6630 
6631 
6632 
6633 
6634 
6635 
6636 
6637 
6638 
6639 
6640 
6641 
6642 
6643 
6644 
6645 
6646 
6647 
6648 
6649 
6650 int
6651 sys_unlink(void)
6652 {
6653   struct inode *ip, *dp;
6654   struct dirent de;
6655   char name[DIRSIZ], *path;
6656   uint off;
6657 
6658   if(argstr(0, &path) < 0)
6659     return -1;
6660 
6661   begin_op();
6662   if((dp = nameiparent(path, name)) == 0){
6663     end_op();
6664     return -1;
6665   }
6666 
6667   ilock(dp);
6668 
6669   
6670   if(namecmp(name, ".") == 0 || namecmp(name, "..") == 0)
6671     goto bad;
6672 
6673   if((ip = dirlookup(dp, name, &off)) == 0)
6674     goto bad;
6675   ilock(ip);
6676 
6677   if(ip->nlink < 1)
6678     panic("unlink: nlink < 1");
6679   if(ip->type == T_DIR && !isdirempty(ip)){
6680     iunlockput(ip);
6681     goto bad;
6682   }
6683 
6684   memset(&de, 0, sizeof(de));
6685   if(writei(dp, (char*)&de, off, sizeof(de)) != sizeof(de))
6686     panic("unlink: writei");
6687   if(ip->type == T_DIR){
6688     dp->nlink--;
6689     iupdate(dp);
6690   }
6691   iunlockput(dp);
6692 
6693   ip->nlink--;
6694   iupdate(ip);
6695   iunlockput(ip);
6696 
6697   end_op();
6698 
6699   return 0;
6700 bad:
6701   iunlockput(dp);
6702   end_op();
6703   return -1;
6704 }
6705 
6706 static struct inode*
6707 create(char *path, short type, short major, short minor)
6708 {
6709   struct inode *ip, *dp;
6710   char name[DIRSIZ];
6711 
6712   if((dp = nameiparent(path, name)) == 0)
6713     return 0;
6714   ilock(dp);
6715 
6716   if((ip = dirlookup(dp, name, 0)) != 0){
6717     iunlockput(dp);
6718     ilock(ip);
6719     if(type == T_FILE && ip->type == T_FILE)
6720       return ip;
6721     iunlockput(ip);
6722     return 0;
6723   }
6724 
6725   if((ip = ialloc(dp->dev, type)) == 0)
6726     panic("create: ialloc");
6727 
6728   ilock(ip);
6729   ip->major = major;
6730   ip->minor = minor;
6731   ip->nlink = 1;
6732   iupdate(ip);
6733 
6734   if(type == T_DIR){  
6735     dp->nlink++;  
6736     iupdate(dp);
6737     
6738     if(dirlink(ip, ".", ip->inum) < 0 || dirlink(ip, "..", dp->inum) < 0)
6739       panic("create dots");
6740   }
6741 
6742   if(dirlink(dp, name, ip->inum) < 0)
6743     panic("create: dirlink");
6744 
6745   iunlockput(dp);
6746 
6747   return ip;
6748 }
6749 
6750 int
6751 sys_open(void)
6752 {
6753   char *path;
6754   int fd, omode;
6755   struct file *f;
6756   struct inode *ip;
6757 
6758   if(argstr(0, &path) < 0 || argint(1, &omode) < 0)
6759     return -1;
6760 
6761   begin_op();
6762 
6763   if(omode & O_CREATE){
6764     ip = create(path, T_FILE, 0, 0);
6765     if(ip == 0){
6766       end_op();
6767       return -1;
6768     }
6769   } else {
6770     if((ip = namei(path)) == 0){
6771       end_op();
6772       return -1;
6773     }
6774     ilock(ip);
6775     if(ip->type == T_DIR && omode != O_RDONLY){
6776       iunlockput(ip);
6777       end_op();
6778       return -1;
6779     }
6780   }
6781 
6782   if((f = filealloc()) == 0 || (fd = fdalloc(f)) < 0){
6783     if(f)
6784       fileclose(f);
6785     iunlockput(ip);
6786     end_op();
6787     return -1;
6788   }
6789   iunlock(ip);
6790   end_op();
6791 
6792   f->type = FD_INODE;
6793   f->ip = ip;
6794   f->off = 0;
6795   f->readable = !(omode & O_WRONLY);
6796   f->writable = (omode & O_WRONLY) || (omode & O_RDWR);
6797   return fd;
6798 }
6799 
6800 int
6801 sys_mkdir(void)
6802 {
6803   char *path;
6804   struct inode *ip;
6805 
6806   begin_op();
6807   if(argstr(0, &path) < 0 || (ip = create(path, T_DIR, 0, 0)) == 0){
6808     end_op();
6809     return -1;
6810   }
6811   iunlockput(ip);
6812   end_op();
6813   return 0;
6814 }
6815 
6816 int
6817 sys_mknod(void)
6818 {
6819   struct inode *ip;
6820   char *path;
6821   int major, minor;
6822 
6823   begin_op();
6824   if((argstr(0, &path)) < 0 ||
6825      argint(1, &major) < 0 ||
6826      argint(2, &minor) < 0 ||
6827      (ip = create(path, T_DEV, major, minor)) == 0){
6828     end_op();
6829     return -1;
6830   }
6831   iunlockput(ip);
6832   end_op();
6833   return 0;
6834 }
6835 
6836 
6837 
6838 
6839 
6840 
6841 
6842 
6843 
6844 
6845 
6846 
6847 
6848 
6849 
6850 int
6851 sys_chdir(void)
6852 {
6853   char *path;
6854   struct inode *ip;
6855   struct proc *curproc = myproc();
6856 
6857   begin_op();
6858   if(argstr(0, &path) < 0 || (ip = namei(path)) == 0){
6859     end_op();
6860     return -1;
6861   }
6862   ilock(ip);
6863   if(ip->type != T_DIR){
6864     iunlockput(ip);
6865     end_op();
6866     return -1;
6867   }
6868   iunlock(ip);
6869   iput(curproc->cwd);
6870   end_op();
6871   curproc->cwd = ip;
6872   return 0;
6873 }
6874 
6875 int
6876 sys_exec(void)
6877 {
6878   char *path, *argv[MAXARG];
6879   int i;
6880   uint uargv, uarg;
6881 
6882   if(argstr(0, &path) < 0 || argint(1, (int*)&uargv) < 0){
6883     return -1;
6884   }
6885   memset(argv, 0, sizeof(argv));
6886   for(i=0;; i++){
6887     if(i >= NELEM(argv))
6888       return -1;
6889     if(fetchint(uargv+4*i, (int*)&uarg) < 0)
6890       return -1;
6891     if(uarg == 0){
6892       argv[i] = 0;
6893       break;
6894     }
6895     if(fetchstr(uarg, &argv[i]) < 0)
6896       return -1;
6897   }
6898   return exec(path, argv);
6899 }
6900 int
6901 sys_pipe(void)
6902 {
6903   int *fd;
6904   struct file *rf, *wf;
6905   int fd0, fd1;
6906 
6907   if(argptr(0, (void*)&fd, 2*sizeof(fd[0])) < 0)
6908     return -1;
6909   if(pipealloc(&rf, &wf) < 0)
6910     return -1;
6911   fd0 = -1;
6912   if((fd0 = fdalloc(rf)) < 0 || (fd1 = fdalloc(wf)) < 0){
6913     if(fd0 >= 0)
6914       myproc()->ofile[fd0] = 0;
6915     fileclose(rf);
6916     fileclose(wf);
6917     return -1;
6918   }
6919   fd[0] = fd0;
6920   fd[1] = fd1;
6921   return 0;
6922 }
6923 
6924 
6925 
6926 
6927 
6928 
6929 
6930 
6931 
6932 
6933 
6934 
6935 
6936 
6937 
6938 
6939 
6940 
6941 
6942 
6943 
6944 
6945 
6946 
6947 
6948 
6949 
6950 #include "types.h"
6951 #include "param.h"
6952 #include "memlayout.h"
6953 #include "mmu.h"
6954 #include "proc.h"
6955 #include "defs.h"
6956 #include "x86.h"
6957 #include "elf.h"
6958 
6959 int
6960 exec(char *path, char **argv)
6961 {
6962   char *s, *last;
6963   int i, off;
6964   uint argc, sz, sp, ustack[3+MAXARG+1];
6965   struct elfhdr elf;
6966   struct inode *ip;
6967   struct proghdr ph;
6968   pde_t *pgdir, *oldpgdir;
6969   struct proc *curproc = myproc();
6970 
6971   begin_op();
6972 
6973   if((ip = namei(path)) == 0){
6974     end_op();
6975     cprintf("exec: fail\n");
6976     return -1;
6977   }
6978   ilock(ip);
6979   pgdir = 0;
6980 
6981   
6982   if(readi(ip, (char*)&elf, 0, sizeof(elf)) != sizeof(elf))
6983     goto bad;
6984   if(elf.magic != ELF_MAGIC)
6985     goto bad;
6986 
6987   if((pgdir = setupkvm()) == 0)
6988     goto bad;
6989 
6990   
6991   sz = 0;
6992   for(i=0, off=elf.phoff; i<elf.phnum; i++, off+=sizeof(ph)){
6993     if(readi(ip, (char*)&ph, off, sizeof(ph)) != sizeof(ph))
6994       goto bad;
6995     if(ph.type != ELF_PROG_LOAD)
6996       continue;
6997     if(ph.memsz < ph.filesz)
6998       goto bad;
6999     if(ph.vaddr + ph.memsz < ph.vaddr)
7000       goto bad;
7001     if((sz = allocuvm(pgdir, sz, ph.vaddr + ph.memsz)) == 0)
7002       goto bad;
7003     if(ph.vaddr % PGSIZE != 0)
7004       goto bad;
7005     if(loaduvm(pgdir, (char*)ph.vaddr, ip, ph.off, ph.filesz) < 0)
7006       goto bad;
7007   }
7008   iunlockput(ip);
7009   end_op();
7010   ip = 0;
7011 
7012   
7013   
7014   sz = PGROUNDUP(sz);
7015   if((sz = allocuvm(pgdir, sz, sz + 2*PGSIZE)) == 0)
7016     goto bad;
7017   clearpteu(pgdir, (char*)(sz - 2*PGSIZE));
7018   sp = sz;
7019 
7020   
7021   for(argc = 0; argv[argc]; argc++) {
7022     if(argc >= MAXARG)
7023       goto bad;
7024     sp = (sp - (strlen(argv[argc]) + 1)) & ~3;
7025     if(copyout(pgdir, sp, argv[argc], strlen(argv[argc]) + 1) < 0)
7026       goto bad;
7027     ustack[3+argc] = sp;
7028   }
7029   ustack[3+argc] = 0;
7030 
7031   ustack[0] = 0xffffffff;  
7032   ustack[1] = argc;
7033   ustack[2] = sp - (argc+1)*4;  
7034 
7035   sp -= (3+argc+1) * 4;
7036   if(copyout(pgdir, sp, ustack, (3+argc+1)*4) < 0)
7037     goto bad;
7038 
7039   
7040   for(last=s=path; *s; s++)
7041     if(*s == '/')
7042       last = s+1;
7043   safestrcpy(curproc->name, last, sizeof(curproc->name));
7044 
7045   
7046   oldpgdir = curproc->pgdir;
7047   curproc->pgdir = pgdir;
7048   curproc->sz = sz;
7049   curproc->tf->eip = elf.entry;  
7050   curproc->tf->esp = sp;
7051   switchuvm(curproc);
7052   freevm(oldpgdir);
7053   return 0;
7054 
7055  bad:
7056   if(pgdir)
7057     freevm(pgdir);
7058   if(ip){
7059     iunlockput(ip);
7060     end_op();
7061   }
7062   return -1;
7063 }
7064 
7065 
7066 
7067 
7068 
7069 
7070 
7071 
7072 
7073 
7074 
7075 
7076 
7077 
7078 
7079 
7080 
7081 
7082 
7083 
7084 
7085 
7086 
7087 
7088 
7089 
7090 
7091 
7092 
7093 
7094 
7095 
7096 
7097 
7098 
7099 
7100 #include "types.h"
7101 #include "defs.h"
7102 #include "param.h"
7103 #include "mmu.h"
7104 #include "proc.h"
7105 #include "fs.h"
7106 #include "spinlock.h"
7107 #include "sleeplock.h"
7108 #include "file.h"
7109 
7110 #define PIPESIZE 512
7111 
7112 struct pipe {
7113   struct spinlock lock;
7114   char data[PIPESIZE];
7115   uint nread;     
7116   uint nwrite;    
7117   int readopen;   
7118   int writeopen;  
7119 };
7120 
7121 int
7122 pipealloc(struct file **f0, struct file **f1)
7123 {
7124   struct pipe *p;
7125 
7126   p = 0;
7127   *f0 = *f1 = 0;
7128   if((*f0 = filealloc()) == 0 || (*f1 = filealloc()) == 0)
7129     goto bad;
7130   if((p = (struct pipe*)kalloc()) == 0)
7131     goto bad;
7132   p->readopen = 1;
7133   p->writeopen = 1;
7134   p->nwrite = 0;
7135   p->nread = 0;
7136   initlock(&p->lock, "pipe");
7137   (*f0)->type = FD_PIPE;
7138   (*f0)->readable = 1;
7139   (*f0)->writable = 0;
7140   (*f0)->pipe = p;
7141   (*f1)->type = FD_PIPE;
7142   (*f1)->readable = 0;
7143   (*f1)->writable = 1;
7144   (*f1)->pipe = p;
7145   return 0;
7146 
7147 
7148 
7149 
7150  bad:
7151   if(p)
7152     kfree((char*)p);
7153   if(*f0)
7154     fileclose(*f0);
7155   if(*f1)
7156     fileclose(*f1);
7157   return -1;
7158 }
7159 
7160 void
7161 pipeclose(struct pipe *p, int writable)
7162 {
7163   acquire(&p->lock);
7164   if(writable){
7165     p->writeopen = 0;
7166     wakeup(&p->nread);
7167   } else {
7168     p->readopen = 0;
7169     wakeup(&p->nwrite);
7170   }
7171   if(p->readopen == 0 && p->writeopen == 0){
7172     release(&p->lock);
7173     kfree((char*)p);
7174   } else
7175     release(&p->lock);
7176 }
7177 
7178 
7179 int
7180 pipewrite(struct pipe *p, char *addr, int n)
7181 {
7182   int i;
7183 
7184   acquire(&p->lock);
7185   for(i = 0; i < n; i++){
7186     while(p->nwrite == p->nread + PIPESIZE){  
7187       if(p->readopen == 0 || myproc()->killed){
7188         release(&p->lock);
7189         return -1;
7190       }
7191       wakeup(&p->nread);
7192       sleep(&p->nwrite, &p->lock);  
7193     }
7194     p->data[p->nwrite++ % PIPESIZE] = addr[i];
7195   }
7196   wakeup(&p->nread);  
7197   release(&p->lock);
7198   return n;
7199 }
7200 int
7201 piperead(struct pipe *p, char *addr, int n)
7202 {
7203   int i;
7204 
7205   acquire(&p->lock);
7206   while(p->nread == p->nwrite && p->writeopen){  
7207     if(myproc()->killed){
7208       release(&p->lock);
7209       return -1;
7210     }
7211     sleep(&p->nread, &p->lock); 
7212   }
7213   for(i = 0; i < n; i++){  
7214     if(p->nread == p->nwrite)
7215       break;
7216     addr[i] = p->data[p->nread++ % PIPESIZE];
7217   }
7218   wakeup(&p->nwrite);  
7219   release(&p->lock);
7220   return i;
7221 }
7222 
7223 
7224 
7225 
7226 
7227 
7228 
7229 
7230 
7231 
7232 
7233 
7234 
7235 
7236 
7237 
7238 
7239 
7240 
7241 
7242 
7243 
7244 
7245 
7246 
7247 
7248 
7249 
7250 #include "types.h"
7251 #include "x86.h"
7252 
7253 void*
7254 memset(void *dst, int c, uint n)
7255 {
7256   if ((int)dst%4 == 0 && n%4 == 0){
7257     c &= 0xFF;
7258     stosl(dst, (c<<24)|(c<<16)|(c<<8)|c, n/4);
7259   } else
7260     stosb(dst, c, n);
7261   return dst;
7262 }
7263 
7264 int
7265 memcmp(const void *v1, const void *v2, uint n)
7266 {
7267   const uchar *s1, *s2;
7268 
7269   s1 = v1;
7270   s2 = v2;
7271   while(n-- > 0){
7272     if(*s1 != *s2)
7273       return *s1 - *s2;
7274     s1++, s2++;
7275   }
7276 
7277   return 0;
7278 }
7279 
7280 void*
7281 memmove(void *dst, const void *src, uint n)
7282 {
7283   const char *s;
7284   char *d;
7285 
7286   s = src;
7287   d = dst;
7288   if(s < d && s + n > d){
7289     s += n;
7290     d += n;
7291     while(n-- > 0)
7292       *--d = *--s;
7293   } else
7294     while(n-- > 0)
7295       *d++ = *s++;
7296 
7297   return dst;
7298 }
7299 
7300 
7301 void*
7302 memcpy(void *dst, const void *src, uint n)
7303 {
7304   return memmove(dst, src, n);
7305 }
7306 
7307 int
7308 strncmp(const char *p, const char *q, uint n)
7309 {
7310   while(n > 0 && *p && *p == *q)
7311     n--, p++, q++;
7312   if(n == 0)
7313     return 0;
7314   return (uchar)*p - (uchar)*q;
7315 }
7316 
7317 char*
7318 strncpy(char *s, const char *t, int n)
7319 {
7320   char *os;
7321 
7322   os = s;
7323   while(n-- > 0 && (*s++ = *t++) != 0)
7324     ;
7325   while(n-- > 0)
7326     *s++ = 0;
7327   return os;
7328 }
7329 
7330 
7331 char*
7332 safestrcpy(char *s, const char *t, int n)
7333 {
7334   char *os;
7335 
7336   os = s;
7337   if(n <= 0)
7338     return os;
7339   while(--n > 0 && (*s++ = *t++) != 0)
7340     ;
7341   *s = 0;
7342   return os;
7343 }
7344 
7345 
7346 
7347 
7348 
7349 
7350 int
7351 strlen(const char *s)
7352 {
7353   int n;
7354 
7355   for(n = 0; s[n]; n++)
7356     ;
7357   return n;
7358 }
7359 
7360 
7361 
7362 
7363 
7364 
7365 
7366 
7367 
7368 
7369 
7370 
7371 
7372 
7373 
7374 
7375 
7376 
7377 
7378 
7379 
7380 
7381 
7382 
7383 
7384 
7385 
7386 
7387 
7388 
7389 
7390 
7391 
7392 
7393 
7394 
7395 
7396 
7397 
7398 
7399 
7400 
7401 
7402 struct mp {             
7403   uchar signature[4];           
7404   void *physaddr;               
7405   uchar length;                 
7406   uchar specrev;                
7407   uchar checksum;               
7408   uchar type;                   
7409   uchar imcrp;
7410   uchar reserved[3];
7411 };
7412 
7413 struct mpconf {         
7414   uchar signature[4];           
7415   ushort length;                
7416   uchar version;                
7417   uchar checksum;               
7418   uchar product[20];            
7419   uint *oemtable;               
7420   ushort oemlength;             
7421   ushort entry;                 
7422   uint *lapicaddr;              
7423   ushort xlength;               
7424   uchar xchecksum;              
7425   uchar reserved;
7426 };
7427 
7428 struct mpproc {         
7429   uchar type;                   
7430   uchar apicid;                 
7431   uchar version;                
7432   uchar flags;                  
7433     #define MPBOOT 0x02           
7434   uchar signature[4];           
7435   uint feature;                 
7436   uchar reserved[8];
7437 };
7438 
7439 struct mpioapic {       
7440   uchar type;                   
7441   uchar apicno;                 
7442   uchar version;                
7443   uchar flags;                  
7444   uint *addr;                  
7445 };
7446 
7447 
7448 
7449 
7450 
7451 #define MPPROC    0x00  
7452 #define MPBUS     0x01  
7453 #define MPIOAPIC  0x02  
7454 #define MPIOINTR  0x03  
7455 #define MPLINTR   0x04  
7456 
7457 
7458 
7459 
7460 
7461 
7462 
7463 
7464 
7465 
7466 
7467 
7468 
7469 
7470 
7471 
7472 
7473 
7474 
7475 
7476 
7477 
7478 
7479 
7480 
7481 
7482 
7483 
7484 
7485 
7486 
7487 
7488 
7489 
7490 
7491 
7492 
7493 
7494 
7495 
7496 
7497 
7498 
7499 
7500 
7501 
7502 
7503 
7504 
7505 
7506 
7507 
7508 
7509 
7510 
7511 
7512 
7513 
7514 
7515 
7516 
7517 
7518 
7519 
7520 
7521 
7522 
7523 
7524 
7525 
7526 
7527 
7528 
7529 
7530 
7531 
7532 
7533 
7534 
7535 
7536 
7537 
7538 
7539 
7540 
7541 
7542 
7543 
7544 
7545 
7546 
7547 
7548 
7549 
7550 
7551 
7552 
7553 
7554 #include "types.h"
7555 #include "defs.h"
7556 #include "param.h"
7557 #include "memlayout.h"
7558 #include "mp.h"
7559 #include "x86.h"
7560 #include "mmu.h"
7561 #include "proc.h"
7562 
7563 struct cpu cpus[NCPU];
7564 int ncpu;
7565 uchar ioapicid;
7566 
7567 static uchar
7568 sum(uchar *addr, int len)
7569 {
7570   int i, sum;
7571 
7572   sum = 0;
7573   for(i=0; i<len; i++)
7574     sum += addr[i];
7575   return sum;
7576 }
7577 
7578 
7579 static struct mp*
7580 mpsearch1(uint a, int len)
7581 {
7582   uchar *e, *p, *addr;
7583 
7584   addr = P2V(a);
7585   e = addr+len;
7586   for(p = addr; p < e; p += sizeof(struct mp))
7587     if(memcmp(p, "_MP_", 4) == 0 && sum(p, sizeof(struct mp)) == 0)
7588       return (struct mp*)p;
7589   return 0;
7590 }
7591 
7592 
7593 
7594 
7595 
7596 
7597 
7598 
7599 
7600 
7601 
7602 
7603 
7604 
7605 static struct mp*
7606 mpsearch(void)
7607 {
7608   uchar *bda;
7609   uint p;
7610   struct mp *mp;
7611 
7612   bda = (uchar *) P2V(0x400);
7613   if((p = ((bda[0x0F]<<8)| bda[0x0E]) << 4)){
7614     if((mp = mpsearch1(p, 1024)))
7615       return mp;
7616   } else {
7617     p = ((bda[0x14]<<8)|bda[0x13])*1024;
7618     if((mp = mpsearch1(p-1024, 1024)))
7619       return mp;
7620   }
7621   return mpsearch1(0xF0000, 0x10000);
7622 }
7623 
7624 
7625 
7626 
7627 
7628 
7629 static struct mpconf*
7630 mpconfig(struct mp **pmp)
7631 {
7632   struct mpconf *conf;
7633   struct mp *mp;
7634 
7635   if((mp = mpsearch()) == 0 || mp->physaddr == 0)
7636     return 0;
7637   conf = (struct mpconf*) P2V((uint) mp->physaddr);
7638   if(memcmp(conf, "PCMP", 4) != 0)
7639     return 0;
7640   if(conf->version != 1 && conf->version != 4)
7641     return 0;
7642   if(sum((uchar*)conf, conf->length) != 0)
7643     return 0;
7644   *pmp = mp;
7645   return conf;
7646 }
7647 
7648 
7649 
7650 void
7651 mpinit(void)
7652 {
7653   uchar *p, *e;
7654   int ismp;
7655   struct mp *mp;
7656   struct mpconf *conf;
7657   struct mpproc *proc;
7658   struct mpioapic *ioapic;
7659 
7660   if((conf = mpconfig(&mp)) == 0)
7661     panic("Expect to run on an SMP");
7662   ismp = 1;
7663   lapic = (uint*)conf->lapicaddr;
7664   for(p=(uchar*)(conf+1), e=(uchar*)conf+conf->length; p<e; ){
7665     switch(*p){
7666     case MPPROC:
7667       proc = (struct mpproc*)p;
7668       if(ncpu < NCPU) {
7669         cpus[ncpu].apicid = proc->apicid;  
7670         ncpu++;
7671       }
7672       p += sizeof(struct mpproc);
7673       continue;
7674     case MPIOAPIC:
7675       ioapic = (struct mpioapic*)p;
7676       ioapicid = ioapic->apicno;
7677       p += sizeof(struct mpioapic);
7678       continue;
7679     case MPBUS:
7680     case MPIOINTR:
7681     case MPLINTR:
7682       p += 8;
7683       continue;
7684     default:
7685       ismp = 0;
7686       break;
7687     }
7688   }
7689   if(!ismp)
7690     panic("Didn't find a suitable machine");
7691 
7692   if(mp->imcrp){
7693     
7694     
7695     outb(0x22, 0x70);   
7696     outb(0x23, inb(0x23) | 1);  
7697   }
7698 }
7699 
7700 
7701 
7702 
7703 #include "param.h"
7704 #include "types.h"
7705 #include "defs.h"
7706 #include "date.h"
7707 #include "memlayout.h"
7708 #include "traps.h"
7709 #include "mmu.h"
7710 #include "x86.h"
7711 
7712 
7713 #define ID      (0x0020/4)   
7714 #define VER     (0x0030/4)   
7715 #define TPR     (0x0080/4)   
7716 #define EOI     (0x00B0/4)   
7717 #define SVR     (0x00F0/4)   
7718   #define ENABLE     0x00000100   
7719 #define ESR     (0x0280/4)   
7720 #define ICRLO   (0x0300/4)   
7721   #define INIT       0x00000500   
7722   #define STARTUP    0x00000600   
7723   #define DELIVS     0x00001000   
7724   #define ASSERT     0x00004000   
7725   #define DEASSERT   0x00000000
7726   #define LEVEL      0x00008000   
7727   #define BCAST      0x00080000   
7728   #define BUSY       0x00001000
7729   #define FIXED      0x00000000
7730 #define ICRHI   (0x0310/4)   
7731 #define TIMER   (0x0320/4)   
7732   #define X1         0x0000000B   
7733   #define PERIODIC   0x00020000   
7734 #define PCINT   (0x0340/4)   
7735 #define LINT0   (0x0350/4)   
7736 #define LINT1   (0x0360/4)   
7737 #define ERROR   (0x0370/4)   
7738   #define MASKED     0x00010000   
7739 #define TICR    (0x0380/4)   
7740 #define TCCR    (0x0390/4)   
7741 #define TDCR    (0x03E0/4)   
7742 
7743 volatile uint *lapic;  
7744 
7745 
7746 
7747 
7748 
7749 
7750 static void
7751 lapicw(int index, int value)
7752 {
7753   lapic[index] = value;
7754   lapic[ID];  
7755 }
7756 
7757 void
7758 lapicinit(void)
7759 {
7760   if(!lapic)
7761     return;
7762 
7763   
7764   lapicw(SVR, ENABLE | (T_IRQ0 + IRQ_SPURIOUS));
7765 
7766   
7767   
7768   
7769   
7770   lapicw(TDCR, X1);
7771   lapicw(TIMER, PERIODIC | (T_IRQ0 + IRQ_TIMER));
7772   lapicw(TICR, 10000000);
7773 
7774   
7775   lapicw(LINT0, MASKED);
7776   lapicw(LINT1, MASKED);
7777 
7778   
7779   
7780   if(((lapic[VER]>>16) & 0xFF) >= 4)
7781     lapicw(PCINT, MASKED);
7782 
7783   
7784   lapicw(ERROR, T_IRQ0 + IRQ_ERROR);
7785 
7786   
7787   lapicw(ESR, 0);
7788   lapicw(ESR, 0);
7789 
7790   
7791   lapicw(EOI, 0);
7792 
7793   
7794   lapicw(ICRHI, 0);
7795   lapicw(ICRLO, BCAST | INIT | LEVEL);
7796   while(lapic[ICRLO] & DELIVS)
7797     ;
7798 
7799 
7800   
7801   lapicw(TPR, 0);
7802 }
7803 
7804 int
7805 lapicid(void)
7806 {
7807   if (!lapic)
7808     return 0;
7809   return lapic[ID] >> 24;
7810 }
7811 
7812 
7813 void
7814 lapiceoi(void)
7815 {
7816   if(lapic)
7817     lapicw(EOI, 0);
7818 }
7819 
7820 
7821 
7822 void
7823 microdelay(int us)
7824 {
7825 }
7826 
7827 #define CMOS_PORT    0x70
7828 #define CMOS_RETURN  0x71
7829 
7830 
7831 
7832 void
7833 lapicstartap(uchar apicid, uint addr)
7834 {
7835   int i;
7836   ushort *wrv;
7837 
7838   
7839   
7840   
7841   outb(CMOS_PORT, 0xF);  
7842   outb(CMOS_PORT+1, 0x0A);
7843   wrv = (ushort*)P2V((0x40<<4 | 0x67));  
7844   wrv[0] = 0;
7845   wrv[1] = addr >> 4;
7846 
7847 
7848 
7849 
7850   
7851   
7852   lapicw(ICRHI, apicid<<24);
7853   lapicw(ICRLO, INIT | LEVEL | ASSERT);
7854   microdelay(200);
7855   lapicw(ICRLO, INIT | LEVEL);
7856   microdelay(100);    
7857 
7858   
7859   
7860   
7861   
7862   
7863   for(i = 0; i < 2; i++){
7864     lapicw(ICRHI, apicid<<24);
7865     lapicw(ICRLO, STARTUP | (addr>>12));
7866     microdelay(200);
7867   }
7868 }
7869 
7870 #define CMOS_STATA   0x0a
7871 #define CMOS_STATB   0x0b
7872 #define CMOS_UIP    (1 << 7)        
7873 
7874 #define SECS    0x00
7875 #define MINS    0x02
7876 #define HOURS   0x04
7877 #define DAY     0x07
7878 #define MONTH   0x08
7879 #define YEAR    0x09
7880 
7881 static uint
7882 cmos_read(uint reg)
7883 {
7884   outb(CMOS_PORT,  reg);
7885   microdelay(200);
7886 
7887   return inb(CMOS_RETURN);
7888 }
7889 
7890 static void
7891 fill_rtcdate(struct rtcdate *r)
7892 {
7893   r->second = cmos_read(SECS);
7894   r->minute = cmos_read(MINS);
7895   r->hour   = cmos_read(HOURS);
7896   r->day    = cmos_read(DAY);
7897   r->month  = cmos_read(MONTH);
7898   r->year   = cmos_read(YEAR);
7899 }
7900 
7901 void
7902 cmostime(struct rtcdate *r)
7903 {
7904   struct rtcdate t1, t2;
7905   int sb, bcd;
7906 
7907   sb = cmos_read(CMOS_STATB);
7908 
7909   bcd = (sb & (1 << 2)) == 0;
7910 
7911   
7912   for(;;) {
7913     fill_rtcdate(&t1);
7914     if(cmos_read(CMOS_STATA) & CMOS_UIP)
7915         continue;
7916     fill_rtcdate(&t2);
7917     if(memcmp(&t1, &t2, sizeof(t1)) == 0)
7918       break;
7919   }
7920 
7921   
7922   if(bcd) {
7923 #define    CONV(x)     (t1.x = ((t1.x >> 4) * 10) + (t1.x & 0xf))
7924     CONV(second);
7925     CONV(minute);
7926     CONV(hour  );
7927     CONV(day   );
7928     CONV(month );
7929     CONV(year  );
7930 #undef     CONV
7931   }
7932 
7933   *r = t1;
7934   r->year += 2000;
7935 }
7936 
7937 
7938 
7939 
7940 
7941 
7942 
7943 
7944 
7945 
7946 
7947 
7948 
7949 
7950 
7951 
7952 
7953 
7954 #include "types.h"
7955 #include "defs.h"
7956 #include "traps.h"
7957 
7958 #define IOAPIC  0xFEC00000   
7959 
7960 #define REG_ID     0x00  
7961 #define REG_VER    0x01  
7962 #define REG_TABLE  0x10  
7963 
7964 
7965 
7966 
7967 
7968 
7969 #define INT_DISABLED   0x00010000  
7970 #define INT_LEVEL      0x00008000  
7971 #define INT_ACTIVELOW  0x00002000  
7972 #define INT_LOGICAL    0x00000800  
7973 
7974 volatile struct ioapic *ioapic;
7975 
7976 
7977 struct ioapic {
7978   uint reg;
7979   uint pad[3];
7980   uint data;
7981 };
7982 
7983 static uint
7984 ioapicread(int reg)
7985 {
7986   ioapic->reg = reg;
7987   return ioapic->data;
7988 }
7989 
7990 static void
7991 ioapicwrite(int reg, uint data)
7992 {
7993   ioapic->reg = reg;
7994   ioapic->data = data;
7995 }
7996 
7997 
7998 
7999 
8000 void
8001 ioapicinit(void)
8002 {
8003   int i, id, maxintr;
8004 
8005   ioapic = (volatile struct ioapic*)IOAPIC;
8006   maxintr = (ioapicread(REG_VER) >> 16) & 0xFF;
8007   id = ioapicread(REG_ID) >> 24;
8008   if(id != ioapicid)
8009     cprintf("ioapicinit: id isn't equal to ioapicid; not a MP\n");
8010 
8011   
8012   
8013   for(i = 0; i <= maxintr; i++){
8014     ioapicwrite(REG_TABLE+2*i, INT_DISABLED | (T_IRQ0 + i));
8015     ioapicwrite(REG_TABLE+2*i+1, 0);
8016   }
8017 }
8018 
8019 void
8020 ioapicenable(int irq, int cpunum)
8021 {
8022   
8023   
8024   
8025   ioapicwrite(REG_TABLE+2*irq, T_IRQ0 + irq);
8026   ioapicwrite(REG_TABLE+2*irq+1, cpunum << 24);
8027 }
8028 
8029 
8030 
8031 
8032 
8033 
8034 
8035 
8036 
8037 
8038 
8039 
8040 
8041 
8042 
8043 
8044 
8045 
8046 
8047 
8048 
8049 
8050 
8051 
8052 #define KBSTATP         0x64    
8053 #define KBS_DIB         0x01    
8054 #define KBDATAP         0x60    
8055 
8056 #define NO              0
8057 
8058 #define SHIFT           (1<<0)
8059 #define CTL             (1<<1)
8060 #define ALT             (1<<2)
8061 
8062 #define CAPSLOCK        (1<<3)
8063 #define NUMLOCK         (1<<4)
8064 #define SCROLLLOCK      (1<<5)
8065 
8066 #define E0ESC           (1<<6)
8067 
8068 
8069 #define KEY_HOME        0xE0
8070 #define KEY_END         0xE1
8071 #define KEY_UP          0xE2
8072 #define KEY_DN          0xE3
8073 #define KEY_LF          0xE4
8074 #define KEY_RT          0xE5
8075 #define KEY_PGUP        0xE6
8076 #define KEY_PGDN        0xE7
8077 #define KEY_INS         0xE8
8078 #define KEY_DEL         0xE9
8079 
8080 
8081 #define C(x) (x - '@')
8082 
8083 static uchar shiftcode[256] =
8084 {
8085   [0x1D] CTL,
8086   [0x2A] SHIFT,
8087   [0x36] SHIFT,
8088   [0x38] ALT,
8089   [0x9D] CTL,
8090   [0xB8] ALT
8091 };
8092 
8093 static uchar togglecode[256] =
8094 {
8095   [0x3A] CAPSLOCK,
8096   [0x45] NUMLOCK,
8097   [0x46] SCROLLLOCK
8098 };
8099 
8100 static uchar normalmap[256] =
8101 {
8102   NO,   0x1B, '1',  '2',  '3',  '4',  '5',  '6',  
8103   '7',  '8',  '9',  '0',  '-',  '=',  '\b', '\t',
8104   'q',  'w',  'e',  'r',  't',  'y',  'u',  'i',  
8105   'o',  'p',  '[',  ']',  '\n', NO,   'a',  's',
8106   'd',  'f',  'g',  'h',  'j',  'k',  'l',  ';',  
8107   '\'', '`',  NO,   '\\', 'z',  'x',  'c',  'v',
8108   'b',  'n',  'm',  ',',  '.',  '/',  NO,   '*',  
8109   NO,   ' ',  NO,   NO,   NO,   NO,   NO,   NO,
8110   NO,   NO,   NO,   NO,   NO,   NO,   NO,   '7',  
8111   '8',  '9',  '-',  '4',  '5',  '6',  '+',  '1',
8112   '2',  '3',  '0',  '.',  NO,   NO,   NO,   NO,   
8113   [0x9C] '\n',      
8114   [0xB5] '/',       
8115   [0xC8] KEY_UP,    [0xD0] KEY_DN,
8116   [0xC9] KEY_PGUP,  [0xD1] KEY_PGDN,
8117   [0xCB] KEY_LF,    [0xCD] KEY_RT,
8118   [0x97] KEY_HOME,  [0xCF] KEY_END,
8119   [0xD2] KEY_INS,   [0xD3] KEY_DEL
8120 };
8121 
8122 static uchar shiftmap[256] =
8123 {
8124   NO,   033,  '!',  '@',  '#',  '$',  '%',  '^',  
8125   '&',  '*',  '(',  ')',  '_',  '+',  '\b', '\t',
8126   'Q',  'W',  'E',  'R',  'T',  'Y',  'U',  'I',  
8127   'O',  'P',  '{',  '}',  '\n', NO,   'A',  'S',
8128   'D',  'F',  'G',  'H',  'J',  'K',  'L',  ':',  
8129   '"',  '~',  NO,   '|',  'Z',  'X',  'C',  'V',
8130   'B',  'N',  'M',  '<',  '>',  '?',  NO,   '*',  
8131   NO,   ' ',  NO,   NO,   NO,   NO,   NO,   NO,
8132   NO,   NO,   NO,   NO,   NO,   NO,   NO,   '7',  
8133   '8',  '9',  '-',  '4',  '5',  '6',  '+',  '1',
8134   '2',  '3',  '0',  '.',  NO,   NO,   NO,   NO,   
8135   [0x9C] '\n',      
8136   [0xB5] '/',       
8137   [0xC8] KEY_UP,    [0xD0] KEY_DN,
8138   [0xC9] KEY_PGUP,  [0xD1] KEY_PGDN,
8139   [0xCB] KEY_LF,    [0xCD] KEY_RT,
8140   [0x97] KEY_HOME,  [0xCF] KEY_END,
8141   [0xD2] KEY_INS,   [0xD3] KEY_DEL
8142 };
8143 
8144 
8145 
8146 
8147 
8148 
8149 
8150 static uchar ctlmap[256] =
8151 {
8152   NO,      NO,      NO,      NO,      NO,      NO,      NO,      NO,
8153   NO,      NO,      NO,      NO,      NO,      NO,      NO,      NO,
8154   C('Q'),  C('W'),  C('E'),  C('R'),  C('T'),  C('Y'),  C('U'),  C('I'),
8155   C('O'),  C('P'),  NO,      NO,      '\r',    NO,      C('A'),  C('S'),
8156   C('D'),  C('F'),  C('G'),  C('H'),  C('J'),  C('K'),  C('L'),  NO,
8157   NO,      NO,      NO,      C('\\'), C('Z'),  C('X'),  C('C'),  C('V'),
8158   C('B'),  C('N'),  C('M'),  NO,      NO,      C('/'),  NO,      NO,
8159   [0x9C] '\r',      
8160   [0xB5] C('/'),    
8161   [0xC8] KEY_UP,    [0xD0] KEY_DN,
8162   [0xC9] KEY_PGUP,  [0xD1] KEY_PGDN,
8163   [0xCB] KEY_LF,    [0xCD] KEY_RT,
8164   [0x97] KEY_HOME,  [0xCF] KEY_END,
8165   [0xD2] KEY_INS,   [0xD3] KEY_DEL
8166 };
8167 
8168 
8169 
8170 
8171 
8172 
8173 
8174 
8175 
8176 
8177 
8178 
8179 
8180 
8181 
8182 
8183 
8184 
8185 
8186 
8187 
8188 
8189 
8190 
8191 
8192 
8193 
8194 
8195 
8196 
8197 
8198 
8199 
8200 #include "types.h"
8201 #include "x86.h"
8202 #include "defs.h"
8203 #include "kbd.h"
8204 
8205 int
8206 kbdgetc(void)
8207 {
8208   static uint shift;
8209   static uchar *charcode[4] = {
8210     normalmap, shiftmap, ctlmap, ctlmap
8211   };
8212   uint st, data, c;
8213 
8214   st = inb(KBSTATP);
8215   if((st & KBS_DIB) == 0)
8216     return -1;
8217   data = inb(KBDATAP);
8218 
8219   if(data == 0xE0){
8220     shift |= E0ESC;
8221     return 0;
8222   } else if(data & 0x80){
8223     
8224     data = (shift & E0ESC ? data : data & 0x7F);
8225     shift &= ~(shiftcode[data] | E0ESC);
8226     return 0;
8227   } else if(shift & E0ESC){
8228     
8229     data |= 0x80;
8230     shift &= ~E0ESC;
8231   }
8232 
8233   shift |= shiftcode[data];
8234   shift ^= togglecode[data];
8235   c = charcode[shift & (CTL | SHIFT)][data];
8236   if(shift & CAPSLOCK){
8237     if('a' <= c && c <= 'z')
8238       c += 'A' - 'a';
8239     else if('A' <= c && c <= 'Z')
8240       c += 'a' - 'A';
8241   }
8242   return c;
8243 }
8244 
8245 void
8246 kbdintr(void)
8247 {
8248   consoleintr(kbdgetc);
8249 }
8250 
8251 
8252 
8253 
8254 #include "types.h"
8255 #include "defs.h"
8256 #include "param.h"
8257 #include "traps.h"
8258 #include "spinlock.h"
8259 #include "sleeplock.h"
8260 #include "fs.h"
8261 #include "file.h"
8262 #include "memlayout.h"
8263 #include "mmu.h"
8264 #include "proc.h"
8265 #include "x86.h"
8266 
8267 static void consputc(int);
8268 
8269 static int panicked = 0;
8270 
8271 static struct {
8272   struct spinlock lock;
8273   int locking;
8274 } cons;
8275 
8276 static void
8277 printint(int xx, int base, int sign)
8278 {
8279   static char digits[] = "0123456789abcdef";
8280   char buf[16];
8281   int i;
8282   uint x;
8283 
8284   if(sign && (sign = xx < 0))
8285     x = -xx;
8286   else
8287     x = xx;
8288 
8289   i = 0;
8290   do{
8291     buf[i++] = digits[x % base];
8292   }while((x /= base) != 0);
8293 
8294   if(sign)
8295     buf[i++] = '-';
8296 
8297   while(--i >= 0)
8298     consputc(buf[i]);
8299 }
8300 
8301 
8302 
8303 
8304 
8305 
8306 
8307 
8308 
8309 
8310 
8311 
8312 
8313 
8314 
8315 
8316 
8317 
8318 
8319 
8320 
8321 
8322 
8323 
8324 
8325 
8326 
8327 
8328 
8329 
8330 
8331 
8332 
8333 
8334 
8335 
8336 
8337 
8338 
8339 
8340 
8341 
8342 
8343 
8344 
8345 
8346 
8347 
8348 
8349 
8350 
8351 void
8352 cprintf(char *fmt, ...)
8353 {
8354   int i, c, locking;
8355   uint *argp;
8356   char *s;
8357 
8358   locking = cons.locking;
8359   if(locking)
8360     acquire(&cons.lock);
8361 
8362   if (fmt == 0)
8363     panic("null fmt");
8364 
8365   argp = (uint*)(void*)(&fmt + 1);
8366   for(i = 0; (c = fmt[i] & 0xff) != 0; i++){
8367     if(c != '%'){
8368       consputc(c);
8369       continue;
8370     }
8371     c = fmt[++i] & 0xff;
8372     if(c == 0)
8373       break;
8374     switch(c){
8375     case 'd':
8376       printint(*argp++, 10, 1);
8377       break;
8378     case 'x':
8379     case 'p':
8380       printint(*argp++, 16, 0);
8381       break;
8382     case 's':
8383       if((s = (char*)*argp++) == 0)
8384         s = "(null)";
8385       for(; *s; s++)
8386         consputc(*s);
8387       break;
8388     case '%':
8389       consputc('%');
8390       break;
8391     default:
8392       
8393       consputc('%');
8394       consputc(c);
8395       break;
8396     }
8397   }
8398 
8399 
8400   if(locking)
8401     release(&cons.lock);
8402 }
8403 
8404 void
8405 panic(char *s)
8406 {
8407   int i;
8408   uint pcs[10];
8409 
8410   cli();
8411   cons.locking = 0;
8412   
8413   cprintf("lapicid %d: panic: ", lapicid());
8414   cprintf(s);
8415   cprintf("\n");
8416   getcallerpcs(&s, pcs);
8417   for(i=0; i<10; i++)
8418     cprintf(" %p", pcs[i]);
8419   panicked = 1; 
8420   for(;;)
8421     ;
8422 }
8423 
8424 
8425 
8426 
8427 
8428 
8429 
8430 
8431 
8432 
8433 
8434 
8435 
8436 
8437 
8438 
8439 
8440 
8441 
8442 
8443 
8444 
8445 
8446 
8447 
8448 
8449 
8450 #define BACKSPACE 0x100
8451 #define CRTPORT 0x3d4
8452 static ushort *crt = (ushort*)P2V(0xb8000);  
8453 
8454 static void
8455 cgaputc(int c)
8456 {
8457   int pos;
8458 
8459   
8460   outb(CRTPORT, 14);
8461   pos = inb(CRTPORT+1) << 8;
8462   outb(CRTPORT, 15);
8463   pos |= inb(CRTPORT+1);
8464 
8465   if(c == '\n')
8466     pos += 80 - pos%80;
8467   else if(c == BACKSPACE){
8468     if(pos > 0) --pos;
8469   } else
8470     crt[pos++] = (c&0xff) | 0x0700;  
8471 
8472   if(pos < 0 || pos > 25*80)
8473     panic("pos under/overflow");
8474 
8475   if((pos/80) >= 24){  
8476     memmove(crt, crt+80, sizeof(crt[0])*23*80);
8477     pos -= 80;
8478     memset(crt+pos, 0, sizeof(crt[0])*(24*80 - pos));
8479   }
8480 
8481   outb(CRTPORT, 14);
8482   outb(CRTPORT+1, pos>>8);
8483   outb(CRTPORT, 15);
8484   outb(CRTPORT+1, pos);
8485   crt[pos] = ' ' | 0x0700;
8486 }
8487 
8488 
8489 
8490 
8491 
8492 
8493 
8494 
8495 
8496 
8497 
8498 
8499 
8500 void
8501 consputc(int c)
8502 {
8503   if(panicked){
8504     cli();
8505     for(;;)
8506       ;
8507   }
8508 
8509   if(c == BACKSPACE){
8510     uartputc('\b'); uartputc(' '); uartputc('\b');
8511   } else
8512     uartputc(c);
8513   cgaputc(c);
8514 }
8515 
8516 #define INPUT_BUF 128
8517 struct {
8518   char buf[INPUT_BUF];
8519   uint r;  
8520   uint w;  
8521   uint e;  
8522 } input;
8523 
8524 #define C(x)  ((x)-'@')  
8525 
8526 void
8527 consoleintr(int (*getc)(void))
8528 {
8529   int c, doprocdump = 0;
8530 
8531   acquire(&cons.lock);
8532   while((c = getc()) >= 0){
8533     switch(c){
8534     case C('P'):  
8535       
8536       doprocdump = 1;
8537       break;
8538     case C('U'):  
8539       while(input.e != input.w &&
8540             input.buf[(input.e-1) % INPUT_BUF] != '\n'){
8541         input.e--;
8542         consputc(BACKSPACE);
8543       }
8544       break;
8545     case C('H'): case '\x7f':  
8546       if(input.e != input.w){
8547         input.e--;
8548         consputc(BACKSPACE);
8549       }
8550       break;
8551     default:
8552       if(c != 0 && input.e-input.r < INPUT_BUF){
8553         c = (c == '\r') ? '\n' : c;
8554         input.buf[input.e++ % INPUT_BUF] = c;
8555         consputc(c);
8556         if(c == '\n' || c == C('D') || input.e == input.r+INPUT_BUF){
8557           input.w = input.e;
8558           wakeup(&input.r);
8559         }
8560       }
8561       break;
8562     }
8563   }
8564   release(&cons.lock);
8565   if(doprocdump) {
8566     procdump();  
8567   }
8568 }
8569 
8570 int
8571 consoleread(struct inode *ip, char *dst, int n)
8572 {
8573   uint target;
8574   int c;
8575 
8576   iunlock(ip);
8577   target = n;
8578   acquire(&cons.lock);
8579   while(n > 0){
8580     while(input.r == input.w){
8581       if(myproc()->killed){
8582         release(&cons.lock);
8583         ilock(ip);
8584         return -1;
8585       }
8586       sleep(&input.r, &cons.lock);
8587     }
8588     c = input.buf[input.r++ % INPUT_BUF];
8589     if(c == C('D')){  
8590       if(n < target){
8591         
8592         
8593         input.r--;
8594       }
8595       break;
8596     }
8597     *dst++ = c;
8598     --n;
8599     if(c == '\n')
8600       break;
8601   }
8602   release(&cons.lock);
8603   ilock(ip);
8604 
8605   return target - n;
8606 }
8607 
8608 int
8609 consolewrite(struct inode *ip, char *buf, int n)
8610 {
8611   int i;
8612 
8613   iunlock(ip);
8614   acquire(&cons.lock);
8615   for(i = 0; i < n; i++)
8616     consputc(buf[i] & 0xff);
8617   release(&cons.lock);
8618   ilock(ip);
8619 
8620   return n;
8621 }
8622 
8623 void
8624 consoleinit(void)
8625 {
8626   initlock(&cons.lock, "console");
8627 
8628   devsw[CONSOLE].write = consolewrite;
8629   devsw[CONSOLE].read = consoleread;
8630   cons.locking = 1;
8631 
8632   ioapicenable(IRQ_KBD, 0);
8633 }
8634 
8635 
8636 
8637 
8638 
8639 
8640 
8641 
8642 
8643 
8644 
8645 
8646 
8647 
8648 
8649 
8650 
8651 
8652 #include "types.h"
8653 #include "defs.h"
8654 #include "param.h"
8655 #include "traps.h"
8656 #include "spinlock.h"
8657 #include "sleeplock.h"
8658 #include "fs.h"
8659 #include "file.h"
8660 #include "mmu.h"
8661 #include "proc.h"
8662 #include "x86.h"
8663 
8664 #define COM1    0x3f8
8665 
8666 static int uart;    
8667 
8668 void
8669 uartinit(void)
8670 {
8671   char *p;
8672 
8673   
8674   outb(COM1+2, 0);
8675 
8676   
8677   outb(COM1+3, 0x80);    
8678   outb(COM1+0, 115200/9600);
8679   outb(COM1+1, 0);
8680   outb(COM1+3, 0x03);    
8681   outb(COM1+4, 0);
8682   outb(COM1+1, 0x01);    
8683 
8684   
8685   if(inb(COM1+5) == 0xFF)
8686     return;
8687   uart = 1;
8688 
8689   
8690   
8691   inb(COM1+2);
8692   inb(COM1+0);
8693   ioapicenable(IRQ_COM1, 0);
8694 
8695   
8696   for(p="xv6...\n"; *p; p++)
8697     uartputc(*p);
8698 }
8699 
8700 void
8701 uartputc(int c)
8702 {
8703   int i;
8704 
8705   if(!uart)
8706     return;
8707   for(i = 0; i < 128 && !(inb(COM1+5) & 0x20); i++)
8708     microdelay(10);
8709   outb(COM1+0, c);
8710 }
8711 
8712 static int
8713 uartgetc(void)
8714 {
8715   if(!uart)
8716     return -1;
8717   if(!(inb(COM1+5) & 0x01))
8718     return -1;
8719   return inb(COM1+0);
8720 }
8721 
8722 void
8723 uartintr(void)
8724 {
8725   consoleintr(uartgetc);
8726 }
8727 
8728 
8729 
8730 
8731 
8732 
8733 
8734 
8735 
8736 
8737 
8738 
8739 
8740 
8741 
8742 
8743 
8744 
8745 
8746 
8747 
8748 
8749 
8750 
8751 
8752 
8753 
8754 
8755 
8756 
8757 
8758 .globl start
8759 start:
8760   pushl $argv
8761   pushl $init
8762   pushl $0  
8763   movl $SYS_exec, %eax
8764   int $T_SYSCALL
8765 
8766 
8767 exit:
8768   movl $SYS_exit, %eax
8769   int $T_SYSCALL
8770   jmp exit
8771 
8772 
8773 init:
8774   .string "/init\0"
8775 
8776 
8777 .p2align 2
8778 argv:
8779   .long init
8780   .long 0
8781 
8782 
8783 
8784 
8785 
8786 
8787 
8788 
8789 
8790 
8791 
8792 
8793 
8794 
8795 
8796 
8797 
8798 
8799 
8800 
8801 
8802 
8803 
8804   .globl name; \
8805   name: \
8806     movl $SYS_ 
8807     int $T_SYSCALL; \
8808     ret
8809 
8810 SYSCALL(fork)
8811 SYSCALL(exit)
8812 SYSCALL(wait)
8813 SYSCALL(pipe)
8814 SYSCALL(read)
8815 SYSCALL(write)
8816 SYSCALL(close)
8817 SYSCALL(kill)
8818 SYSCALL(exec)
8819 SYSCALL(open)
8820 SYSCALL(mknod)
8821 SYSCALL(unlink)
8822 SYSCALL(fstat)
8823 SYSCALL(link)
8824 SYSCALL(mkdir)
8825 SYSCALL(chdir)
8826 SYSCALL(dup)
8827 SYSCALL(getpid)
8828 SYSCALL(sbrk)
8829 SYSCALL(sleep)
8830 SYSCALL(uptime)
8831 
8832 SYSCALL(greet)
8833 SYSCALL(numvp)
8834 SYSCALL(numpp)
8835 SYSCALL(getptsize)
8836 SYSCALL(mmap)
8837 SYSCALL(munmap)
8838 SYSCALL(shm_open)
8839 SYSCALL(shm_get)
8840 SYSCALL(shm_close)
8841 
8842 
8843 
8844 
8845 
8846 
8847 
8848 
8849 
8850 
8851 
8852 #include "types.h"
8853 #include "stat.h"
8854 #include "user.h"
8855 #include "fcntl.h"
8856 
8857 char *argv[] = { "sh", 0 };
8858 
8859 int
8860 main(void)
8861 {
8862   int pid, wpid;
8863 
8864   if(open("console", O_RDWR) < 0){
8865     mknod("console", 1, 1);
8866     open("console", O_RDWR);
8867   }
8868   dup(0);  
8869   dup(0);  
8870 
8871   for(;;){
8872     printf(1, "init: starting sh\n");
8873     pid = fork();
8874     if(pid < 0){
8875       printf(1, "init: fork failed\n");
8876       exit();
8877     }
8878     if(pid == 0){
8879       exec("sh", argv);
8880       printf(1, "init: exec sh failed\n");
8881       exit();
8882     }
8883     while((wpid=wait()) >= 0 && wpid != pid)
8884       printf(1, "zombie!\n");
8885   }
8886 }
8887 
8888 
8889 
8890 
8891 
8892 
8893 
8894 
8895 
8896 
8897 
8898 
8899 
8900 
8901 
8902 #include "types.h"
8903 #include "user.h"
8904 #include "fcntl.h"
8905 
8906 
8907 #define EXEC  1
8908 #define REDIR 2
8909 #define PIPE  3
8910 #define LIST  4
8911 #define BACK  5
8912 
8913 #define MAXARGS 10
8914 
8915 struct cmd {
8916   int type;
8917 };
8918 
8919 struct execcmd {
8920   int type;
8921   char *argv[MAXARGS];
8922   char *eargv[MAXARGS];
8923 };
8924 
8925 struct redircmd {
8926   int type;
8927   struct cmd *cmd;
8928   char *file;
8929   char *efile;
8930   int mode;
8931   int fd;
8932 };
8933 
8934 struct pipecmd {
8935   int type;
8936   struct cmd *left;
8937   struct cmd *right;
8938 };
8939 
8940 struct listcmd {
8941   int type;
8942   struct cmd *left;
8943   struct cmd *right;
8944 };
8945 
8946 struct backcmd {
8947   int type;
8948   struct cmd *cmd;
8949 };
8950 int fork1(void);  
8951 void panic(char*);
8952 struct cmd *parsecmd(char*);
8953 
8954 
8955 void
8956 runcmd(struct cmd *cmd)
8957 {
8958   int p[2];
8959   struct backcmd *bcmd;
8960   struct execcmd *ecmd;
8961   struct listcmd *lcmd;
8962   struct pipecmd *pcmd;
8963   struct redircmd *rcmd;
8964 
8965   if(cmd == 0)
8966     exit();
8967 
8968   switch(cmd->type){
8969   default:
8970     panic("runcmd");
8971 
8972   case EXEC:
8973     ecmd = (struct execcmd*)cmd;
8974     if(ecmd->argv[0] == 0)
8975       exit();
8976     exec(ecmd->argv[0], ecmd->argv);
8977     printf(2, "exec %s failed\n", ecmd->argv[0]);
8978     break;
8979 
8980   case REDIR:
8981     rcmd = (struct redircmd*)cmd;
8982     close(rcmd->fd);
8983     if(open(rcmd->file, rcmd->mode) < 0){
8984       printf(2, "open %s failed\n", rcmd->file);
8985       exit();
8986     }
8987     runcmd(rcmd->cmd);
8988     break;
8989 
8990   case LIST:
8991     lcmd = (struct listcmd*)cmd;
8992     if(fork1() == 0)
8993       runcmd(lcmd->left);
8994     wait();
8995     runcmd(lcmd->right);
8996     break;
8997 
8998 
8999 
9000   case PIPE:
9001     pcmd = (struct pipecmd*)cmd;
9002     if(pipe(p) < 0)
9003       panic("pipe");
9004     if(fork1() == 0){
9005       close(1);
9006       dup(p[1]);
9007       close(p[0]);
9008       close(p[1]);
9009       runcmd(pcmd->left);
9010     }
9011     if(fork1() == 0){
9012       close(0);
9013       dup(p[0]);
9014       close(p[0]);
9015       close(p[1]);
9016       runcmd(pcmd->right);
9017     }
9018     close(p[0]);
9019     close(p[1]);
9020     wait();
9021     wait();
9022     break;
9023 
9024   case BACK:
9025     bcmd = (struct backcmd*)cmd;
9026     if(fork1() == 0)
9027       runcmd(bcmd->cmd);
9028     break;
9029   }
9030   exit();
9031 }
9032 
9033 int
9034 getcmd(char *buf, int nbuf)
9035 {
9036   printf(2, "$ ");
9037   memset(buf, 0, nbuf);
9038   gets(buf, nbuf);
9039   if(buf[0] == 0) 
9040     return -1;
9041   return 0;
9042 }
9043 
9044 
9045 
9046 
9047 
9048 
9049 
9050 int
9051 main(void)
9052 {
9053   static char buf[100];
9054   int fd;
9055 
9056   
9057   while((fd = open("console", O_RDWR)) >= 0){
9058     if(fd >= 3){
9059       close(fd);
9060       break;
9061     }
9062   }
9063 
9064   
9065   while(getcmd(buf, sizeof(buf)) >= 0){
9066     if(buf[0] == 'c' && buf[1] == 'd' && buf[2] == ' '){
9067       
9068       buf[strlen(buf)-1] = 0;  
9069       if(chdir(buf+3) < 0)
9070         printf(2, "cannot cd %s\n", buf+3);
9071       continue;
9072     }
9073     if(fork1() == 0)
9074       runcmd(parsecmd(buf));
9075     wait();
9076   }
9077   exit();
9078 }
9079 
9080 void
9081 panic(char *s)
9082 {
9083   printf(2, "%s\n", s);
9084   exit();
9085 }
9086 
9087 int
9088 fork1(void)
9089 {
9090   int pid;
9091 
9092   pid = fork();
9093   if(pid == -1)
9094     panic("fork");
9095   return pid;
9096 }
9097 
9098 
9099 
9100 
9101 
9102 struct cmd*
9103 execcmd(void)
9104 {
9105   struct execcmd *cmd;
9106 
9107   cmd = malloc(sizeof(*cmd));
9108   memset(cmd, 0, sizeof(*cmd));
9109   cmd->type = EXEC;
9110   return (struct cmd*)cmd;
9111 }
9112 
9113 struct cmd*
9114 redircmd(struct cmd *subcmd, char *file, char *efile, int mode, int fd)
9115 {
9116   struct redircmd *cmd;
9117 
9118   cmd = malloc(sizeof(*cmd));
9119   memset(cmd, 0, sizeof(*cmd));
9120   cmd->type = REDIR;
9121   cmd->cmd = subcmd;
9122   cmd->file = file;
9123   cmd->efile = efile;
9124   cmd->mode = mode;
9125   cmd->fd = fd;
9126   return (struct cmd*)cmd;
9127 }
9128 
9129 struct cmd*
9130 pipecmd(struct cmd *left, struct cmd *right)
9131 {
9132   struct pipecmd *cmd;
9133 
9134   cmd = malloc(sizeof(*cmd));
9135   memset(cmd, 0, sizeof(*cmd));
9136   cmd->type = PIPE;
9137   cmd->left = left;
9138   cmd->right = right;
9139   return (struct cmd*)cmd;
9140 }
9141 
9142 
9143 
9144 
9145 
9146 
9147 
9148 
9149 
9150 struct cmd*
9151 listcmd(struct cmd *left, struct cmd *right)
9152 {
9153   struct listcmd *cmd;
9154 
9155   cmd = malloc(sizeof(*cmd));
9156   memset(cmd, 0, sizeof(*cmd));
9157   cmd->type = LIST;
9158   cmd->left = left;
9159   cmd->right = right;
9160   return (struct cmd*)cmd;
9161 }
9162 
9163 struct cmd*
9164 backcmd(struct cmd *subcmd)
9165 {
9166   struct backcmd *cmd;
9167 
9168   cmd = malloc(sizeof(*cmd));
9169   memset(cmd, 0, sizeof(*cmd));
9170   cmd->type = BACK;
9171   cmd->cmd = subcmd;
9172   return (struct cmd*)cmd;
9173 }
9174 
9175 
9176 
9177 
9178 
9179 
9180 
9181 
9182 
9183 
9184 
9185 
9186 
9187 
9188 
9189 
9190 
9191 
9192 
9193 
9194 
9195 
9196 
9197 
9198 
9199 
9200 
9201 
9202 char whitespace[] = " \t\r\n\v";
9203 char symbols[] = "<|>&;()";
9204 
9205 int
9206 gettoken(char **ps, char *es, char **q, char **eq)
9207 {
9208   char *s;
9209   int ret;
9210 
9211   s = *ps;
9212   while(s < es && strchr(whitespace, *s))
9213     s++;
9214   if(q)
9215     *q = s;
9216   ret = *s;
9217   switch(*s){
9218   case 0:
9219     break;
9220   case '|':
9221   case '(':
9222   case ')':
9223   case ';':
9224   case '&':
9225   case '<':
9226     s++;
9227     break;
9228   case '>':
9229     s++;
9230     if(*s == '>'){
9231       ret = '+';
9232       s++;
9233     }
9234     break;
9235   default:
9236     ret = 'a';
9237     while(s < es && !strchr(whitespace, *s) && !strchr(symbols, *s))
9238       s++;
9239     break;
9240   }
9241   if(eq)
9242     *eq = s;
9243 
9244   while(s < es && strchr(whitespace, *s))
9245     s++;
9246   *ps = s;
9247   return ret;
9248 }
9249 
9250 int
9251 peek(char **ps, char *es, char *toks)
9252 {
9253   char *s;
9254 
9255   s = *ps;
9256   while(s < es && strchr(whitespace, *s))
9257     s++;
9258   *ps = s;
9259   return *s && strchr(toks, *s);
9260 }
9261 
9262 struct cmd *parseline(char**, char*);
9263 struct cmd *parsepipe(char**, char*);
9264 struct cmd *parseexec(char**, char*);
9265 struct cmd *nulterminate(struct cmd*);
9266 
9267 struct cmd*
9268 parsecmd(char *s)
9269 {
9270   char *es;
9271   struct cmd *cmd;
9272 
9273   es = s + strlen(s);
9274   cmd = parseline(&s, es);
9275   peek(&s, es, "");
9276   if(s != es){
9277     printf(2, "leftovers: %s\n", s);
9278     panic("syntax");
9279   }
9280   nulterminate(cmd);
9281   return cmd;
9282 }
9283 
9284 struct cmd*
9285 parseline(char **ps, char *es)
9286 {
9287   struct cmd *cmd;
9288 
9289   cmd = parsepipe(ps, es);
9290   while(peek(ps, es, "&")){
9291     gettoken(ps, es, 0, 0);
9292     cmd = backcmd(cmd);
9293   }
9294   if(peek(ps, es, ";")){
9295     gettoken(ps, es, 0, 0);
9296     cmd = listcmd(cmd, parseline(ps, es));
9297   }
9298   return cmd;
9299 }
9300 struct cmd*
9301 parsepipe(char **ps, char *es)
9302 {
9303   struct cmd *cmd;
9304 
9305   cmd = parseexec(ps, es);
9306   if(peek(ps, es, "|")){
9307     gettoken(ps, es, 0, 0);
9308     cmd = pipecmd(cmd, parsepipe(ps, es));
9309   }
9310   return cmd;
9311 }
9312 
9313 struct cmd*
9314 parseredirs(struct cmd *cmd, char **ps, char *es)
9315 {
9316   int tok;
9317   char *q, *eq;
9318 
9319   while(peek(ps, es, "<>")){
9320     tok = gettoken(ps, es, 0, 0);
9321     if(gettoken(ps, es, &q, &eq) != 'a')
9322       panic("missing file for redirection");
9323     switch(tok){
9324     case '<':
9325       cmd = redircmd(cmd, q, eq, O_RDONLY, 0);
9326       break;
9327     case '>':
9328       cmd = redircmd(cmd, q, eq, O_WRONLY|O_CREATE, 1);
9329       break;
9330     case '+':  
9331       cmd = redircmd(cmd, q, eq, O_WRONLY|O_CREATE, 1);
9332       break;
9333     }
9334   }
9335   return cmd;
9336 }
9337 
9338 
9339 
9340 
9341 
9342 
9343 
9344 
9345 
9346 
9347 
9348 
9349 
9350 struct cmd*
9351 parseblock(char **ps, char *es)
9352 {
9353   struct cmd *cmd;
9354 
9355   if(!peek(ps, es, "("))
9356     panic("parseblock");
9357   gettoken(ps, es, 0, 0);
9358   cmd = parseline(ps, es);
9359   if(!peek(ps, es, ")"))
9360     panic("syntax - missing )");
9361   gettoken(ps, es, 0, 0);
9362   cmd = parseredirs(cmd, ps, es);
9363   return cmd;
9364 }
9365 
9366 struct cmd*
9367 parseexec(char **ps, char *es)
9368 {
9369   char *q, *eq;
9370   int tok, argc;
9371   struct execcmd *cmd;
9372   struct cmd *ret;
9373 
9374   if(peek(ps, es, "("))
9375     return parseblock(ps, es);
9376 
9377   ret = execcmd();
9378   cmd = (struct execcmd*)ret;
9379 
9380   argc = 0;
9381   ret = parseredirs(ret, ps, es);
9382   while(!peek(ps, es, "|)&;")){
9383     if((tok=gettoken(ps, es, &q, &eq)) == 0)
9384       break;
9385     if(tok != 'a')
9386       panic("syntax");
9387     cmd->argv[argc] = q;
9388     cmd->eargv[argc] = eq;
9389     argc++;
9390     if(argc >= MAXARGS)
9391       panic("too many args");
9392     ret = parseredirs(ret, ps, es);
9393   }
9394   cmd->argv[argc] = 0;
9395   cmd->eargv[argc] = 0;
9396   return ret;
9397 }
9398 
9399 
9400 
9401 struct cmd*
9402 nulterminate(struct cmd *cmd)
9403 {
9404   int i;
9405   struct backcmd *bcmd;
9406   struct execcmd *ecmd;
9407   struct listcmd *lcmd;
9408   struct pipecmd *pcmd;
9409   struct redircmd *rcmd;
9410 
9411   if(cmd == 0)
9412     return 0;
9413 
9414   switch(cmd->type){
9415   case EXEC:
9416     ecmd = (struct execcmd*)cmd;
9417     for(i=0; ecmd->argv[i]; i++)
9418       *ecmd->eargv[i] = 0;
9419     break;
9420 
9421   case REDIR:
9422     rcmd = (struct redircmd*)cmd;
9423     nulterminate(rcmd->cmd);
9424     *rcmd->efile = 0;
9425     break;
9426 
9427   case PIPE:
9428     pcmd = (struct pipecmd*)cmd;
9429     nulterminate(pcmd->left);
9430     nulterminate(pcmd->right);
9431     break;
9432 
9433   case LIST:
9434     lcmd = (struct listcmd*)cmd;
9435     nulterminate(lcmd->left);
9436     nulterminate(lcmd->right);
9437     break;
9438 
9439   case BACK:
9440     bcmd = (struct backcmd*)cmd;
9441     nulterminate(bcmd->cmd);
9442     break;
9443   }
9444   return cmd;
9445 }
9446 
9447 
9448 
9449 
9450 
9451 
9452 
9453 
9454 
9455 
9456 
9457 
9458 
9459 .code16                       
9460 .globl start
9461 start:
9462   cli                         
9463 
9464   
9465   xorw    %ax,%ax             
9466   movw    %ax,%ds             
9467   movw    %ax,%es             
9468   movw    %ax,%ss             
9469 
9470   
9471   
9472 seta20.1:
9473   inb     $0x64,%al               
9474   testb   $0x2,%al
9475   jnz     seta20.1
9476 
9477   movb    $0xd1,%al               
9478   outb    %al,$0x64
9479 
9480 seta20.2:
9481   inb     $0x64,%al               
9482   testb   $0x2,%al
9483   jnz     seta20.2
9484 
9485   movb    $0xdf,%al               
9486   outb    %al,$0x60
9487 
9488   
9489   
9490   
9491   lgdt    gdtdesc
9492   movl    %cr0, %eax
9493   orl     $CR0_PE, %eax
9494   movl    %eax, %cr0
9495 
9496 
9497 
9498 
9499 
9500   
9501   
9502   
9503   ljmp    $(SEG_KCODE<<3), $start32
9504 
9505 .code32  
9506 start32:
9507   
9508   movw    $(SEG_KDATA<<3), %ax    
9509   movw    %ax, %ds                
9510   movw    %ax, %es                
9511   movw    %ax, %ss                
9512   movw    $0, %ax                 
9513   movw    %ax, %fs                
9514   movw    %ax, %gs                
9515 
9516   
9517   movl    $start, %esp
9518   call    bootmain
9519 
9520   
9521   
9522   movw    $0x8a00, %ax            
9523   movw    %ax, %dx
9524   outw    %ax, %dx
9525   movw    $0x8ae0, %ax            
9526   outw    %ax, %dx
9527 spin:
9528   jmp     spin
9529 
9530 
9531 .p2align 2                                
9532 gdt:
9533   SEG_NULLASM                             
9534   SEG_ASM(STA_X|STA_R, 0x0, 0xffffffff)   
9535   SEG_ASM(STA_W, 0x0, 0xffffffff)         
9536 
9537 gdtdesc:
9538   .word   (gdtdesc - gdt - 1)             
9539   .long   gdt                             
9540 
9541 
9542 
9543 
9544 
9545 
9546 
9547 
9548 
9549 
9550 
9551 
9552 
9553 
9554 
9555 
9556 
9557 #include "types.h"
9558 #include "elf.h"
9559 #include "x86.h"
9560 #include "memlayout.h"
9561 
9562 #define SECTSIZE  512
9563 
9564 void readseg(uchar*, uint, uint);
9565 
9566 void
9567 bootmain(void)
9568 {
9569   struct elfhdr *elf;
9570   struct proghdr *ph, *eph;
9571   void (*entry)(void);
9572   uchar* pa;
9573 
9574   elf = (struct elfhdr*)0x10000;  
9575 
9576   
9577   readseg((uchar*)elf, 4096, 0);
9578 
9579   
9580   if(elf->magic != ELF_MAGIC)
9581     return;  
9582 
9583   
9584   ph = (struct proghdr*)((uchar*)elf + elf->phoff);
9585   eph = ph + elf->phnum;
9586   for(; ph < eph; ph++){
9587     pa = (uchar*)ph->paddr;
9588     readseg(pa, ph->filesz, ph->off);
9589     if(ph->memsz > ph->filesz)
9590       stosb(pa + ph->filesz, 0, ph->memsz - ph->filesz);
9591   }
9592 
9593   
9594   
9595   entry = (void(*)(void))(elf->entry);
9596   entry();
9597 }
9598 
9599 
9600 void
9601 waitdisk(void)
9602 {
9603   
9604   while((inb(0x1F7) & 0xC0) != 0x40)
9605     ;
9606 }
9607 
9608 
9609 void
9610 readsect(void *dst, uint offset)
9611 {
9612   
9613   waitdisk();
9614   outb(0x1F2, 1);   
9615   outb(0x1F3, offset);
9616   outb(0x1F4, offset >> 8);
9617   outb(0x1F5, offset >> 16);
9618   outb(0x1F6, (offset >> 24) | 0xE0);
9619   outb(0x1F7, 0x20);  
9620 
9621   
9622   waitdisk();
9623   insl(0x1F0, dst, SECTSIZE/4);
9624 }
9625 
9626 
9627 
9628 void
9629 readseg(uchar* pa, uint count, uint offset)
9630 {
9631   uchar* epa;
9632 
9633   epa = pa + count;
9634 
9635   
9636   pa -= offset % SECTSIZE;
9637 
9638   
9639   offset = (offset / SECTSIZE) + 1;
9640 
9641   
9642   
9643   
9644   for(; pa < epa; pa += SECTSIZE, offset++)
9645     readsect(pa, offset);
9646 }
9647 
9648 
9649 
9650 /* Simple linker script for the JOS kernel.
9651    See the GNU ld 'info' manual ("info ld") to learn the syntax. */
9652 
9653 OUTPUT_FORMAT("elf32-i386", "elf32-i386", "elf32-i386")
9654 OUTPUT_ARCH(i386)
9655 ENTRY(_start)
9656 
9657 SECTIONS
9658 {
9659 	/* Link the kernel at this address: "." means the current address */
9660         /* Must be equal to KERNLINK */
9661 	. = 0x80100000;
9662 
9663 	.text : AT(0x100000) {
9664 		*(.text .stub .text.* .gnu.linkonce.t.*)
9665 	}
9666 
9667 	PROVIDE(etext = .);	/* Define the 'etext' symbol to this value */
9668 
9669 	.rodata : {
9670 		*(.rodata .rodata.* .gnu.linkonce.r.*)
9671 	}
9672 
9673 	/* Include debugging information in kernel memory */
9674 	.stab : {
9675 		PROVIDE(__STAB_BEGIN__ = .);
9676 		*(.stab);
9677 		PROVIDE(__STAB_END__ = .);
9678 	}
9679 
9680 	.stabstr : {
9681 		PROVIDE(__STABSTR_BEGIN__ = .);
9682 		*(.stabstr);
9683 		PROVIDE(__STABSTR_END__ = .);
9684 	}
9685 
9686 	/* Adjust the address for the data segment to the next page */
9687 	. = ALIGN(0x1000);
9688 
9689 	/* Conventionally, Unix linkers provide pseudo-symbols
9690 	 * etext, edata, and end, at the end of the text, data, and bss.
9691 	 * For the kernel mapping, we need the address at the beginning
9692 	 * of the data section, but that's not one of the conventional
9693 	 * symbols, because the convention started before there was a
9694 	 * read-only rodata section between text and data. */
9695 	PROVIDE(data = .);
9696 
9697 
9698 
9699 
9700 	/* The data segment */
9701 	.data : {
9702 		*(.data)
9703 	}
9704 
9705 	PROVIDE(edata = .);
9706 
9707 	.bss : {
9708 		*(.bss)
9709 	}
9710 
9711 	PROVIDE(end = .);
9712 
9713 	/DISCARD/ : {
9714 		*(.eh_frame .note.GNU-stack)
9715 	}
9716 }
9717 
9718 
9719 
9720 
9721 
9722 
9723 
9724 
9725 
9726 
9727 
9728 
9729 
9730 
9731 
9732 
9733 
9734 
9735 
9736 
9737 
9738 
9739 
9740 
9741 
9742 
9743 
9744 
9745 
9746 
9747 
9748 
9749 
